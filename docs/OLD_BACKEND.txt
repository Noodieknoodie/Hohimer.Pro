api\__init__.py
```py
"""API endpoints for the application."""
from . import clients, contracts, payments, files
```

api\clients.py
```py
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from core.database import execute_query
from models.schemas import Client, Contract, ClientDashboard, PaymentStatusInfo, ComplianceInfo, NextPaymentDue
from services.client_service import get_all_clients, get_client_by_id
from services.contract_service import get_client_contract
from services.payment_service import get_client_payments
from repositories.calculation_repository import CalculationRepository
from repositories.payment_repository import PaymentRepository

router = APIRouter(prefix="/clients", tags=["clients"])

@router.get("/", response_model=List[Client])
async def read_clients(
    provider: Optional[str] = Query(None, description="Filter by provider name")
):
    try:
        clients = get_all_clients(provider)
        return clients
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{client_id}", response_model=Client)
async def read_client(client_id: int):
    try:
        client = get_client_by_id(client_id)
        if not client:
            raise HTTPException(status_code=404, detail="Client not found")
        return client
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# @router.get("/{client_id}/summary", response_model=ClientSummary)
# async def read_client_summary(client_id: int):
#     try:
#         summary = get_client_summary(client_id)
#         if not summary:
#             raise HTTPException(status_code=404, detail="Client not found")
#         return summary
#     except HTTPException:
#         raise
#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))

@router.get("/{client_id}/contract", response_model=Contract)
async def read_client_contract(client_id: int):
    try:
        contract = get_client_contract(client_id)
        if not contract:
            raise HTTPException(status_code=404, detail="Contract not found")
        return contract
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{client_id}/dashboard", response_model=ClientDashboard)
async def get_client_dashboard(client_id: int):
    """
    Single endpoint providing ALL calculated data for a client.
    Frontend should call ONLY this for dashboard display.
    """
    try:
        # Get client info
        client = get_client_by_id(client_id)
        if not client:
            raise HTTPException(status_code=404, detail="Client not found")
        
        # Get contract info
        contract = get_client_contract(client_id)
        
        # Get payment status using repository
        payment_status_data = CalculationRepository.calculate_payment_status(client_id)
        payment_status = PaymentStatusInfo(**payment_status_data)
        
        # Get compliance info using repository
        compliance_status, compliance_reason = CalculationRepository.map_status_to_compliance(payment_status_data)
        compliance_color = "red" if compliance_status == "non_compliant" else "yellow" if payment_status_data["current_status"] == "Due" else "green"
        compliance = ComplianceInfo(
            status=compliance_status,
            reason=compliance_reason,
            color=compliance_color
        )
        
        # Get recent payments
        recent_payments = get_client_payments(client_id, page=1, limit=5)
        
        # Calculate next payment due info
        next_payment_due = NextPaymentDue(
            period=payment_status_data["current_period"],
            due_date=None,  # Could be calculated based on schedule
            expected_fee=None  # Could be calculated if contract exists
        )
        
        # If we have contract and it's percentage-based, calculate expected fee
        if contract and contract.fee_type in ["percentage", "percent"]:
            fee_calc = CalculationRepository.calculate_expected_fee(contract.contract_id)
            next_payment_due.expected_fee = fee_calc.expected_fee
        elif contract and contract.fee_type == "flat":
            next_payment_due.expected_fee = contract.flat_rate
        
        return ClientDashboard(
            client=client,
            contract=contract,
            payment_status=payment_status,
            compliance=compliance,
            recent_payments=recent_payments,
            next_payment_due=next_payment_due
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

api\contracts.py
```py
from fastapi import APIRouter, HTTPException, Query
from typing import Optional

from models.schemas import Contract
from services.contract_service import (
    get_contract_by_id, 
    get_client_contract
)
from repositories.calculation_repository import CalculationRepository

router = APIRouter(prefix="/contracts", tags=["contracts"])

@router.get("/{contract_id}", response_model=Contract)
async def read_contract(contract_id: int):
    try:
        contract = get_contract_by_id(contract_id)
        if not contract:
            raise HTTPException(status_code=404, detail="Contract not found")
        return contract
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/client/{client_id}", response_model=Contract)
async def read_client_contract(client_id: int):
    try:
        contract = get_client_contract(client_id)
        if not contract:
            raise HTTPException(status_code=404, detail="Contract not found for this client")
        return contract
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{contract_id}/expected-fee", response_model=Contract)
async def calculate_fee(
    contract_id: int,
    total_assets: Optional[float] = Query(None, description="Total assets for percentage-based fees")
):
    try:
        fee_calculation = CalculationRepository.calculate_expected_fee(contract_id, total_assets)
        return fee_calculation
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

api\files.py
```py
from fastapi import APIRouter, HTTPException, Path, Query
from typing import List, Optional, Dict, Any
from models.schemas import File
from services.file_service import (
    has_files_for_payment, 
    has_files_for_client, 
    get_payment_files,
    get_full_file_path,
    validate_file_exists
)

# Create a router with the correct prefix for files
router = APIRouter(prefix="/files", tags=["files"])

@router.get("/check/payment/{payment_id}", response_model=dict)
async def check_payment_files(payment_id: int = Path(..., ge=1)):
    """Check if a payment has any files attached to it."""
    try:
        has_files = has_files_for_payment(payment_id)
        return {"has_files": has_files}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/check/client/{client_id}", response_model=dict)
async def check_client_files(client_id: int = Path(..., ge=1)):
    """Check if a client has any files available."""
    try:
        has_files = has_files_for_client(client_id)
        return {"has_files": has_files}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/payment/{payment_id}", response_model=List[File])
async def get_files_for_payment(payment_id: int = Path(..., ge=1)):
    """Get all files associated with a specific payment, with their full paths."""
    try:
        files = get_payment_files(payment_id)
        
        # Enhance file data with full paths for frontend display
        for file in files:
            if "onedrive_path" in file:
                file_path = get_full_file_path(file["onedrive_path"])
                file["full_path"] = file_path
                
                # Check if file exists
                file_exists = validate_file_exists(file_path)
                file["exists"] = file_exists
                
        return files
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

api\payments.py
```py
from fastapi import APIRouter, HTTPException, Query, Path
from typing import List, Optional, Dict, Any
from pydantic import BaseModel
from models.schemas import Payment, PaymentCreate, AvailablePeriods, Contract
from services.payment_service import (
    get_client_payments, 
    get_payment_by_id,
    create_payment,
    update_payment,
    delete_payment,
    get_available_periods
)
# Import file service at the top level to avoid circular imports
from services.file_service import has_files_for_payment
from repositories.calculation_repository import CalculationRepository

# Main router for all payment-related endpoints
router = APIRouter(tags=["payments"])

# Client payment endpoints
@router.get("/clients/{client_id}/payments", response_model=List[Payment])
async def read_client_payments(
    client_id: int,
    page: int = Query(1, ge=1, description="Page number"),
    limit: int = Query(10, ge=1, le=100, description="Items per page"),
    year: Optional[int] = Query(None, description="Filter by year")
):
    try:
        # Convert year to int if it's a valid integer string, otherwise use None
        filtered_year = year
        if isinstance(year, str) and year.lower() == 'null':
            filtered_year = None
        payments = get_client_payments(
            client_id=client_id, 
            page=page, 
            limit=limit, 
            year=filtered_year
        )
        # Ensure has_files property is explicitly set in each payment
        for payment in payments:
            if payment.has_files is None:
                payment.has_files = has_files_for_payment(payment.payment_id)
        return payments
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Payment detail endpoint
@router.get("/payments/{payment_id}", response_model=Payment)
async def read_payment(payment_id: int = Path(..., ge=1)):
    try:
        payment = get_payment_by_id(payment_id)
        if not payment:
            raise HTTPException(status_code=404, detail="Payment not found")
        # Ensure has_files property is explicitly set
        if payment.has_files is None:
            payment.has_files = has_files_for_payment(payment.payment_id)
        return payment
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Create payment endpoint
@router.post("/payments", response_model=Payment)
async def create_new_payment(payment: PaymentCreate):
    try:
        new_payment = create_payment(payment)
        return new_payment
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# Update payment endpoint
@router.put("/payments/{payment_id}", response_model=Payment)
async def update_existing_payment(
    payment_id: int = Path(..., ge=1),
    payment: PaymentCreate = None
):
    try:
        updated_payment = update_payment(payment_id, payment)
        if not updated_payment:
            raise HTTPException(status_code=404, detail="Payment not found")
        return updated_payment
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# Delete payment endpoint
@router.delete("/payments/{payment_id}", status_code=204)
async def delete_existing_payment(payment_id: int = Path(..., ge=1)):
    try:
        success = delete_payment(payment_id)
        if not success:
            raise HTTPException(status_code=404, detail="Payment not found")
        return None
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Contract periods endpoint
@router.get("/contracts/{contract_id}/periods", response_model=AvailablePeriods)
async def read_available_periods(
    contract_id: int,
    client_id: int = Query(..., description="Client ID is required"),
):
    try:
        periods = get_available_periods(contract_id, client_id)
        return periods
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Calculation endpoints for frontend business logic removal

class FeeCalculationRequest(BaseModel):
    contract_id: int
    total_assets: Optional[float] = None

class VarianceCalculation(BaseModel):
    status: str
    message: str
    difference: Optional[float] = None
    percent_difference: Optional[float] = None

@router.post("/calculate-fee", response_model=Contract)
async def calculate_fee_endpoint(request: FeeCalculationRequest):
    """
    Calculate expected fee for payment form.
    Replaces frontend calculateExpectedFee() function.
    """
    try:
        calculation = CalculationRepository.calculate_expected_fee(
            request.contract_id, 
            request.total_assets
        )
        return calculation
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/calculate-variance")
async def calculate_payment_variance(
    actual_fee: float,
    expected_fee: float
) -> VarianceCalculation:
    """
    Calculate variance between actual and expected fee.
    Replaces frontend calculateVariance() function.
    """
    try:
        if actual_fee is None or expected_fee is None:
            return VarianceCalculation(
                status="unknown", 
                message="N/A"
            )

        difference = actual_fee - expected_fee
        percent_difference = (difference / expected_fee) * 100 if expected_fee != 0 else 0
        abs_percent_difference = abs(percent_difference)

        # Format currency
        def format_currency(value):
            return f"${value:,.2f}"

        if abs(difference) < 0.01:
            return VarianceCalculation(
                status="exact", 
                message="Exact Match",
                difference=difference,
                percent_difference=percent_difference
            )
        elif abs_percent_difference <= 5:
            return VarianceCalculation(
                status="acceptable",
                message=f"{format_currency(difference)} ({percent_difference:.1f}%)",
                difference=difference,
                percent_difference=percent_difference
            )
        elif abs_percent_difference <= 15:
            return VarianceCalculation(
                status="warning",
                message=f"{format_currency(difference)} ({percent_difference:.1f}%)",
                difference=difference,
                percent_difference=percent_difference
            )
        else:
            return VarianceCalculation(
                status="alert",
                message=f"{format_currency(difference)} ({percent_difference:.1f}%)",
                difference=difference,
                percent_difference=percent_difference
            )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

core\__init__.py
```py
# Package initialization
```

core\config.py
```py
# backend/core/config.py

import os
import sys
from pathlib import Path
# Use absolute import instead of relative
from utils.user_utils import get_user_base_path, validate_db_path

# Define app mode based on environment variable or auto-detection
APP_MODE = os.environ.get("APP_MODE", "auto").lower()  # 'home', 'office', or 'auto'

# Path to local database (for home mode)
LOCAL_DB_PATH = Path(__file__).parent.parent / "data" / "401k_payments.db"

# Get base path (for office mode)
BASE_PATH = get_user_base_path()
# Use OneDrive path with dynamic username instead of network path
OFFICE_DB_PATH = BASE_PATH / "HohimerPro" / "database" / "401k_payments.db"


# Determine which database to use based on mode and availability
if APP_MODE == "home":
    DB_PATH = LOCAL_DB_PATH
elif APP_MODE == "office":
    DB_PATH = OFFICE_DB_PATH
else:  # Auto-detect based on file availability
    if OFFICE_DB_PATH.exists():
        print("Auto-detected OFFICE mode - using OneDrive database")
        DB_PATH = OFFICE_DB_PATH
        APP_MODE = "office"
    else:
        print("Auto-detected HOME mode - using local database")
        DB_PATH = LOCAL_DB_PATH
        APP_MODE = "home"

DB_BACKUP_PATH = (BASE_PATH / "HohimerPro" / "database" / "db_backups" 
                  if APP_MODE == "office" else Path(__file__).parent.parent / "data" / "backup_dbs")

# Validate the database path to provide early and clear feedback
try:
    validate_db_path(DB_PATH)
    print(f"Successfully connected to database at: {DB_PATH}")
    print(f"Running in {APP_MODE.upper()} mode")
except (FileNotFoundError, Exception) as e:
    print(f"ERROR: {str(e)}")
    print(f"Failed to access database at: {DB_PATH}")
    
    # If in auto mode and first attempt failed, try the alternative
    if APP_MODE == "auto" and DB_PATH == OFFICE_DB_PATH:
        print("Attempting to use local database instead...")
        DB_PATH = LOCAL_DB_PATH
        APP_MODE = "home"
        try:
            validate_db_path(DB_PATH)
            print(f"Successfully connected to database at: {DB_PATH}")
            print(f"Running in {APP_MODE.upper()} mode")
        except (FileNotFoundError, Exception) as e2:
            print(f"ERROR: {str(e2)}")
            print("Unable to connect to either office or home database")
    elif APP_MODE == "auto" and DB_PATH == LOCAL_DB_PATH:
        print("Attempting to use office database instead...")
        DB_PATH = OFFICE_DB_PATH
        APP_MODE = "office"
        try:
            validate_db_path(DB_PATH)
            print(f"Successfully connected to database at: {DB_PATH}")
            print(f"Running in {APP_MODE.upper()} mode")
        except (FileNotFoundError, Exception) as e2:
            print(f"ERROR: {str(e2)}")
            print("Unable to connect to either office or home database")

PATHS = {
    'BASE_PATH': BASE_PATH,
    'DB_PATH': DB_PATH,
    'DB_BACKUP_PATH': DB_BACKUP_PATH,
    'APP_MODE': APP_MODE,
}

ORIGINS = [
    "http://localhost:3000",
    "http://localhost:8000",
    "http://localhost:6069",
    "http://127.0.0.1:3000",
    "http://127.0.0.1:8000",
    "http://127.0.0.1:6069",
    "http://10.10.1.64:6069",
    "http://10.10.1.64:8000",
    "http://10.10.1.185:6069",
    "http://10.10.1.185:8000",
    "*"  # Allow all origins - use this temporarily if specific IPs don't work
]

# Application metadata
APP_NAME = "HohimerPro - 401K Payments"
APP_VERSION = "1.0"
```

core\database.py
```py
import sqlite3
import os
from contextlib import contextmanager
from typing import Dict, List, Tuple, Union, Any
from fastapi import HTTPException
from .config import DB_PATH

def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

@contextmanager
def get_db_connection():
    try:
        # Check if file exists before attempting connection
        if not os.path.exists(DB_PATH):
            error_msg = f"Database file not found at: {DB_PATH}"
            print(f"ERROR: {error_msg}")
            raise FileNotFoundError(error_msg)
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = dict_factory
        try:
            yield conn
        finally:
            conn.close()
    except sqlite3.Error as e:
        error_msg = f"Database connection error: {str(e)}"
        print(f"ERROR: {error_msg}")
        raise HTTPException(status_code=500, detail=error_msg)
    except Exception as e:
        error_msg = f"Unexpected error accessing database: {str(e)}"
        print(f"ERROR: {error_msg}")
        raise HTTPException(status_code=500, detail=error_msg)

@contextmanager
def get_db_transaction():
    """Context manager for database transactions with automatic commit/rollback."""
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = dict_factory
        yield conn
        conn.commit()
    except Exception as e:
        if conn:
            conn.rollback()
        error_msg = f"Transaction error: {str(e)}"
        print(f"ERROR: {error_msg}")
        raise HTTPException(status_code=500, detail=error_msg)
    finally:
        if conn:
            conn.close()

def execute_transaction(queries_and_params):
    """Execute multiple queries in a single transaction."""
    with get_db_transaction() as conn:
        cursor = conn.cursor()
        results = []
        
        for query, params in queries_and_params:
            cursor.execute(query, params)
            if query.strip().upper().startswith(("INSERT", "UPDATE", "DELETE")):
                results.append({"lastrowid": cursor.lastrowid, "rowcount": cursor.rowcount})
            else:
                results.append(cursor.fetchall())
                
        return results

def execute_query(
    query: str, 
    params: Union[Tuple, Dict, List] = None, 
    fetch_one: bool = False
) -> List[Dict[str, Any]]:
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            if query.strip().upper().startswith(("INSERT", "UPDATE", "DELETE")):
                conn.commit()
                return {"lastrowid": cursor.lastrowid, "rowcount": cursor.rowcount}
            if fetch_one:
                return cursor.fetchone()
            return cursor.fetchall()
    except HTTPException:
        # Re-raise HTTP exceptions from get_db_connection
        raise
    except sqlite3.Error as e:
        error_msg = f"Database query error: {str(e)}\nQuery: {query}"
        print(f"ERROR: {error_msg}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    except Exception as e:
        error_msg = f"Unexpected error executing query: {str(e)}\nQuery: {query}"
        print(f"ERROR: {error_msg}")
        raise HTTPException(status_code=500, detail=f"Server error: {str(e)}")
```

data\SCHEMA_REFERENCE.sql
```sql
-- SELECT sql FROM sqlite_master WHERE type IN ('table', 'index', 'trigger', 'view') AND sql NOT NULL;
CREATE TABLE quarterly_summaries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    client_id INTEGER NOT NULL,
    year INTEGER NOT NULL,
    quarter INTEGER NOT NULL,
    total_payments REAL,
    total_assets REAL,
    payment_count INTEGER,
    avg_payment REAL,
    expected_total REAL,
    last_updated DATE, -- remember, in SQLite, Date and Text are interchangeable - formatted as YYYY-MM-DD regarless 
    FOREIGN KEY(client_id) REFERENCES clients(client_id) ON DELETE CASCADE,
    UNIQUE(client_id, year, quarter)
);
CREATE TABLE yearly_summaries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    client_id INTEGER NOT NULL,
    year INTEGER NOT NULL,
    total_payments REAL,
    total_assets REAL,
    payment_count INTEGER,
    avg_payment REAL,
    yoy_growth REAL,
    last_updated DATE,
    FOREIGN KEY(client_id) REFERENCES clients(client_id) ON DELETE CASCADE,
    UNIQUE(client_id, year)
);
CREATE TABLE contacts (
    contact_id INTEGER PRIMARY KEY AUTOINCREMENT,
    client_id INTEGER NOT NULL,
    contact_type TEXT NOT NULL,
    contact_name TEXT,
    phone TEXT,
    email TEXT,
    fax TEXT,
    physical_address TEXT,
    mailing_address TEXT,
    valid_from DATETIME DEFAULT CURRENT_TIMESTAMP,
    valid_to DATETIME,
    FOREIGN KEY(client_id) REFERENCES clients(client_id) ON DELETE CASCADE
);
CREATE INDEX idx_quarterly_lookup ON quarterly_summaries(client_id, year, quarter);
CREATE INDEX idx_yearly_lookup ON yearly_summaries(client_id, year);
CREATE INDEX idx_contacts_client_id ON contacts(client_id);
CREATE INDEX idx_contacts_type ON contacts(client_id, contact_type);
CREATE TABLE "contracts" (
	"contract_id"	INTEGER NOT NULL,
	"client_id"	INTEGER NOT NULL,
	"contract_number"	TEXT,
	"provider_name"	TEXT,
	"contract_start_date"	DATE,
	"fee_type"	TEXT,
	"percent_rate"	REAL,
	"flat_rate"	REAL,
	"payment_schedule"	TEXT,
	"num_people"	INTEGER,
	"notes"	TEXT,
	"valid_from"	DATETIME DEFAULT CURRENT_TIMESTAMP,
	"valid_to"	DATETIME,
	PRIMARY KEY("contract_id" AUTOINCREMENT),
	FOREIGN KEY("client_id") REFERENCES "clients"("client_id") ON DELETE CASCADE
);
CREATE INDEX idx_contracts_client_id ON contracts(client_id);
CREATE INDEX idx_contracts_provider ON contracts(provider_name);
CREATE TRIGGER update_yearly_after_quarterly
    AFTER INSERT ON quarterly_summaries
    BEGIN
        INSERT OR REPLACE INTO yearly_summaries 
        (client_id, year, total_payments, total_assets, payment_count, avg_payment, yoy_growth, last_updated)
        SELECT 
            client_id, 
            year, 
            SUM(total_payments), 
            AVG(total_assets), 
            SUM(payment_count), 
            AVG(avg_payment),
            NULL,
            datetime('now')
        FROM quarterly_summaries 
        WHERE client_id = NEW.client_id 
            AND year = NEW.year
        GROUP BY client_id, year;
    END;
CREATE TABLE "clients" (
	"client_id"	INTEGER NOT NULL,
	"display_name"	TEXT NOT NULL,
	"full_name"	TEXT,
	"ima_signed_date"	DATE,
	"onedrive_folder_path"	TEXT,
	"valid_from"	DATETIME DEFAULT CURRENT_TIMESTAMP,
	"valid_to"	DATETIME,
	PRIMARY KEY("client_id" AUTOINCREMENT)
);
CREATE TABLE "client_files" (
    "file_id" INTEGER NOT NULL,
    "client_id" INTEGER NOT NULL,
    "file_name" TEXT NOT NULL,
    "onedrive_path" TEXT NOT NULL,
    "uploaded_at" DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY("file_id" AUTOINCREMENT),
    FOREIGN KEY("client_id") REFERENCES "clients"("client_id") ON DELETE CASCADE
);
CREATE TABLE "payment_files" (
    "payment_id" INTEGER NOT NULL,
    "file_id" INTEGER NOT NULL,
    "linked_at" DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY("payment_id", "file_id"),
    FOREIGN KEY("payment_id") REFERENCES "payments"("payment_id") ON DELETE CASCADE,
    FOREIGN KEY("file_id") REFERENCES "client_files"("file_id") ON DELETE CASCADE
);
CREATE TABLE "payments" (
	"payment_id"	INTEGER NOT NULL,
	"contract_id"	INTEGER NOT NULL,
	"client_id"	INTEGER NOT NULL,
	"received_date"	DATE,
	"total_assets"	INTEGER,
	"expected_fee"	REAL,
	"actual_fee"	REAL,
	"method"	TEXT,
	"notes"	TEXT,
	"valid_from"	DATETIME DEFAULT CURRENT_TIMESTAMP,
	"valid_to"	DATETIME,
	"applied_start_month"	INTEGER,
	"applied_start_month_year"	INTEGER,
	"applied_end_month"	INTEGER,
	"applied_end_month_year"	INTEGER,
	"applied_start_quarter"	INTEGER,
	"applied_start_quarter_year"	INTEGER,
	"applied_end_quarter"	INTEGER,
	"applied_end_quarter_year"	INTEGER,
	PRIMARY KEY("payment_id" AUTOINCREMENT),
	FOREIGN KEY("client_id") REFERENCES "clients"("client_id") ON DELETE CASCADE,
	FOREIGN KEY("contract_id") REFERENCES "contracts"("contract_id") ON DELETE CASCADE
);
CREATE INDEX idx_payments_client_id ON payments(client_id);
CREATE INDEX idx_payments_contract_id ON payments(contract_id);
CREATE INDEX idx_payments_date ON payments(client_id, received_date DESC);
CREATE TRIGGER update_quarterly_after_payment
AFTER INSERT ON payments
BEGIN
    INSERT OR REPLACE INTO quarterly_summaries 
    (client_id, year, quarter, total_payments, total_assets, payment_count, avg_payment, expected_total, last_updated)
    SELECT 
        client_id, 
        applied_start_quarter_year, 
        applied_start_quarter, 
        SUM(actual_fee), 
        AVG(total_assets), 
        COUNT(*), 
        AVG(actual_fee), 
        MAX(expected_fee), 
        datetime('now')
    FROM payments 
    WHERE client_id = NEW.client_id 
      AND applied_start_quarter_year = NEW.applied_start_quarter_year 
      AND applied_start_quarter = NEW.applied_start_quarter
    GROUP BY client_id, applied_start_quarter_year, applied_start_quarter;
END;
CREATE INDEX idx_payments_applied_months ON payments (
    client_id,
    applied_start_month_year,
    applied_start_month,
    applied_end_month_year,
    applied_end_month
);
CREATE VIEW payment_file_view AS
SELECT 
    p.payment_id,
    p.client_id,
    p.contract_id,
    p.received_date,
    p.actual_fee,
    CASE WHEN cf.file_id IS NOT NULL THEN 1 ELSE 0 END AS has_file,
    cf.file_id,
    cf.file_name,
    cf.onedrive_path
FROM 
    payments p
LEFT JOIN 
    payment_files pf ON p.payment_id = pf.payment_id
LEFT JOIN 
    client_files cf ON pf.file_id = cf.file_id;
CREATE TABLE "client_metrics" (
	"id"	INTEGER NOT NULL,
	"client_id"	INTEGER NOT NULL,
	"last_payment_date"	DATE,
	"last_payment_amount"	REAL,
	"last_payment_quarter"	INTEGER,
	"last_payment_year"	INTEGER,
	"total_ytd_payments"	REAL,
	"avg_quarterly_payment"	REAL,
	"last_recorded_assets"	REAL,
	"last_updated"	DATE,
	"next_payment_due"	DATE,
	UNIQUE("client_id"),
	PRIMARY KEY("id" AUTOINCREMENT),
	FOREIGN KEY("client_id") REFERENCES "clients"("client_id") ON DELETE CASCADE
);
CREATE INDEX idx_client_metrics_lookup ON client_metrics(client_id);
CREATE VIEW client_payment_status AS
        SELECT
            c.client_id,
            c.display_name,
            ct.payment_schedule,
            p.applied_end_month,
            p.applied_end_month_year,
            p.applied_end_quarter,
            p.applied_end_quarter_year
        FROM clients c
        JOIN contracts ct ON c.client_id = ct.client_id
        LEFT JOIN (
            SELECT client_id, MAX(received_date) AS latest_payment_date
            FROM payments
            WHERE valid_to IS NULL
            GROUP BY client_id
        ) latest ON latest.client_id = c.client_id
        LEFT JOIN payments p ON p.client_id = latest.client_id 
            AND p.received_date = latest.latest_payment_date
            AND p.valid_to IS NULL
        WHERE ct.valid_to IS NULL AND c.valid_to IS NULL;
```

main.py
```py
from fastapi import FastAPI, HTTPException, Path
from fastapi.middleware.cors import CORSMiddleware
# Use absolute imports instead of relative imports
from core.config import APP_NAME, APP_VERSION, ORIGINS
from api import clients, contracts, payments, files

app = FastAPI(
    title=APP_NAME,
    version=APP_VERSION,
    description="API for 401(k) payment tracking system",
)

# Add CORS middleware first, before including routers
app.add_middleware(
    CORSMiddleware,
    allow_origins=ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include all routers
app.include_router(clients.router)
app.include_router(contracts.router)
app.include_router(payments.router)
app.include_router(files.router)

@app.get("/")
async def root():
    return {"status": "ok", "message": f"{APP_NAME} API is running"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

models\__init__.py
```py

```

models\period.py
```py
"""
Period model to replace string-based period handling.
Fixes bugs with period comparisons and arithmetic operations.
"""
from typing import Union, List
from datetime import datetime
import re


class Period:
    """
    A Period represents either a monthly or quarterly period with proper comparison and arithmetic.
    
    Internal storage uses integers for year and value (month 1-12 or quarter 1-4).
    String representation maintained for backward compatibility with existing APIs.
    """
    
    def __init__(self, year: int, value: int, is_monthly: bool = True):
        """
        Initialize a Period.
        
        Args:
            year: The year (e.g., 2023, 2024)
            value: The month (1-12) for monthly periods or quarter (1-4) for quarterly periods
            is_monthly: True for monthly periods, False for quarterly periods
        """
        self.year = year
        self.value = value
        self.is_monthly = is_monthly
        
        # Validate inputs
        if is_monthly and not (1 <= value <= 12):
            raise ValueError(f"Monthly period value must be 1-12, got {value}")
        if not is_monthly and not (1 <= value <= 4):
            raise ValueError(f"Quarterly period value must be 1-4, got {value}")
        if year < 1900 or year > 2100:
            raise ValueError(f"Year must be reasonable (1900-2100), got {year}")
    
    @classmethod
    def from_string(cls, period_str: str) -> 'Period':
        """
        Parse a period string like "3-2024" (monthly) or "1-2024" (quarterly).
        
        For quarterly periods, we assume the format is "Q-YYYY" where Q is 1-4.
        For monthly periods, we assume the format is "M-YYYY" where M is 1-12.
        
        The distinction is made based on the value: 1-4 suggests quarterly, 5-12 suggests monthly.
        Values of 1-4 are ambiguous and default to monthly unless context suggests otherwise.
        """
        if not period_str or not isinstance(period_str, str):
            raise ValueError(f"Period string cannot be empty or None: {period_str}")
        
        # Handle the format with Q prefix for quarters (like "Q1-2024")
        quarter_match = re.match(r'^Q?(\d+)-(\d{4})$', period_str.strip())
        if quarter_match:
            value = int(quarter_match.group(1))
            year = int(quarter_match.group(2))
            
            # If it starts with Q or the value is clearly quarterly (1-4 and formatted as Q)
            if period_str.strip().startswith('Q'):
                return cls(year, value, is_monthly=False)
            
            # Otherwise use heuristic: 1-4 could be either, 5-12 is definitely monthly
            if 1 <= value <= 4:
                # Ambiguous case - default to monthly for backward compatibility
                # unless the format suggests quarterly
                return cls(year, value, is_monthly=True)
            elif 5 <= value <= 12:
                return cls(year, value, is_monthly=True)
            else:
                raise ValueError(f"Invalid period value: {value}")
        
        # If no match, try simple number-year format
        parts = period_str.strip().split('-')
        if len(parts) != 2:
            raise ValueError(f"Period string must be in format 'value-year': {period_str}")
        
        try:
            value = int(parts[0])
            year = int(parts[1])
        except ValueError:
            raise ValueError(f"Invalid period format - non-numeric values: {period_str}")
        
        # Use heuristic to determine if monthly or quarterly
        if 1 <= value <= 4:
            # Could be either - check if it looks like a quarter
            # For backward compatibility, default to monthly
            return cls(year, value, is_monthly=True)
        elif 5 <= value <= 12:
            return cls(year, value, is_monthly=True)
        else:
            raise ValueError(f"Invalid period value: {value}")
    
    @classmethod
    def from_quarterly_string(cls, period_str: str) -> 'Period':
        """
        Explicitly parse as quarterly period.
        Use this when you know the period should be quarterly.
        """
        parts = period_str.strip().replace('Q', '').split('-')
        if len(parts) != 2:
            raise ValueError(f"Quarterly period string must be in format 'Q-year': {period_str}")
        
        try:
            quarter = int(parts[0])
            year = int(parts[1])
        except ValueError:
            raise ValueError(f"Invalid quarterly period format: {period_str}")
        
        return cls(year, quarter, is_monthly=False)
    
    def to_string(self) -> str:
        """
        Convert to string format for API serialization and backward compatibility.
        Returns "month-year" for monthly or "quarter-year" for quarterly periods.
        """
        return f"{self.value}-{self.year}"
    
    def to_display_string(self) -> str:
        """
        Convert to human-readable format.
        Returns "January 2024" for monthly or "Q1 2024" for quarterly periods.
        """
        if self.is_monthly:
            month_names = [
                "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ]
            return f"{month_names[self.value - 1]} {self.year}"
        else:
            return f"Q{self.value} {self.year}"
    
    def __eq__(self, other) -> bool:
        """Check if two periods are equal."""
        if not isinstance(other, Period):
            return False
        return (self.year == other.year and 
                self.value == other.value and 
                self.is_monthly == other.is_monthly)
    
    def __lt__(self, other) -> bool:
        """Check if this period comes before another period."""
        if not isinstance(other, Period):
            raise TypeError(f"Cannot compare Period with {type(other)}")
        
        # Different period types cannot be compared
        if self.is_monthly != other.is_monthly:
            raise ValueError("Cannot compare monthly and quarterly periods")
        
        # Compare by year first
        if self.year != other.year:
            return self.year < other.year
        
        # Same year, compare by value
        return self.value < other.value
    
    def __le__(self, other) -> bool:
        """Check if this period comes before or equals another period."""
        return self == other or self < other
    
    def __gt__(self, other) -> bool:
        """Check if this period comes after another period."""
        return not self <= other
    
    def __ge__(self, other) -> bool:
        """Check if this period comes after or equals another period."""
        return not self < other
    
    def __hash__(self) -> int:
        """Make Period hashable for use in sets and dict keys."""
        return hash((self.year, self.value, self.is_monthly))
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        period_type = "monthly" if self.is_monthly else "quarterly"
        return f"Period({self.year}, {self.value}, {period_type})"
    
    def add_months(self, months: int) -> 'Period':
        """
        Add months to a monthly period.
        Raises ValueError if called on quarterly period.
        """
        if not self.is_monthly:
            raise ValueError("Cannot add months to quarterly period")
        
        # Calculate new month and year
        total_months = (self.year * 12 + self.value - 1) + months
        new_year = total_months // 12
        new_month = (total_months % 12) + 1
        
        return Period(new_year, new_month, is_monthly=True)
    
    def add_quarters(self, quarters: int) -> 'Period':
        """
        Add quarters to a quarterly period.
        Raises ValueError if called on monthly period.
        """
        if self.is_monthly:
            raise ValueError("Cannot add quarters to monthly period")
        
        # Calculate new quarter and year
        total_quarters = (self.year * 4 + self.value - 1) + quarters
        new_year = total_quarters // 4
        new_quarter = (total_quarters % 4) + 1
        
        return Period(new_year, new_quarter, is_monthly=False)
    
    def subtract_months(self, months: int) -> 'Period':
        """Subtract months from a monthly period."""
        return self.add_months(-months)
    
    def subtract_quarters(self, quarters: int) -> 'Period':
        """Subtract quarters from a quarterly period."""
        return self.add_quarters(-quarters)
    
    def get_previous_period(self) -> 'Period':
        """Get the period immediately before this one."""
        if self.is_monthly:
            return self.subtract_months(1)
        else:
            return self.subtract_quarters(1)
    
    def get_next_period(self) -> 'Period':
        """Get the period immediately after this one."""
        if self.is_monthly:
            return self.add_months(1)
        else:
            return self.add_quarters(1)
    
    def periods_between(self, other: 'Period') -> int:
        """
        Calculate the number of periods between this period and another.
        Returns positive if other is after this period, negative if before.
        """
        if not isinstance(other, Period):
            raise TypeError(f"Cannot calculate periods between Period and {type(other)}")
        
        if self.is_monthly != other.is_monthly:
            raise ValueError("Cannot calculate periods between monthly and quarterly periods")
        
        if self.is_monthly:
            this_total = self.year * 12 + self.value - 1
            other_total = other.year * 12 + other.value - 1
            return other_total - this_total
        else:
            this_total = self.year * 4 + self.value - 1
            other_total = other.year * 4 + other.value - 1
            return other_total - this_total
    
    @classmethod
    def generate_range(cls, start: 'Period', end: 'Period') -> List['Period']:
        """
        Generate a list of periods from start to end (inclusive).
        Both periods must be the same type (monthly or quarterly).
        """
        if not isinstance(start, Period) or not isinstance(end, Period):
            raise TypeError("Both start and end must be Period objects")
        
        if start.is_monthly != end.is_monthly:
            raise ValueError("Start and end periods must be the same type")
        
        if start > end:
            raise ValueError("Start period must be before or equal to end period")
        
        periods = []
        current = start
        
        while current <= end:
            periods.append(Period(current.year, current.value, current.is_monthly))
            current = current.get_next_period()
        
        return periods
    
    @classmethod
    def get_current_period(cls, is_monthly: bool = True) -> 'Period':
        """Get the current period based on today's date."""
        today = datetime.now()
        
        if is_monthly:
            return cls(today.year, today.month, is_monthly=True)
        else:
            quarter = (today.month - 1) // 3 + 1
            return cls(today.year, quarter, is_monthly=False)
    
    @classmethod
    def get_previous_period_for_schedule(cls, schedule: str) -> 'Period':
        """
        Get the previous period for arrears payment based on payment schedule.
        
        Args:
            schedule: "monthly" or "quarterly"
        
        Returns:
            The previous period (for arrears payment logic)
        """
        is_monthly = schedule.lower() == "monthly"
        current = cls.get_current_period(is_monthly)
        return current.get_previous_period()
```

models\schemas.py
```py
"""
Consolidated model schemas for the financial advisory application.

This module contains the 4 essential models that replace the previous 15+ redundant model classes.
All models use optional fields to handle different use cases (list views, detail views, create/update operations).
"""

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime


class Client(BaseModel):
    """
    Consolidated client model that replaces Client, ClientMetrics, and ClientSummary.
    Uses optional fields to handle different response contexts.
    """
    # Core client fields (always present)
    client_id: int
    display_name: str
    full_name: str
    ima_signed_date: Optional[str] = None
    onedrive_folder_path: Optional[str] = None
    
    # Contract info (from joins)
    provider_name: Optional[str] = None
    
    # Calculated status fields (for dashboard and list views)
    compliance_status: Optional[str] = None  # red/yellow/green
    compliance_reason: Optional[str] = None
    current_status: Optional[str] = None  # Due/Current/Overdue
    current_period: Optional[str] = None
    overdue_periods: List[str] = []
    
    # Payment metrics (for detailed views)
    last_payment_date: Optional[str] = None
    last_payment_amount: Optional[float] = None
    last_payment_quarter: Optional[int] = None
    last_payment_year: Optional[int] = None
    total_ytd_payments: Optional[float] = None
    avg_quarterly_payment: Optional[float] = None
    last_recorded_assets: Optional[float] = None
    
    # Enhanced data (for detailed responses)
    contract: Optional[Dict[str, Any]] = None
    quarterly_summaries: Optional[List[Dict[str, Any]]] = None
    yearly_summaries: Optional[List[Dict[str, Any]]] = None
    
    class Config:
        # Support ORM mode for database integration
        orm_mode = True


class Contract(BaseModel):
    """
    Consolidated contract model that replaces Contract, ContractBase, and ExpectedFeeCalculation.
    Uses optional fields for fee calculation results and metadata.
    """
    # Core contract fields (always present)
    contract_id: int
    client_id: int
    provider_name: str
    fee_type: str  # PERCENTAGE or FLAT
    payment_schedule: str  # Monthly or Quarterly
    
    # Contract details (optional)
    contract_number: Optional[str] = None
    contract_start_date: Optional[str] = None
    percent_rate: Optional[float] = None
    flat_rate: Optional[float] = None
    num_people: Optional[int] = None
    notes: Optional[str] = None
    
    # Fee calculation results (when calculation is performed)
    expected_fee: Optional[float] = None
    calculation_method: Optional[str] = None
    
    class Config:
        orm_mode = True


class Payment(BaseModel):
    """
    Consolidated payment model that replaces Payment, PaymentBase, PaymentCreate, and PaymentWithDetails.
    Uses optional fields to handle create operations and enhanced responses.
    """
    # Core payment fields
    payment_id: Optional[int] = None  # None for create operations
    contract_id: int
    client_id: int
    received_date: str
    actual_fee: Optional[float] = None
    
    # Asset and fee tracking
    total_assets: Optional[float] = None
    expected_fee: Optional[float] = None
    
    # Payment metadata
    method: Optional[str] = None
    notes: Optional[str] = None
    
    # Period application (for split payments)
    applied_start_month: Optional[int] = None
    applied_start_month_year: Optional[int] = None
    applied_end_month: Optional[int] = None
    applied_end_month_year: Optional[int] = None
    applied_start_quarter: Optional[int] = None
    applied_start_quarter_year: Optional[int] = None
    applied_end_quarter: Optional[int] = None
    applied_end_quarter_year: Optional[int] = None
    
    # Enhanced fields (from joins and calculations)
    client_name: Optional[str] = None
    provider_name: Optional[str] = None
    fee_type: Optional[str] = None
    percent_rate: Optional[float] = None
    flat_rate: Optional[float] = None
    payment_schedule: Optional[str] = None
    
    # Calculated fields (for detailed responses)
    is_split_payment: bool = False
    periods: Optional[List[Dict[str, Any]]] = None
    variance: Optional[Dict[str, Any]] = None
    has_files: bool = False
    
    class Config:
        orm_mode = True
        validate_assignment = True


class File(BaseModel):
    """
    Consolidated file model that replaces File, FileBase, PaymentFile, and FileWithPayment.
    Uses optional fields for payment relationships and file metadata.
    """
    # Core file fields
    file_id: Optional[int] = None  # None for create operations
    client_id: int
    file_name: str
    onedrive_path: str
    uploaded_at: Optional[str] = None
    
    # Payment relationship (optional)
    payment_id: Optional[int] = None
    linked_at: Optional[str] = None
    
    # Enhanced fields for file operations
    full_path: Optional[str] = None  # Complete OneDrive path
    exists: Optional[bool] = None  # File existence check result
    size: Optional[int] = None  # File size in bytes
    
    class Config:
        orm_mode = True


# Dashboard response models for unified client data
class PaymentStatusInfo(BaseModel):
    """Payment status information for dashboard responses"""
    overdue_periods: List[str]
    current_status: str
    current_period: str


class ComplianceInfo(BaseModel):
    """Compliance status information for dashboard responses"""
    status: str  # "compliant" or "non_compliant"
    reason: str
    color: str  # "red", "yellow", "green" for UI


class NextPaymentDue(BaseModel):
    """Next payment due information for dashboard responses"""
    period: str
    due_date: Optional[str]
    expected_fee: Optional[float]


class ClientDashboard(BaseModel):
    """Complete dashboard data for a client in a single response"""
    client: Client
    contract: Optional[Contract]
    payment_status: PaymentStatusInfo
    compliance: ComplianceInfo
    recent_payments: List[Payment]
    next_payment_due: NextPaymentDue


# Legacy support model for available periods (to maintain API compatibility)
class AvailablePeriods(BaseModel):
    """Available periods for payment form (maintains backward compatibility)"""
    periods: List[Dict[str, Any]]


# Type aliases for clarity
ClientCreate = Client  # Same model, payment_id will be None
ContractCreate = Contract  # Same model, contract_id will be None  
PaymentCreate = Payment  # Same model, payment_id will be None
FileCreate = File  # Same model, file_id will be None
```

repositories\__init__.py
```py
"""
Repository layer for the application.
Consolidates business logic and SQL queries from scattered service files.
"""

from .calculation_repository import CalculationRepository
from .payment_repository import PaymentRepository

__all__ = ['CalculationRepository', 'PaymentRepository']
```

repositories\calculation_repository.py
```py
"""
Calculation Repository - Centralized business logic calculations.
Consolidates fee calculations and payment status logic from multiple services.
"""

from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime
from core.database import execute_query
from models.schemas import Contract
from services.contract_service import get_contract_by_id

# Constants
MONTH_NAMES = [
    "January", "February", "March", "April", "May", "June", 
    "July", "August", "September", "October", "November", "December"
]

class CalculationRepository:
    """Centralized repository for all business calculations"""
    
    @staticmethod
    def calculate_expected_fee(contract_id: int, total_assets: Optional[float] = None) -> Contract:
        """
        Calculate the expected fee based on contract terms and total assets.
        This is the COMPLETE version from contract_service.py (lines 37-95)
        """
        contract = get_contract_by_id(contract_id)
        
        if not contract:
            # Return a Contract object with minimal fields when contract not found
            return Contract(
                contract_id=contract_id,
                client_id=0,
                provider_name="Unknown",
                fee_type="unknown",
                payment_schedule="Unknown",
                expected_fee=None,
                calculation_method="Contract not found"
            )
        
        # Handle flat fee contracts
        if contract.fee_type == "flat":
            # Return contract with calculated fee for flat rate
            contract_dict = contract.__dict__.copy()
            contract_dict.update({
                "expected_fee": contract.flat_rate,
                "calculation_method": "Flat fee"
            })
            return Contract(**contract_dict)
        
        # Handle percentage-based fees
        if contract.fee_type in ["percentage", "percent"]:
            # Try to use provided assets first
            if not total_assets:
                # If no assets provided, try to find last recorded assets
                assets_query = """
                    SELECT last_recorded_assets
                    FROM client_metrics
                    WHERE client_id = :client_id
                """
                
                metrics_data = execute_query(
                    assets_query, 
                    {"client_id": contract.client_id}, 
                    fetch_one=True
                )
                
                if metrics_data and metrics_data.get("last_recorded_assets"):
                    total_assets = metrics_data["last_recorded_assets"]
            
            # Calculate fee if we have both assets and rate
            if total_assets and contract.percent_rate:
                expected_fee = total_assets * contract.percent_rate
                rate_percentage = contract.percent_rate * 100
                
                # Return contract with calculated percentage fee
                contract_dict = contract.__dict__.copy()
                contract_dict.update({
                    "expected_fee": expected_fee,
                    "calculation_method": f"{rate_percentage:.4f}% of ${total_assets:,.2f}"
                })
                return Contract(**contract_dict)
        
        # If we get here, we couldn't calculate a fee
        # Return contract with no calculated fee when unable to calculate
        contract_dict = contract.__dict__.copy()
        contract_dict.update({
            "expected_fee": None,
            "calculation_method": "Unable to calculate (missing data)"
        })
        return Contract(**contract_dict)
    
    @staticmethod
    def calculate_expected_fee_from_payment(payment: Dict[str, Any]) -> Optional[float]:
        """
        Calculate expected fee from payment dict (simplified version for internal use)
        This replaces the simple version from payment_service.py
        """
        if payment.get("fee_type") == "flat" and payment.get("flat_rate") is not None:
            return payment.get("flat_rate")
        elif payment.get("fee_type") in ["percentage", "percent"] and payment.get("percent_rate") is not None:
            if payment.get("total_assets") is not None:
                return payment.get("total_assets") * payment.get("percent_rate")
        return None
    
    @staticmethod
    def calculate_payment_status(client_id: int) -> Dict[str, Any]:
        """
        Calculate payment status - moved from client_service.py lines 73-194
        Returns: {"overdue_periods": [], "current_status": "Due", "current_period": ""}
        """
        # Get the payment schedule and last payment info
        query = """
            SELECT 
                ct.payment_schedule,
                p.received_date as last_payment_date,
                p.applied_end_month,
                p.applied_end_month_year,
                p.applied_end_quarter,
                p.applied_end_quarter_year
            FROM contracts ct
            LEFT JOIN (
                SELECT * FROM payments 
                WHERE client_id = :client_id AND valid_to IS NULL
                ORDER BY received_date DESC
                LIMIT 1
            ) p ON ct.client_id = p.client_id
            WHERE ct.client_id = :client_id AND ct.valid_to IS NULL
        """
        result = execute_query(query, {"client_id": client_id}, fetch_one=True)
        
        # If no contract, return default values
        if not result:
            return {
                "overdue_periods": [],
                "current_status": "Due",
                "current_period": CalculationRepository._get_current_period("monthly")
            }
        
        payment_schedule = result["payment_schedule"]
        today = datetime.now()
        current_month = today.month
        current_year = today.year
        current_quarter = (today.month - 1) // 3 + 1
        
        overdue_periods = []
        
        # If no payments yet, they're missing the previous period
        if not result["last_payment_date"]:
            # Just show previous period as overdue
            if payment_schedule.lower() == "monthly":
                prev_month = current_month - 1 if current_month > 1 else 12
                prev_year = current_year if current_month > 1 else current_year - 1
                overdue_periods.append(f"{MONTH_NAMES[prev_month - 1]} {prev_year}")
            else:
                prev_quarter = current_quarter - 1 if current_quarter > 1 else 4
                prev_year = current_year if current_quarter > 1 else current_year - 1
                overdue_periods.append(f"Q{prev_quarter} {prev_year}")
            
            return {
                "overdue_periods": overdue_periods,
                "current_status": "Overdue",
                "current_period": CalculationRepository._get_current_period(payment_schedule)
            }
        
        # Check payment status based on schedule
        is_current_paid = False
        is_previous_paid = False
        
        if payment_schedule.lower() == "monthly":
            if result["applied_end_month"] and result["applied_end_month_year"]:
                last_paid_month = result["applied_end_month"]
                last_paid_year = result["applied_end_month_year"]
                
                # Calculate previous month
                prev_month = current_month - 1 if current_month > 1 else 12
                prev_year = current_year if current_month > 1 else current_year - 1
                
                # Check if current month is paid
                is_current_paid = (last_paid_month == current_month and last_paid_year == current_year)
                
                # Check if previous month is paid
                is_previous_paid = (
                    (last_paid_month == current_month and last_paid_year == current_year) or
                    (last_paid_month == prev_month and last_paid_year == prev_year)
                )
                
                # If previous month not paid, it's overdue
                if not is_previous_paid:
                    overdue_periods.append(f"{MONTH_NAMES[prev_month - 1]} {prev_year}")
        else:  # quarterly
            if result["applied_end_quarter"] and result["applied_end_quarter_year"]:
                last_paid_quarter = result["applied_end_quarter"]
                last_paid_year = result["applied_end_quarter_year"]
                
                # Calculate previous quarter
                prev_quarter = current_quarter - 1 if current_quarter > 1 else 4
                prev_year = current_year if current_quarter > 1 else current_year - 1
                
                # Check if current quarter is paid
                is_current_paid = (last_paid_quarter == current_quarter and last_paid_year == current_year)
                
                # Check if previous quarter is paid
                is_previous_paid = (
                    (last_paid_quarter == current_quarter and last_paid_year == current_year) or
                    (last_paid_quarter == prev_quarter and last_paid_year == prev_year)
                )
                
                # If previous quarter not paid, it's overdue
                if not is_previous_paid:
                    overdue_periods.append(f"Q{prev_quarter} {prev_year}")
        
        # Determine overall status
        if overdue_periods:
            current_status = "Overdue"
        elif is_current_paid:
            current_status = "Current"
        else:
            current_status = "Due"
        
        return {
            "overdue_periods": overdue_periods,
            "current_status": current_status,
            "current_period": CalculationRepository._get_current_period(payment_schedule)
        }
    
    @staticmethod
    def map_status_to_compliance(payment_status: Dict[str, Any]) -> Tuple[str, str]:
        """
        Consolidate compliance mapping from client_service.py
        Returns: (compliance_status, compliance_reason)
        """
        current_status = payment_status.get("current_status", "Due")
        overdue_periods = payment_status.get("overdue_periods", [])
        
        if current_status == "Overdue":
            return "non_compliant", f"Overdue: {', '.join(overdue_periods)}"
        elif current_status == "Current":
            return "compliant", "All payments up to date"
        else:  # Due
            return "compliant", "Payment due for current period"
    
    @staticmethod
    def _get_current_period(schedule_type: str) -> str:
        """Helper function to get the current period formatted as string"""
        today = datetime.now()
        if schedule_type.lower() == "monthly":
            return f"{MONTH_NAMES[today.month - 1]} {today.year}"
        else:
            current_quarter = (today.month - 1) // 3 + 1
            return f"Q{current_quarter} {today.year}"
```

repositories\payment_repository.py
```py
"""
Payment Repository - Centralized SQL queries for payment operations.
Consolidates payment queries from payment_service.py and other services.
"""

from typing import Dict, Any, Optional, List
from core.database import execute_query

class PaymentRepository:
    """Centralized repository for payment data access"""
    
    # Base query extracted from payment_service.py lines 18-36
    PAYMENT_BASE_SELECT = """
        SELECT 
            p.payment_id, p.contract_id, p.client_id, p.received_date, 
            p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
            p.applied_start_month, p.applied_start_month_year, 
            p.applied_end_month, p.applied_end_month_year,
            p.applied_start_quarter, p.applied_start_quarter_year, 
            p.applied_end_quarter, p.applied_end_quarter_year,
            c.display_name as client_name, co.provider_name, co.fee_type, 
            co.percent_rate, co.flat_rate, co.payment_schedule,
            COALESCE(pv.has_file, 0) as has_file
        FROM payments p
        JOIN clients c ON p.client_id = c.client_id
        LEFT JOIN contracts co ON p.contract_id = co.contract_id
        LEFT JOIN (
            SELECT DISTINCT payment_id, has_file 
            FROM payment_file_view
        ) pv ON p.payment_id = pv.payment_id
    """
    
    @staticmethod
    def get_by_client(
        client_id: int, 
        page: int = 1, 
        limit: int = 50, 
        year: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Get payments for a client with pagination and optional year filter.
        Consolidates logic from payment_service.py get_client_payments()
        """
        offset = (page - 1) * limit
        params = {"client_id": client_id, "limit": limit, "offset": offset}
        
        query = PaymentRepository.PAYMENT_BASE_SELECT + """
            WHERE p.client_id = :client_id AND p.valid_to IS NULL
        """
        
        if year:
            query += """ 
                AND (
                    (p.applied_start_month_year = :year) OR 
                    (p.applied_end_month_year = :year) OR
                    (p.applied_start_quarter_year = :year) OR 
                    (p.applied_end_quarter_year = :year)
                )
            """
            params["year"] = year
            
        query += " ORDER BY p.received_date DESC LIMIT :limit OFFSET :offset"
        
        return execute_query(query, params)
    
    @staticmethod
    def get_by_id(payment_id: int) -> Optional[Dict[str, Any]]:
        """
        Get a single payment by ID.
        Consolidates logic from payment_service.py get_payment_by_id()
        """
        query = PaymentRepository.PAYMENT_BASE_SELECT + """
            WHERE p.payment_id = :payment_id AND p.valid_to IS NULL
        """
        
        return execute_query(
            query, 
            {"payment_id": payment_id}, 
            fetch_one=True
        )
    
    @staticmethod
    def get_recent_by_client(client_id: int, limit: int = 5) -> List[Dict[str, Any]]:
        """
        Get recent payments for a client (for dashboard use).
        """
        query = PaymentRepository.PAYMENT_BASE_SELECT + """
            WHERE p.client_id = :client_id AND p.valid_to IS NULL
            ORDER BY p.received_date DESC 
            LIMIT :limit
        """
        
        return execute_query(query, {"client_id": client_id, "limit": limit})
    
    @staticmethod
    def get_last_payment_for_client(client_id: int) -> Optional[Dict[str, Any]]:
        """
        Get the most recent payment for a client.
        Used in payment status calculations.
        """
        query = """
            SELECT 
                p.received_date,
                p.applied_end_month,
                p.applied_end_month_year,
                p.applied_end_quarter,
                p.applied_end_quarter_year,
                p.actual_fee,
                p.total_assets
            FROM payments p
            WHERE p.client_id = :client_id AND p.valid_to IS NULL
            ORDER BY p.received_date DESC
            LIMIT 1
        """
        
        return execute_query(
            query, 
            {"client_id": client_id}, 
            fetch_one=True
        )
    
    @staticmethod
    def create_payment(payment_data: Dict[str, Any]) -> bool:
        """
        Create a new payment record.
        """
        query = """
            INSERT INTO payments (
                contract_id, client_id, received_date, total_assets,
                expected_fee, actual_fee, method, notes,
                applied_start_month, applied_start_month_year,
                applied_end_month, applied_end_month_year,
                applied_start_quarter, applied_start_quarter_year,
                applied_end_quarter, applied_end_quarter_year
            ) VALUES (
                :contract_id, :client_id, :received_date, :total_assets,
                :expected_fee, :actual_fee, :method, :notes,
                :applied_start_month, :applied_start_month_year,
                :applied_end_month, :applied_end_month_year,
                :applied_start_quarter, :applied_start_quarter_year,
                :applied_end_quarter, :applied_end_quarter_year
            )
        """
        
        result = execute_query(query, payment_data)
        return result["rowcount"] > 0
    
    @staticmethod
    def update_payment(payment_id: int, payment_data: Dict[str, Any]) -> bool:
        """
        Update an existing payment record.
        """
        # Build dynamic update query based on provided fields
        set_clauses = []
        params = {"payment_id": payment_id}
        
        for field, value in payment_data.items():
            if field != "payment_id":  # Don't update the ID
                set_clauses.append(f"{field} = :{field}")
                params[field] = value
        
        if not set_clauses:
            return False
            
        query = f"""
            UPDATE payments 
            SET {', '.join(set_clauses)}
            WHERE payment_id = :payment_id AND valid_to IS NULL
        """
        
        result = execute_query(query, params)
        return result["rowcount"] > 0
    
    @staticmethod
    def soft_delete_payment(payment_id: int) -> bool:
        """
        Soft delete a payment by setting valid_to timestamp.
        """
        query = """
            UPDATE payments 
            SET valid_to = datetime('now') 
            WHERE payment_id = :payment_id AND valid_to IS NULL
        """
        
        result = execute_query(query, {"payment_id": payment_id})
        return result["rowcount"] > 0
```

services\__init__.py
```py

```

services\client_metrics_service.py
```py
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
from core.database import execute_query, execute_transaction
from utils.constants import PAYMENT_SCHEDULES

def update_client_metrics(client_id: int) -> bool:
    """
    Update metrics for a specific client after payment changes.
    Handles all metric calculations with proper null handling.
    
    Args:
        client_id: The client ID to update metrics for
        
    Returns:
        bool: Success status
    """
    try:
        # Get latest payment info
        payment_query = """
            SELECT 
                received_date, actual_fee, 
                applied_start_quarter, applied_start_quarter_year,
                total_assets
            FROM payments
            WHERE client_id = :client_id AND valid_to IS NULL
            ORDER BY received_date DESC
            LIMIT 1
        """
        latest_payment = execute_query(payment_query, {"client_id": client_id}, fetch_one=True)
        
        # Get YTD payments sum
        current_year = datetime.now().year
        ytd_query = """
            SELECT SUM(actual_fee) as ytd_total
            FROM payments
            WHERE client_id = :client_id 
              AND valid_to IS NULL
              AND (
                  (applied_start_quarter_year = :year) OR
                  (applied_start_month_year = :year)
              )
        """
        ytd_result = execute_query(ytd_query, {"client_id": client_id, "year": current_year}, fetch_one=True)
        
        # Get average quarterly payment
        avg_query = """
            SELECT AVG(actual_fee) as avg_payment
            FROM payments
            WHERE client_id = :client_id AND valid_to IS NULL
        """
        avg_result = execute_query(avg_query, {"client_id": client_id}, fetch_one=True)
        
        # Get payment schedule for next payment calculation
        schedule_query = """
            SELECT payment_schedule
            FROM contracts
            WHERE client_id = :client_id AND valid_to IS NULL
        """
        schedule_result = execute_query(schedule_query, {"client_id": client_id}, fetch_one=True)
        
        # Calculate next payment due date
        next_payment_due = None
        if latest_payment and schedule_result and "received_date" in latest_payment:
            # Convert received_date string to datetime
            try:
                last_date = datetime.strptime(latest_payment["received_date"], "%Y-%m-%d")
                
                if schedule_result.get("payment_schedule", "").lower() == PAYMENT_SCHEDULES["MONTHLY"]:
                    # Monthly: add one month
                    next_date = last_date.replace(month=last_date.month % 12 + 1)
                    if last_date.month == 12:
                        next_date = next_date.replace(year=last_date.year + 1)
                    next_payment_due = next_date.strftime("%Y-%m-%d")
                else:
                    # Quarterly: add three months
                    if last_date.month > 9:  # Oct-Dec
                        next_date = last_date.replace(year=last_date.year + 1, month=(last_date.month + 3) % 12)
                    else:
                        next_date = last_date.replace(month=last_date.month + 3)
                    next_payment_due = next_date.strftime("%Y-%m-%d")
            except (ValueError, TypeError):
                pass  # Skip if date parsing fails
        
        # Build update data dictionary with null handling
        update_data = {
            "client_id": client_id,
            "last_payment_date": latest_payment["received_date"] if latest_payment and "received_date" in latest_payment else None,
            "last_payment_amount": latest_payment["actual_fee"] if latest_payment and "actual_fee" in latest_payment else None,
            "last_payment_quarter": latest_payment["applied_start_quarter"] if latest_payment and "applied_start_quarter" in latest_payment else None,
            "last_payment_year": latest_payment["applied_start_quarter_year"] if latest_payment and "applied_start_quarter_year" in latest_payment else None,
            "total_ytd_payments": ytd_result["ytd_total"] if ytd_result and "ytd_total" in ytd_result else 0,
            "avg_quarterly_payment": avg_result["avg_payment"] if avg_result and "avg_payment" in avg_result else None,
            "last_recorded_assets": latest_payment["total_assets"] if latest_payment and "total_assets" in latest_payment else None,
            "last_updated": datetime.now().strftime("%Y-%m-%d"),
            "next_payment_due": next_payment_due
        }
        
        # Perform upsert operation
        upsert_query = """
            INSERT INTO client_metrics (
                client_id, last_payment_date, last_payment_amount, 
                last_payment_quarter, last_payment_year, total_ytd_payments, 
                avg_quarterly_payment, last_recorded_assets, last_updated, 
                next_payment_due
            ) VALUES (
                :client_id, :last_payment_date, :last_payment_amount,
                :last_payment_quarter, :last_payment_year, :total_ytd_payments,
                :avg_quarterly_payment, :last_recorded_assets, :last_updated,
                :next_payment_due
            )
            ON CONFLICT(client_id) DO UPDATE SET
                last_payment_date = :last_payment_date,
                last_payment_amount = :last_payment_amount,
                last_payment_quarter = :last_payment_quarter,
                last_payment_year = :last_payment_year,
                total_ytd_payments = :total_ytd_payments,
                avg_quarterly_payment = :avg_quarterly_payment,
                last_recorded_assets = :last_recorded_assets,
                last_updated = :last_updated,
                next_payment_due = :next_payment_due
        """
        
        execute_query(upsert_query, update_data)
        return True
    except Exception as e:
        print(f"Error updating client metrics for client {client_id}: {str(e)}")
        return False
```

services\client_service.py
```py
from typing import List, Dict, Any, Optional
from datetime import datetime
from core.database import execute_query
from models.schemas import Client
from repositories.calculation_repository import CalculationRepository
from utils.constants import MONTH_NAMES

# SQL query constants
GET_ALL_CLIENTS_QUERY = """
    SELECT c.client_id, c.display_name, c.full_name, c.ima_signed_date, c.onedrive_folder_path,
           co.provider_name
    FROM clients c
    LEFT JOIN (
        SELECT client_id, provider_name
        FROM contracts 
        WHERE valid_to IS NULL
        GROUP BY client_id
    ) co ON c.client_id = co.client_id
    WHERE c.valid_to IS NULL
"""

def get_all_clients(provider: Optional[str] = None) -> List[Client]:
    query = GET_ALL_CLIENTS_QUERY
    params = {}
    if provider:
        query += " AND co.provider_name = :provider"
        params["provider"] = provider
    query += " ORDER BY c.display_name"
    clients_data = execute_query(query, params)
    clients = []
    for client_data in clients_data:
        client = Client(**client_data)
        # Get payment status using repository
        payment_status = CalculationRepository.calculate_payment_status(client_data["client_id"])
        # Map payment status to compliance status for backward compatibility
        compliance_status, compliance_reason = CalculationRepository.map_status_to_compliance(payment_status)
        if compliance_status == "non_compliant":
            client.compliance_status = "red"
        elif payment_status["current_status"] == "Due":
            client.compliance_status = "yellow"
        else:
            client.compliance_status = "green"
        client.compliance_reason = compliance_reason
        clients.append(client)
    return clients

def get_client_by_id(client_id: int) -> Optional[Client]:
    query = """
        SELECT c.client_id, c.display_name, c.full_name, c.ima_signed_date, c.onedrive_folder_path,
               co.provider_name, co.payment_schedule, co.fee_type
        FROM clients c
        LEFT JOIN contracts co ON c.client_id = co.client_id AND co.valid_to IS NULL
        WHERE c.client_id = :client_id AND c.valid_to IS NULL
    """
    client_data = execute_query(query, {"client_id": client_id}, fetch_one=True)
    if not client_data:
        return None
    client = Client(**client_data)
    # Get payment status using repository
    payment_status = CalculationRepository.calculate_payment_status(client_id)
    # Map payment status to compliance status for backward compatibility
    compliance_status, compliance_reason = CalculationRepository.map_status_to_compliance(payment_status)
    if compliance_status == "non_compliant":
        client.compliance_status = "red"
    elif payment_status["current_status"] == "Due":
        client.compliance_status = "yellow"
    else:
        client.compliance_status = "green"
    client.compliance_reason = compliance_reason
    return client

```

services\contract_service.py
```py
from typing import Dict, Any, Optional
from models.schemas import Contract
from core.database import execute_query

def get_contract_by_id(contract_id: int) -> Optional[Contract]:
    query = """
        SELECT contract_id, client_id, contract_number, provider_name, 
               contract_start_date, fee_type, percent_rate, flat_rate,
               payment_schedule, num_people, notes
        FROM contracts
        WHERE contract_id = :contract_id AND valid_to IS NULL
    """
    
    contract_data = execute_query(query, {"contract_id": contract_id}, fetch_one=True)
    
    if not contract_data:
        return None
        
    return Contract(**contract_data)

def get_client_contract(client_id: int) -> Optional[Contract]:
    query = """
        SELECT contract_id, client_id, contract_number, provider_name, 
               contract_start_date, fee_type, percent_rate, flat_rate,
               payment_schedule, num_people, notes
        FROM contracts
        WHERE client_id = :client_id AND valid_to IS NULL
    """
    
    contract_data = execute_query(query, {"client_id": client_id}, fetch_one=True)
    
    if not contract_data:
        return None
        
    return Contract(**contract_data)

```

services\file_service.py
```py
from typing import List, Dict, Any, Optional
import os
from pathlib import Path
from core.database import execute_query
from models.schemas import File
from utils.user_utils import get_user_base_path

def has_files_for_payment(payment_id: int) -> bool:
    """Check if a payment has any files attached to it."""
    query = """
        SELECT has_file
        FROM payment_file_view
        WHERE payment_id = :payment_id
        LIMIT 1
    """
    result = execute_query(query, {"payment_id": payment_id}, fetch_one=True)
    return result and result.get("has_file", 0) == 1

def get_payment_files(payment_id: int) -> List[Dict[str, Any]]:
    """Get full file details for a specific payment."""
    query = """
        SELECT 
            file_id, 
            client_id, 
            file_name, 
            onedrive_path,
            payment_id
        FROM payment_file_view
        WHERE payment_id = :payment_id
        AND has_file = 1
    """
    files = execute_query(query, {"payment_id": payment_id})
    
    # Enhance file data with full paths
    for file in files:
        if "onedrive_path" in file:
            file["full_path"] = get_full_file_path(file["onedrive_path"])
            
    return files

def get_full_file_path(onedrive_path: str) -> str:
    """
    Construct the full file path from the relative path stored in the database.
    This prepends the user's base path + the 401Ks/Current Plans folder to 
    create the complete path to the file on the local filesystem.
    """
    base_path = get_user_base_path()
    full_path = base_path / "401Ks" / "Current Plans" / onedrive_path
    
    # Normalize the path to ensure it works correctly with the PDF viewer
    normalized_path = os.path.normpath(str(full_path))
    return normalized_path

def has_files_for_client(client_id: int) -> bool:
    """Check if a client has any files available."""
    query = """
        SELECT COUNT(*) as file_count
        FROM client_files
        WHERE client_id = :client_id
    """
    result = execute_query(query, {"client_id": client_id}, fetch_one=True)
    return result and result.get("file_count", 0) > 0

def get_payment_file_ids(payment_id: int) -> List[int]:
    """Get file IDs for a specific payment."""
    query = """
        SELECT file_id
        FROM payment_files
        WHERE payment_id = :payment_id
    """
    results = execute_query(query, {"payment_id": payment_id})
    return [result["file_id"] for result in results]

def validate_file_exists(file_path: str) -> bool:
    """
    Check if a file exists at the given path.
    """
    return os.path.isfile(file_path)
```

services\payment_service.py
```py
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
from core.database import execute_query, execute_transaction
from models.schemas import Payment, PaymentCreate, AvailablePeriods
from services.client_metrics_service import update_client_metrics               
from services.contract_service import get_contract_by_id
from services.period_service import get_available_periods as get_periods_from_service
from repositories.calculation_repository import CalculationRepository
from repositories.payment_repository import PaymentRepository
from utils.constants import MONTH_NAMES

def get_client_payments(
    client_id: int,
    page: int = 1,
    limit: int = 10,
    year: Optional[int] = None
) -> List[Payment]:
    offset = (page - 1) * limit
    params = {"client_id": client_id, "limit": limit, "offset": offset}
    query = """
        SELECT 
            p.payment_id, p.contract_id, p.client_id, p.received_date, 
            p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
            p.applied_start_month, p.applied_start_month_year, 
            p.applied_end_month, p.applied_end_month_year,
            p.applied_start_quarter, p.applied_start_quarter_year, 
            p.applied_end_quarter, p.applied_end_quarter_year,
            c.display_name as client_name, co.provider_name, co.fee_type, 
            co.percent_rate, co.flat_rate, co.payment_schedule,
            COALESCE(pv.has_file, 0) as has_file
        FROM payments p
        JOIN clients c ON p.client_id = c.client_id
        LEFT JOIN contracts co ON p.contract_id = co.contract_id
        LEFT JOIN (
            SELECT DISTINCT payment_id, has_file 
            FROM payment_file_view
        ) pv ON p.payment_id = pv.payment_id
        WHERE p.client_id = :client_id AND p.valid_to IS NULL
    """
    if year:
        query += """ 
            AND (
                (p.applied_start_month_year = :year) OR 
                (p.applied_end_month_year = :year) OR
                (p.applied_start_quarter_year = :year) OR 
                (p.applied_end_quarter_year = :year)
            )
        """
        params["year"] = year
    query += " ORDER BY p.received_date DESC LIMIT :limit OFFSET :offset"
    payment_data = execute_query(query, params)
    enhanced_payments = []
    for payment in payment_data:
        payment_with_details = enhance_payment_with_details(payment)
        enhanced_payments.append(payment_with_details)
    return enhanced_payments

def get_payment_by_id(payment_id: int) -> Optional[Payment]:
    query = """
        SELECT 
            p.payment_id, p.contract_id, p.client_id, p.received_date, 
            p.total_assets, p.expected_fee, p.actual_fee, p.method, p.notes,
            p.applied_start_month, p.applied_start_month_year, 
            p.applied_end_month, p.applied_end_month_year,
            p.applied_start_quarter, p.applied_start_quarter_year, 
            p.applied_end_quarter, p.applied_end_quarter_year,
            c.display_name as client_name, co.provider_name, co.fee_type, 
            co.percent_rate, co.flat_rate, co.payment_schedule,
            COALESCE(pv.has_file, 0) as has_file
        FROM payments p
        JOIN clients c ON p.client_id = c.client_id
        LEFT JOIN contracts co ON p.contract_id = co.contract_id
        LEFT JOIN (
            SELECT DISTINCT payment_id, has_file 
            FROM payment_file_view
        ) pv ON p.payment_id = pv.payment_id
        WHERE p.payment_id = :payment_id AND p.valid_to IS NULL
    """
    payment_data = execute_query(query, {"payment_id": payment_id}, fetch_one=True)
    if not payment_data:
        return None
    return enhance_payment_with_details(payment_data)

def create_payment(payment: PaymentCreate) -> Payment:
    contract = get_contract_by_id(payment.contract_id)
    is_monthly = contract.payment_schedule.lower() == "monthly"
    query = """
        INSERT INTO payments (
            contract_id, client_id, received_date, total_assets,
            actual_fee, method, notes
    """
    if is_monthly:
        query += """,
            applied_start_month, applied_start_month_year,
            applied_end_month, applied_end_month_year
        """
    else:
        query += """,
            applied_start_quarter, applied_start_quarter_year,
            applied_end_quarter, applied_end_quarter_year
        """
    query += ") VALUES ("
    query += ":contract_id, :client_id, :received_date, :total_assets, "
    query += ":actual_fee, :method, :notes"
    if is_monthly:
        query += """,
            :applied_start_month, :applied_start_month_year,
            :applied_end_month, :applied_end_month_year
        """
    else:
        query += """,
            :applied_start_quarter, :applied_start_quarter_year,
            :applied_end_quarter, :applied_end_quarter_year
        """
    query += ")"
    params = payment.dict(exclude_unset=True)
    
    result = execute_query(query, params)
    payment_id = result["lastrowid"]
    
    created_payment = get_payment_by_id(payment_id)
    
    # Update client metrics after creating a payment
    update_client_metrics(payment.client_id)
    
    return Payment(**created_payment.model_dump())

def update_payment(payment_id: int, payment: PaymentCreate) -> Optional[Payment]:
    existing = get_payment_by_id(payment_id)
    if not existing:
        return None
    contract = get_contract_by_id(payment.contract_id)
    is_monthly = contract.payment_schedule.lower() == "monthly"
    query = """
        UPDATE payments
        SET contract_id = :contract_id,
            client_id = :client_id,
            received_date = :received_date,
            total_assets = :total_assets,
            actual_fee = :actual_fee,
            method = :method,
            notes = :notes
    """
    if is_monthly:
        query += """,
            applied_start_month = :applied_start_month,
            applied_start_month_year = :applied_start_month_year,
            applied_end_month = :applied_end_month,
            applied_end_month_year = :applied_end_month_year,
            applied_start_quarter = NULL,
            applied_start_quarter_year = NULL,
            applied_end_quarter = NULL,
            applied_end_quarter_year = NULL
        """
    else:
        query += """,
            applied_start_month = NULL,
            applied_start_month_year = NULL,
            applied_end_month = NULL,
            applied_end_month_year = NULL,
            applied_start_quarter = :applied_start_quarter,
            applied_start_quarter_year = :applied_start_quarter_year,
            applied_end_quarter = :applied_end_quarter,
            applied_end_quarter_year = :applied_end_quarter_year
        """
    query += " WHERE payment_id = :payment_id"
    params = payment.dict(exclude_unset=True)
    params["payment_id"] = payment_id
    
    execute_query(query, params)
    
    updated_payment = get_payment_by_id(payment_id)
    
    # Update client metrics after updating a payment
    update_client_metrics(payment.client_id)
    
    return Payment(**updated_payment.model_dump())

def delete_payment(payment_id: int) -> bool:
    payment = get_payment_by_id(payment_id)
    if not payment:
        return False
    
    # Store client_id before deletion
    client_id = payment.client_id
    
    query = """
        UPDATE payments
        SET valid_to = CURRENT_TIMESTAMP
        WHERE payment_id = :payment_id
    """
    
    result = execute_query(query, {"payment_id": payment_id})
    
    # Update client metrics after soft-deleting a payment
    if result["rowcount"] > 0:
        update_client_metrics(client_id)
    
    return result["rowcount"] > 0


def check_split_payment_status(payment: Dict[str, Any]) -> Tuple[bool, Optional[List[Dict[str, Any]]]]:
    """Determine if payment covers multiple periods and calculate period breakdown."""
    is_split_monthly = (
        payment.get("applied_start_month") is not None and
        payment.get("applied_end_month") is not None and
        (
            payment.get("applied_start_month") != payment.get("applied_end_month") or
            payment.get("applied_start_month_year") != payment.get("applied_end_month_year")
        )
    )
    
    is_split_quarterly = (
        payment.get("applied_start_quarter") is not None and
        payment.get("applied_end_quarter") is not None and
        (
            payment.get("applied_start_quarter") != payment.get("applied_end_quarter") or
            payment.get("applied_start_quarter_year") != payment.get("applied_end_quarter_year")
        )
    )
    
    is_split = is_split_monthly or is_split_quarterly
    
    periods = None
    if is_split:
        periods = calculate_periods(payment)
        
    return is_split, periods

def calculate_payment_variance(payment: Dict[str, Any]) -> Dict[str, Any]:
    """Calculate variance between expected and actual fee."""
    # If actual fee is missing, we can't calculate variance
    if payment.get("actual_fee") is None:
        return {
            "difference": None,
            "percent_difference": None,
            "status": "unknown",
            "message": "Cannot calculate"
        }
        
    # Get expected fee
    expected_fee = payment.get("expected_fee")
    if expected_fee is None:
        expected_fee = CalculationRepository.calculate_expected_fee_from_payment(payment)
        
    if expected_fee is None:
        return {
            "difference": None,
            "percent_difference": None,
            "status": "unknown",
            "message": "Cannot calculate"
        }
        
    actual_fee = payment.get("actual_fee")
    difference = actual_fee - expected_fee
    percent_difference = (difference / expected_fee) * 100 if expected_fee != 0 else 0
    abs_percent_difference = abs(percent_difference)
    
    if actual_fee == expected_fee:
        status = "exact"
        message = "Exact Match"
    elif abs_percent_difference <= 5:
        status = "acceptable"
        message = f"${difference:.2f} ({percent_difference:.2f}%) "
    elif abs_percent_difference <= 15:
        status = "warning"
        message = f"${difference:.2f} ({percent_difference:.2f}%)"
    else:
        status = "alert"
        message = f"${difference:.2f} ({percent_difference:.2f}%)"
        
    return {
        "difference": difference,
        "percent_difference": percent_difference,
        "status": status,
        "message": message
    }

def enhance_payment_with_details(payment_data: Dict[str, Any]) -> Payment:
    payment = Payment(**payment_data)
    
    # Calculate expected fee if needed
    if payment.expected_fee is None:
        payment.expected_fee = CalculationRepository.calculate_expected_fee_from_payment(payment_data)
    
    # Set has_files from the query result
    payment.has_files = payment_data.get('has_file') == 1
    
    # Check if payment is split across periods
    is_split, periods = check_split_payment_status(payment_data)
    payment.is_split_payment = is_split
    payment.periods = periods
    
    # Calculate variance
    payment.variance = calculate_payment_variance(payment_data)
    
    return payment

def calculate_periods(payment: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Calculate the individual periods covered by a split payment."""
    periods = []
    actual_fee = payment.get("actual_fee") or 0
    
    if payment.get("applied_start_quarter") is not None:
        # Handle quarterly periods
        start_quarter = payment.get("applied_start_quarter")
        start_year = payment.get("applied_start_quarter_year")
        end_quarter = payment.get("applied_end_quarter")
        end_year = payment.get("applied_end_quarter_year")
        
        # Calculate total number of quarters
        total_quarters = (end_year - start_year) * 4 + (end_quarter - start_quarter) + 1
        amount_per_quarter = actual_fee / total_quarters if total_quarters > 0 else 0
        
        # Current quarter/year
        quarter = start_quarter
        year = start_year
        
        # Generate period for each quarter
        for _ in range(total_quarters):
            periods.append({
                "period": f"Q{quarter} {year}",
                "amount": amount_per_quarter
            })
            
            # Move to next quarter
            quarter += 1
            if quarter > 4:
                quarter = 1
                year += 1
    
    elif payment.get("applied_start_month") is not None:
        # Handle monthly periods
        start_month = payment.get("applied_start_month")
        start_year = payment.get("applied_start_month_year")
        end_month = payment.get("applied_end_month")
        end_year = payment.get("applied_end_month_year")
        
        # Calculate total number of months
        total_months = (end_year - start_year) * 12 + (end_month - start_month) + 1
        amount_per_month = actual_fee / total_months if total_months > 0 else 0
        
        # Current month/year
        month = start_month
        year = start_year
        
        # Generate period for each month
        for _ in range(total_months):
            month_name = MONTH_NAMES[month - 1]
            periods.append({
                "period": f"{month_name} {year}",
                "amount": amount_per_month
            })
            
            # Move to next month
            month += 1
            if month > 12:
                month = 1
                year += 1
    
    return periods

def get_available_periods(contract_id: int, client_id: int) -> AvailablePeriods:
    """Get available periods for payment selection based on payment history.
    
    Returns periods from one period prior to current date down to the first payment date.
    This supports the arrears payment logic where payments are always for the previous period.
    
    Now uses Period objects internally for reliable period arithmetic and comparisons.
    """
    periods_data = get_periods_from_service(contract_id, client_id)
    return AvailablePeriods(periods=periods_data["periods"])
```

services\period_service.py
```py
"""
Period service to centralize all period-related logic.
Replaces the 140+ lines of string manipulation in payment_service.py with Period objects.
"""
from typing import List, Dict, Any, Optional
from datetime import datetime
from core.database import execute_query
from models.period import Period


def get_available_periods(contract_id: int, client_id: int) -> Dict[str, List[Dict[str, str]]]:
    """
    Get available periods for payment selection based on payment history.
    
    Returns periods from one period prior to current date down to the first payment date.
    This supports the arrears payment logic where payments are always for the previous period.
    
    Now uses Period objects internally for reliable period arithmetic and comparisons.
    """
    # Get contract details
    contract_query = """
        SELECT contract_id, payment_schedule
        FROM contracts
        WHERE contract_id = :contract_id 
        AND client_id = :client_id
        AND valid_to IS NULL
    """
    contract_data = execute_query(
        contract_query, 
        {"contract_id": contract_id, "client_id": client_id}, 
        fetch_one=True
    )
    if not contract_data:
        return {"periods": []}
    
    is_monthly = contract_data["payment_schedule"].lower() == "monthly"
    
    # Get the earliest payment period for this client
    first_payment_period = get_first_payment_period(client_id, is_monthly)
    
    # Calculate the end period (one period prior to current for arrears)
    end_period = Period.get_previous_period_for_schedule(contract_data["payment_schedule"])
    
    # Determine start period
    if first_payment_period:
        start_period = first_payment_period
    else:
        # Default to beginning of current year if no payments
        current_year = datetime.now().year
        if is_monthly:
            start_period = Period(current_year, 1, is_monthly=True)
        else:
            start_period = Period(current_year, 1, is_monthly=False)
    
    # Generate period range
    try:
        periods_list = Period.generate_range(start_period, end_period)
    except ValueError:
        # If start is after end, just return the end period
        periods_list = [end_period]
    
    # Convert to API format (most recent first)
    periods = []
    for period in reversed(periods_list):
        periods.append({
            "label": period.to_display_string(),
            "value": period.to_string()
        })
    
    return {"periods": periods}


def get_first_payment_period(client_id: int, is_monthly: bool) -> Optional[Period]:
    """
    Get the earliest payment period for a client.
    
    Args:
        client_id: The client ID
        is_monthly: True for monthly payments, False for quarterly
        
    Returns:
        Period object representing the first payment period, or None if no payments
    """
    if is_monthly:
        query = """
            SELECT applied_start_month as first_month,
                   applied_start_month_year as first_month_year
            FROM payments
            WHERE client_id = :client_id
            AND valid_to IS NULL
            AND applied_start_month IS NOT NULL
            ORDER BY applied_start_month_year, applied_start_month
            LIMIT 1
        """
    else:
        query = """
            SELECT applied_start_quarter as first_quarter,
                   applied_start_quarter_year as first_quarter_year
            FROM payments
            WHERE client_id = :client_id
            AND valid_to IS NULL
            AND applied_start_quarter IS NOT NULL
            ORDER BY applied_start_quarter_year, applied_start_quarter
            LIMIT 1
        """
    
    result = execute_query(query, {"client_id": client_id}, fetch_one=True)
    
    if not result:
        return None
    
    if is_monthly:
        return Period(result["first_month_year"], result["first_month"], is_monthly=True)
    else:
        return Period(result["first_quarter_year"], result["first_quarter"], is_monthly=False)


def get_current_period(is_monthly: bool = True) -> Period:
    """
    Get the current period based on today's date.
    
    Args:
        is_monthly: True for monthly period, False for quarterly
        
    Returns:
        Period object representing the current period
    """
    return Period.get_current_period(is_monthly)


def get_previous_period(is_monthly: bool = True) -> Period:
    """
    Get the previous period (for arrears payment logic).
    
    Args:
        is_monthly: True for monthly period, False for quarterly
        
    Returns:
        Period object representing the previous period
    """
    current = get_current_period(is_monthly)
    return current.get_previous_period()


def get_next_period(period: Period) -> Period:
    """
    Get the period immediately after the given period.
    
    Args:
        period: The period to get the next period for
        
    Returns:
        The next period
    """
    return period.get_next_period()


def calculate_period_range(start_period: Period, end_period: Period) -> List[Period]:
    """
    Generate a list of periods from start to end (inclusive).
    
    Args:
        start_period: The starting period
        end_period: The ending period
        
    Returns:
        List of Period objects from start to end
        
    Raises:
        ValueError: If periods are incompatible or start > end
    """
    return Period.generate_range(start_period, end_period)


def parse_period_string(period_str: str, is_quarterly: bool = False) -> Period:
    """
    Parse a period string into a Period object.
    
    Args:
        period_str: String like "3-2024" or "Q1-2024"
        is_quarterly: True if the period should be parsed as quarterly
        
    Returns:
        Period object
        
    Raises:
        ValueError: If the period string is invalid
    """
    if is_quarterly:
        return Period.from_quarterly_string(period_str)
    else:
        return Period.from_string(period_str)


def periods_between(start: Period, end: Period) -> int:
    """
    Calculate the number of periods between two periods.
    
    Args:
        start: The starting period
        end: The ending period
        
    Returns:
        Number of periods (positive if end is after start, negative if before)
        
    Raises:
        ValueError: If periods are incompatible types
    """
    return start.periods_between(end)


def format_period_for_display(period: Period) -> str:
    """
    Format a period for human-readable display.
    
    Args:
        period: The period to format
        
    Returns:
        Human-readable string like "March 2024" or "Q1 2024"
    """
    return period.to_display_string()


def format_period_for_api(period: Period) -> str:
    """
    Format a period for API responses (backward compatibility).
    
    Args:
        period: The period to format
        
    Returns:
        API-compatible string like "3-2024"
    """
    return period.to_string()


def is_period_in_past(period: Period) -> bool:
    """
    Check if a period is in the past relative to the current period.
    
    Args:
        period: The period to check
        
    Returns:
        True if the period is in the past
    """
    current = Period.get_current_period(period.is_monthly)
    return period < current


def get_payment_period_from_payment_data(payment_data: Dict[str, Any]) -> Optional[Period]:
    """
    Extract the payment period from payment database row data.
    
    Args:
        payment_data: Dictionary containing payment data from database
        
    Returns:
        Period object representing the applied period, or None if invalid
    """
    # Check for quarterly period first
    if (payment_data.get("applied_start_quarter") is not None and 
        payment_data.get("applied_start_quarter_year") is not None):
        
        quarter = payment_data["applied_start_quarter"]
        year = payment_data["applied_start_quarter_year"]
        return Period(year, quarter, is_monthly=False)
    
    # Check for monthly period
    elif (payment_data.get("applied_start_month") is not None and 
          payment_data.get("applied_start_month_year") is not None):
        
        month = payment_data["applied_start_month"]
        year = payment_data["applied_start_month_year"]
        return Period(year, month, is_monthly=True)
    
    return None


def convert_period_to_payment_fields(period: Period) -> Dict[str, Any]:
    """
    Convert a Period object to database fields for payment storage.
    
    Args:
        period: The period to convert
        
    Returns:
        Dictionary with database field names and values
    """
    if period.is_monthly:
        return {
            "applied_start_month": period.value,
            "applied_start_month_year": period.year,
            "applied_end_month": period.value,
            "applied_end_month_year": period.year,
            "applied_start_quarter": None,
            "applied_start_quarter_year": None,
            "applied_end_quarter": None,
            "applied_end_quarter_year": None
        }
    else:
        return {
            "applied_start_month": None,
            "applied_start_month_year": None,
            "applied_end_month": None,
            "applied_end_month_year": None,
            "applied_start_quarter": period.value,
            "applied_start_quarter_year": period.year,
            "applied_end_quarter": period.value,
            "applied_end_quarter_year": period.year
        }


def convert_period_range_to_payment_fields(start_period: Period, end_period: Period) -> Dict[str, Any]:
    """
    Convert a period range to database fields for split payment storage.
    
    Args:
        start_period: The starting period
        end_period: The ending period
        
    Returns:
        Dictionary with database field names and values
        
    Raises:
        ValueError: If periods are incompatible types or start > end
    """
    if start_period.is_monthly != end_period.is_monthly:
        raise ValueError("Start and end periods must be the same type")
    
    if start_period > end_period:
        raise ValueError("Start period must be before or equal to end period")
    
    if start_period.is_monthly:
        return {
            "applied_start_month": start_period.value,
            "applied_start_month_year": start_period.year,
            "applied_end_month": end_period.value,
            "applied_end_month_year": end_period.year,
            "applied_start_quarter": None,
            "applied_start_quarter_year": None,
            "applied_end_quarter": None,
            "applied_end_quarter_year": None
        }
    else:
        return {
            "applied_start_month": None,
            "applied_start_month_year": None,
            "applied_end_month": None,
            "applied_end_month_year": None,
            "applied_start_quarter": start_period.value,
            "applied_start_quarter_year": start_period.year,
            "applied_end_quarter": end_period.value,
            "applied_end_quarter_year": end_period.year
        }
```

utils\__init__.py
```py
"""Utils package for the application.""" 
```

utils\constants.py
```py
"""Constants used throughout the application."""

# Month names used in multiple services
MONTH_NAMES = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
]

# Payment methods used in the payment form
PAYMENT_METHODS = [
    "Auto - ACH", 
    "Auto - Check", 
    "Invoice - Check", 
    "Wire Transfer", 
    "Check"
]

# Payment statuses
PAYMENT_STATUS = {
    "PAID": "Paid",
    "DUE": "Due",
    "OVERDUE": "Overdue"
}

# Fee types
FEE_TYPES = {
    "FLAT": "flat",
    "PERCENTAGE": "percentage",
    "PERCENT": "percent"
}

# Payment schedules
PAYMENT_SCHEDULES = {
    "MONTHLY": "monthly",
    "QUARTERLY": "quarterly"
}
```

utils\user_utils.py
```py
# user_utils.py
import os
import sqlite3
from pathlib import Path

_USERNAME = os.getlogin()

def get_user_base_path():
    # Updated path to match the actual location without the "401Ks/Current Plans/" part
    base_path = Path(f"C:/Users/{_USERNAME}/Hohimer Wealth Management/Hohimer Company Portal - Hohimer Team Shared 4-15-19")
    return base_path

def validate_db_path(db_path):
    """Validate that the database file exists and is accessible."""
    if not db_path.exists():
        raise FileNotFoundError(f"Database file not found at: {db_path}")
    
    # Try to open the database to confirm it's a valid SQLite file
    try:
        conn = sqlite3.connect(str(db_path))
        conn.close()
        return True
    except sqlite3.Error as e:
        raise sqlite3.Error(f"Error accessing database at {db_path}: {str(e)}")
```