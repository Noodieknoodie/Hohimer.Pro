
<doc 1>
Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Quickstart: Create and deploy functions to Azure Functions using the Azure Developer CLI
	•	2024-10-19
In this article
In this Quickstart, you use Azure Developer command-line tools to create functions that respond to HTTP requests. After testing the code locally, you deploy it to a new serverless function app you create running in a Flex Consumption plan in Azure Functions.
The project source uses the Azure Developer CLI (azd) to simplify deploying your code to Azure. This deployment follows current best practices for secure and scalable Azure Functions deployments.
By default, the Flex Consumption plan follows a pay-for-what-you-use billing model, which means to complete this quickstart incurs a small cost of a few USD cents or less in your Azure account.
Prerequisites
	•	An Azure account with an active subscription. Create an account for free.
	•	Azure Developer CLI.
	•	Azure Functions Core Tools.
	•	.NET 8.0 SDK
	•	Azurite storage emulator
	•	Java 17 Developer Kit
	◦	If you use another supported version of Java, you must update the project's pom.xml file.
	◦	The JAVA_HOME environment variable must be set to the install location of the correct version of the JDK.
	•	Apache Maven 3.8.x
	•	Node.js 20
	•	PowerShell 7.2
	•	.NET 6.0 SDK
	•	Python 3.11.
	•	A secure HTTP test tool for sending requests with JSON payloads to your function endpoints. This article uses curl.
Initialize the project
You can use the azd init command to create a local Azure Functions code project from a template.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template functions-quickstart-dotnet-azd -e flexquickstart-dotnet
	2	 This command pulls the project files from the template repository and initializes the project in the current folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Run this command to navigate to the http app folder: cd http
	4	
	5	Create a file named local.settings.json in the http folder that contains this JSON data: {
	6	  "IsEncrypted": false,
	7	  "Values": {
	8	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	9	    "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
	10	  }
	11	}
	12	 This file is required when running locally.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template azure-functions-java-flex-consumption-azd -e flexquickstart-java 
	2	 This command pulls the project files from the template repository and initializes the project in the current folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Run this command to navigate to the http app folder: cd http
	4	
	5	Create a file named local.settings.json in the http folder that contains this JSON data: {
	6	  "IsEncrypted": false,
	7	  "Values": {
	8	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	9	    "FUNCTIONS_WORKER_RUNTIME": "java"
	10	  }
	11	}
	12	 This file is required when running locally.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template functions-quickstart-javascript-azd -e flexquickstart-js
	2	 This command pulls the project files from the template repository and initializes the project in the root folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Create a file named local.settings.json in the root folder that contains this JSON data: {
	4	  "IsEncrypted": false,
	5	  "Values": {
	6	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	7	    "FUNCTIONS_WORKER_RUNTIME": "node"
	8	  }
	9	}
	10	 This file is required when running locally.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template functions-quickstart-powershell-azd -e flexquickstart-ps
	2	 This command pulls the project files from the template repository and initializes the project in the root folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Run this command to navigate to the src app folder: cd src
	4	
	5	Create a file named local.settings.json in the src folder that contains this JSON data: {
	6	  "IsEncrypted": false,
	7	  "Values": {
	8	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	9	    "FUNCTIONS_WORKER_RUNTIME": "powershell",
	10	    "FUNCTIONS_WORKER_RUNTIME_VERSION": "7.2"
	11	  }
	12	}
	13	 This file is required when running locally.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template functions-quickstart-typescript-azd -e flexquickstart-ts
	2	 This command pulls the project files from the template repository and initializes the project in the root folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Create a file named local.settings.json in the root folder that contains this JSON data: {
	4	  "IsEncrypted": false,
	5	  "Values": {
	6	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	7	    "FUNCTIONS_WORKER_RUNTIME": "node"
	8	  }
	9	}
	10	 This file is required when running locally.
	1	In your local terminal or command prompt, run this azd init command in an empty folder: azd init --template functions-quickstart-python-http-azd -e flexquickstart-py
	2	 This command pulls the project files from the template repository and initializes the project in the root folder. The -e flag sets a name for the current environment. In azd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
	3	Create a file named local.settings.json in the root folder that contains this JSON data: {
	4	  "IsEncrypted": false,
	5	  "Values": {
	6	    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
	7	    "FUNCTIONS_WORKER_RUNTIME": "python"
	8	  }
	9	}
	10	 This file is required when running locally.
Create and activate a virtual environment
In the root folder, run these commands to create and activate a virtual environment named .venv:
	•	Linux/macOS
	•	Windows (bash)
	•	Windows (Cmd)
python3 -m venv .venv
source .venv/bin/activate
If Python didn't install the venv package on your Linux distribution, run the following command:
sudo apt-get install python3-venv
Run in your local environment
	1	Run this command from your app folder in a terminal or command prompt: func start
	2	  mvn clean package
	3	mvn azure-functions:run
	4	  npm install
	5	func start 
	6	  npm install
	7	npm start 
	8	  When the Functions host starts in your local project folder, it writes the URL endpoints of your HTTP triggered functions to the terminal output.
	9	In your browser, navigate to the httpget endpoint, which should look like this URL: http://localhost:7071/api/httpget
	10	From a new terminal or command prompt window, run this curl command to send a POST request with a JSON payload to the httppost endpoint: curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d @testdata.json
	11	  curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d "@src/functions/testdata.json"
	12	  This command reads JSON payload data from the testdata.json project file. You can find examples of both HTTP requests in the test.http project file.
	13	When you're done, press Ctrl+C in the terminal window to stop the func.exe host process.
	5	Run deactivate to shut down the virtual environment.
Review the code (optional)
You can review the code that defines the two HTTP trigger function endpoints:
	•	httpget
	•	httppost
    [Function("httpget")]
    public IActionResult Run([HttpTrigger(AuthorizationLevel.Function, "get")]
     HttpRequest req,
     string name)
    {
      var returnValue = string.IsNullOrEmpty(name)
        ? "Hello, World."
        : $"Hello, {name}.";

      _logger.LogInformation($"C# HTTP trigger function processed a request for {returnValue}.");

      return new OkObjectResult(returnValue);
    }
@FunctionName("httpget")
public HttpResponseMessage run(
    @HttpTrigger(
      name = "req",
      methods = {HttpMethod.GET},
      authLevel = AuthorizationLevel.FUNCTION)
      HttpRequestMessage<Optional<String>> request,
    final ExecutionContext context) {
  context.getLogger().info("Java HTTP trigger processed a request.");

  // Parse query parameter
  String name = Optional.ofNullable(request.getQueryParameters().get("name")).orElse("World");

  return request.createResponseBuilder(HttpStatus.OK).body("Hello, " + name).build();
}
const { app } = require('@azure/functions');

app.http('httpget', {
  methods: ['GET'],
  authLevel: 'function',
  handler: async (request, context) => {
    context.log(`Http function processed request for url "${request.url}"`);

    const name = request.query.get('name') || await request.text() || 'world';

    return { body: `Hello, ${name}!` };
  }
});
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

export async function httpGetFunction(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
  context.log(`Http function processed request for url "${request.url}"`);

  const name = request.query.get('name') || await request.text() || 'world';

  return { body: `Hello, ${name}!` };
};

app.http('httpget', {
  methods: ['GET'],
  authLevel: 'function',
  handler: httpGetFunction
});
This function.json file defines the httpget function:
{
 "bindings": [
  {
   "authLevel": "function",
   "type": "httpTrigger",
   "direction": "in",
   "name": "Request",
   "methods": [
    "get"
   ],
   "route": "httpget"
  },
  {
   "type": "http",
   "direction": "out",
   "name": "Response"
  }
 ]
}
This run.ps1 file implements the function code:
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with query parameters
$name = $Request.Query.name

$body = "This HTTP triggered function executed successfully. Pass a name in the query string for a personalized response."

if ($name) {
  $body = "Hello, $name. This HTTP triggered function executed successfully."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
  StatusCode = [HttpStatusCode]::OK
  Body = $body
})
@app.route(route="httpget", methods=["GET"])
def http_get(req: func.HttpRequest) -> func.HttpResponse:
  name = req.params.get("name", "World")

  logging.info(f"Processing GET request. Name: {name}")

  return func.HttpResponse(f"Hello, {name}!")
You can review the complete template project here.
You can review the complete template project here.
You can review the complete template project here.
You can review the complete template project here.
You can review the complete template project here.
You can review the complete template project here.
After you verify your functions locally, it's time to publish them to Azure.
Create Azure resources
This project is configured to use the azd provision command to create a function app in a Flex Consumption plan, along with other required Azure resources.
Note
This project includes a set of Bicep files that azd uses to create a secure deployment to a Flex consumption plan that follows best practices.
The azd up and azd deploy commands aren't currently supported for Java apps.
	1	In the root folder of the project, run this command to create the required Azure resources: azd provision
	2	 The root folder contains the azure.yaml definition file required by azd. If you aren't already signed-in, you're asked to authenticate with your Azure account.
	3	When prompted, provide these required deployment parameters:
	4	Parameter
	5	Description
	6	Azure subscription
	7	Subscription in which your resources are created.
	8	Azure location
	9	Azure region in which to create the resource group that contains the new Azure resources. Only regions that currently support the Flex Consumption plan are shown.
	10	The azd provision command uses your response to these prompts with the Bicep configuration files to create and configure these required Azure resources:
	◦	Flex Consumption plan and function app
	◦	Azure Storage (required) and Application Insights (recommended)
	◦	Access policies and roles for your account
	◦	Service-to-service connections using managed identities (instead of stored connection strings)
	◦	Virtual network to securely run both the function app and the other Azure resources
	11	After the command completes successfully, you can deploy your project code to this new function app in Azure.
Deploy to Azure
You can use Core Tools to package your code and deploy it to Azure from the target output folder.
	1	Navigate to the app folder equivalent in the target output folder: cd http/target/azure-functions/contoso-functions
	2	 This folder should have a host.json file, which indicates that it's the root of your compiled Java function app.
	3	Run these commands to deploy your compiled Java code project to the new function app resource in Azure using Core Tools:
	◦	bash
	◦	Cmd
	4	APP_NAME=$(azd env get-value AZURE_FUNCTION_NAME)
	5	func azure functionapp publish $APP_NAME
	6	   The azd env get-value command gets your function app name from the local environment, which is required for deployment using func azure functionapp publish. After publishing completes successfully, you see links to the HTTP trigger endpoints in Azure.
Deploy to Azure
This project is configured to use the azd up command to deploy this project to a new function app in a Flex Consumption plan in Azure.
Tip
This project includes a set of Bicep files that azd uses to create a secure deployment to a Flex consumption plan that follows best practices.
	1	Run this command to have azd create the required Azure resources in Azure and deploy your code project to the new function app: azd up
	2	 The root folder contains the azure.yaml definition file required by azd. If you aren't already signed-in, you're asked to authenticate with your Azure account.
	3	When prompted, provide these required deployment parameters:
	4	Parameter
	5	Description
	6	Azure subscription
	7	Subscription in which your resources are created.
	8	Azure location
	9	Azure region in which to create the resource group that contains the new Azure resources. Only regions that currently support the Flex Consumption plan are shown.
	10	The azd up command uses your response to these prompts with the Bicep configuration files to complete these deployment tasks:
	◦	Create and configure these required Azure resources (equivalent to azd provision):
	▪	Flex Consumption plan and function app
	▪	Azure Storage (required) and Application Insights (recommended)
	▪	Access policies and roles for your account
	▪	Service-to-service connections using managed identities (instead of stored connection strings)
	▪	Virtual network to securely run both the function app and the other Azure resources
	◦	Package and deploy your code to the deployment container (equivalent to azd deploy). The app is then started and runs in the deployed package.
	11	After the command completes successfully, you see links to the resources you created.
Invoke the function on Azure
You can now invoke your function endpoints in Azure by making HTTP requests to their URLs using your HTTP test tool or from the browser (for GET requests). When your functions run in Azure, access key authorization is enforced, and you must provide a function access key with your request.
You can use the Core Tools to obtain the URL endpoints of your functions running in Azure.
	1	In your local terminal or command prompt, run these commands to get the URL endpoint values:
	◦	bash
	◦	Cmd
	2	SET APP_NAME=(azd env get-value AZURE_FUNCTION_NAME)
	3	func azure functionapp list-functions $APP_NAME --show-keys
	4	   
	◦	PowerShell
	◦	Cmd
	5	$APP_NAME = azd env get-value AZURE_FUNCTION_NAME
	6	func azure functionapp list-functions $APP_NAME --show-keys
	7	    The azd env get-value command gets your function app name from the local environment. Using the --show-keys option with func azure functionapp list-functions means that the returned Invoke URL: value for each endpoint includes a function-level access key.
	8	As before, use your HTTP test tool to validate these URLs in your function app running in Azure.
Redeploy your code
You can run the azd up command as many times as you need to both provision your Azure resources and deploy code updates to your function app.
Note
Deployed code files are always overwritten by the latest deployment package.
Your initial responses to azd prompts and any environment variables generated by azd are stored locally in your named environment. Use the azd env get-values command to review all of the variables in your environment that were used when creating Azure resources.
Clean up resources
When you're done working with your function app and related resources, you can use this command to delete the function app and its related resources from Azure and avoid incurring any further costs:
azd down --no-prompt
Note
The --no-prompt option instructs azd to delete your resource group without a confirmation from you.
This command doesn't affect your local code project.
Related content
	•	Flex Consumption plan
	•	Azure Developer CLI (azd)
	•	azd reference
	•	Azure Functions Core Tools reference
	•	Code and test Azure Functions locally




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025

</doc 1>

————————————————————————

<doc 2>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Quickstart: Create ARM templates with Visual Studio Code
	•	2025-01-29
In this article
The Azure Resource Manager Tools for Visual Studio Code provide language support, resource snippets, and resource autocompletion. These tools help you create and validate Azure Resource Manager templates (ARM templates). Because of these features, we recommend using these tools to create and configure ARM templates. In this quickstart, you use the extension to create an ARM template from scratch. While doing so, you experience the extension's capabilities, such as ARM template snippets, validation, completions, and parameter file support.
This quickstart focuses on using the Visual Studio Code extension to build the ARM template. For a tutorial that is more focused on syntax, see Tutorial: Create and deploy your first ARM template.
To complete this quickstart, you need Visual Studio Code, with the Azure Resource Manager tools extension installed. You also need either the Azure CLI or the Azure PowerShell module installed and authenticated.
If you don't have an Azure subscription, create a free account before you begin.
Tip
We recommend Bicep because it offers the same capabilities as ARM templates and the syntax is easier to use. To learn more, see Quickstart: Create Bicep files with Visual Studio Code.
Note
The current release of the Azure Resource Manager Tools extension for Visual Studio Code does not recognize the enhancements made in languageVersion 2.0.
Create an ARM template
Create and open with Visual Studio Code a new file named azuredeploy.json. Enter arm into the code editor, which initiates Azure Resource Manager snippets for scaffolding out an ARM template.
Select arm! to create a template scoped for an Azure resource group deployment.

This snippet creates the basic building blocks for an ARM template.

Notice that the Visual Studio Code language mode changed from JSON to Azure Resource Manager Template. The extension includes a language server specific to ARM templates that provides template-specific validation, completion, and other language services.

Add an Azure resource
The extension includes snippets for many Azure resources. Use these snippets to easily add resources to your template deployment.
Place the cursor in the template resources block, type storage, and select the arm-storage snippet.

This action adds a storage resource to the template.

Use the tab key to tab through configurable properties on the storage account.

Completion and validation
One of the most powerful capabilities of the extension is its integration with Azure schemas. Azure schemas provide the extension with validation and resource-aware completion capabilities. To see validation and completion in action, modify the storage account.
First, update the storage account kind to an invalid value such as megaStorage. This action produces a warning that megaStorage isn't a valid value.

To use the completion capabilities, remove megaStorage, place the cursor inside of the double quotes, and press ctrl + space. This action presents a completion list of valid values.

Add template parameters
Now create and use a parameter to specify the storage account name.
Place your cursor in the parameters block, add a carriage return, type ", and then select the new-parameter snippet. This action adds a generic parameter to the template.

Update the name of the parameter to storageAccountName and the description to Storage account name.

Azure storage account names have a minimum length of three characters and a maximum of 24. Add both minLength and maxLength to the parameter and provide appropriate values.

Now, on the storage resource, update the name property to use the parameter. To do so, remove the current name. Enter a double quote and an opening square bracket [, which produces a list of ARM template functions. Select parameters from the list.

Entering a single quote ' inside of the round brackets produces a list of all parameters defined in the template, in this case, storageAccountName. Select the parameter.

Create a parameter file
An ARM template parameter file allows you to store environment-specific parameter values and pass these values in as a group at deployment time. For example, you can have a parameter file with values specific to a test environment and another for a production environment.
The extension makes it easy to create a parameter file from your existing templates. To do so, right-click on the template in the code editor and select Select/Create Parameter File.

Select New > All Parameters > Select a name and location for the parameter file.
This action creates a new parameter file and maps it with the template from which it was created. You can see and modify the current template/parameter file mapping in the Visual Studio Code status bar while the template is selected.

Now that the parameter file is mapped to the template, the extension validates both the template and parameter file together. To see this validation in practice, add a two-character value to the storageAccountName parameter in the parameter file and save the file.

Navigate back to the ARM template and notice the error indicating that the value doesn't meet the parameter criteria.

Update the value to something appropriate, save the file, and navigate back to the template. Notice that the error on the parameter is resolved.
Deploy the template
Open the integrated Visual Studio Code terminal using the ctrl + ` key combination and use either the Azure CLI or Azure PowerShell module to deploy the template.
	•	CLI
	•	PowerShell
az group create --name arm-vscode --location eastus

az deployment group create --resource-group arm-vscode --template-file azuredeploy.json --parameters azuredeploy.parameters.json
Clean up resources
When you no longer need the Azure resources, use the Azure CLI or Azure PowerShell module to delete the quickstart resource group.
	•	CLI
	•	PowerShell
az group delete --name arm-vscode
Next steps
Beginner tutorials




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 2>

————————————————————————

<doc 3>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
ARM template best practices
	•	2025-04-28
In this article
This article shows you how to use recommended practices when constructing your Azure Resource Manager template (ARM template). These recommendations help you avoid common problems when using an ARM template to deploy a solution.
Template limits
Limit the size of your template to 4 MB, and each resource definition to 1 MB. The limits apply to the final state of the template after it has been expanded with iterative resource definitions, and values for variables and parameters. The parameter file is also limited to 4 MB. You may get an error with a template or parameter file of less than 4 MB if the total size of the request is too large. For more information about how to simplify your template to avoid a large request, see Resolve errors for job size exceeded.
You're also limited to:
	•	256 parameters
	•	512 variables
	•	800 resources (including copy count)
	•	64 output values
	•	10 unique locations per subscription/tenant/management group scope
	•	24,576 characters in a template expression
You can exceed some template limits by using a nested template. For more information, see Using linked and nested templates when deploying Azure resources. To reduce the number of parameters, variables, or outputs, you can combine several values into an object. For more information, see Objects as parameters.
Resource group
When you deploy resources to a resource group, the resource group stores metadata about the resources. The metadata is stored in the location of the resource group.
If the resource group's region is temporarily unavailable, you can't update resources in the resource group because the metadata is unavailable. The resources in other regions will still function as expected, but you can't update them. To minimize risk, locate your resource group and resources in the same region.
Parameters
The information in this section can be helpful when you work with parameters.
General recommendations for parameters
	•	Minimize your use of parameters. Instead, use variables or literal values for properties that don't need to be specified during deployment.
	•	Use camel case for parameter names.
	•	Use parameters for settings that vary according to the environment, like SKU, size, or capacity.
	•	Use parameters for resource names that you want to specify for easy identification.
	•	Provide a description of every parameter in the metadata. "parameters": {
	•	 "storageAccountType": {
	•	  "type": "string",
	•	  "metadata": {
	•	   "description": "The type of the new storage account created to store the VM disks."
	•	  }
	•	 }
	•	}
	•	
	•	Define default values for parameters that aren't sensitive. By specifying a default value, it's easier to deploy the template, and users of your template see an example of an appropriate value. Any default value for a parameter must be valid for all users in the default deployment configuration. "parameters": {
	•	 "storageAccountType": {
	•	  "type": "string",
	•	  "defaultValue": "Standard_GRS",
	•	  "metadata": {
	•	   "description": "The type of the new storage account created to store the VM disks."
	•	  }
	•	 }
	•	}
	•	
	•	To specify an optional parameter, don't use an empty string as a default value. Instead, use a literal value or a language expression to construct a value. "storageAccountName": {
	•	  "type": "string",
	•	  "defaultValue": "[concat('storage', uniqueString(resourceGroup().id))]",
	•	  "metadata": {
	•	   "description": "Name of the storage account"
	•	  }
	•	}
	•	
	•	Use allowedValues sparingly. Use it only when you must make sure some values aren't included in the permitted options. If you use allowedValues too broadly, you might block valid deployments by not keeping your list up to date.
	•	When a parameter name in your template matches a parameter in the PowerShell deployment command, Resource Manager resolves this naming conflict by adding the postfix FromTemplate to the template parameter. For example, if you include a parameter named ResourceGroupName in your template, it conflicts with the ResourceGroupName parameter in the New-AzResourceGroupDeployment cmdlet. During deployment, you're prompted to provide a value for ResourceGroupNameFromTemplate.
Security recommendations for parameters
	•	Always use parameters for user names and passwords (or secrets).
	•	Use securestring for all passwords and secrets. If you pass sensitive data in a JSON object, use the secureObject type. Template parameters with secure string or secure object types can't be read after resource deployment. "parameters": {
	•	 "secretValue": {
	•	  "type": "securestring",
	•	  "metadata": {
	•	   "description": "The value of the secret to store in the vault."
	•	  }
	•	 }
	•	}
	•	
	•	Don't provide default values for user names, passwords, or any value that requires a secureString type.
	•	Don't provide default values for properties that increase the attack surface area of the application.
Location recommendations for parameters
	•	Use a parameter to specify the location for resources, and set the default value to resourceGroup().location. Providing a location parameter enables users of the template to specify a location where they have permission to deploy resources. "parameters": {
	•	  "location": {
	•	   "type": "string",
	•	   "defaultValue": "[resourceGroup().location]",
	•	   "metadata": {
	•	    "description": "The location in which the resources should be deployed."
	•	   }
	•	  }
	•	}
	•	
	•	Don't specify allowedValues for the location parameter. The locations you specify might not be available in all clouds.
	•	Use the location parameter value for resources that are likely to be in the same location. This approach minimizes the number of times users are asked to provide location information.
	•	For resources that aren't available in all locations, use a separate parameter or specify a literal location value.
Variables
The following information can be helpful when you work with variables:
	•	Use camel case for variable names.
	•	Use variables for values that you need to use more than once in a template. If a value is used only once, a hard-coded value makes your template easier to read.
	•	Use variables for values that you construct from a complex arrangement of template functions. Your template is easier to read when the complex expression only appears in variables.
	•	You can't use the reference function in the variables section of the template. The reference function derives its value from the resource's runtime state. However, variables are resolved during the initial parsing of the template. Construct values that need the reference function directly in the resources or outputs section of the template.
	•	Include variables for resource names that must be unique.
	•	Use a copy loop in variables to create a repeated pattern of JSON objects.
	•	Remove unused variables.
API version
Set the apiVersion property to a hard-coded API version for the resource type. When creating a new template, we recommend you use the latest API version for a resource type. To determine available values, see template reference.
When your template works as expected, we recommend you continue using the same API version. By using the same API version, you don't have to worry about breaking changes that might be introduced in later versions.
Don't use a parameter for the API version. Resource properties and values can vary by API version. IntelliSense in a code editor can't determine the correct schema when the API version is set to a parameter. If you pass in an API version that doesn't match the properties in your template, the deployment will fail.
Don't use variables for the API version.
Resource dependencies
When deciding what dependencies to set, use the following guidelines:
	•	Use the reference function and pass in the resource name to set an implicit dependency between resources that need to share a property. Don't add an explicit dependsOn element when you've already defined an implicit dependency. This approach reduces the risk of having unnecessary dependencies. For an example of setting an implicit dependency, see reference and list functions.
	•	Set a child resource as dependent on its parent resource.
	•	Resources with the condition element set to false are automatically removed from the dependency order. Set the dependencies as if the resource is always deployed.
	•	Let dependencies cascade without setting them explicitly. For example, your virtual machine depends on a virtual network interface, and the virtual network interface depends on a virtual network and public IP addresses. Therefore, the virtual machine is deployed after all three resources, but don't explicitly set the virtual machine as dependent on all three resources. This approach clarifies the dependency order and makes it easier to change the template later.
	•	If a value can be determined before deployment, try deploying the resource without a dependency. For example, if a configuration value needs the name of another resource, you might not need a dependency. This guidance doesn't always work because some resources verify the existence of the other resource. If you receive an error, add a dependency.
Resources
The following information can be helpful when you work with resources:
	•	To help other contributors understand the purpose of the resource, specify comments for each resource in the template. "resources": [
	•	 {
	•	  "name": "[variables('storageAccountName')]",
	•	  "type": "Microsoft.Storage/storageAccounts",
	•	  "apiVersion": "2019-06-01",
	•	  "location": "[resourceGroup().location]",
	•	  "comments": "This storage account is used to store the VM disks.",
	•	   ...
	•	 }
	•	]
	•	 If your ARM template is stored in a .jsonc file, comments using the // syntax are supported, as shown here. "resources": [
	•	 {
	•	  // This storage account is used to store the VM disks.
	•	  "name": "[variables('storageAccountName')]",
	•	  "type": "Microsoft.Storage/storageAccounts",
	•	  "apiVersion": "2019-06-01",
	•	  "location": "[resourceGroup().location]",
	•	   ...
	•	 }
	•	]
	•	 For more details about comments and metadata, see Understand the structure and syntax of ARM templates.
	•	If you use a public endpoint in your template (such as an Azure Blob storage public endpoint), don't hard-code the namespace. Use the reference function to dynamically retrieve the namespace. You can use this approach to deploy the template to different public namespace environments without manually changing the endpoint in the template. Set the API version to the same version that you're using for the storage account in your template. "diagnosticsProfile": {
	•	 "bootDiagnostics": {
	•	  "enabled": "true",
	•	  "storageUri": "[reference(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2019-06-01').primaryEndpoints.blob]"
	•	 }
	•	}
	•	 If the storage account is deployed in the same template that you're creating and the name of the storage account isn't shared with another resource in the template, you don't need to specify the provider namespace or the apiVersion when you reference the resource. The following example shows the simplified syntax. "diagnosticsProfile": {
	•	 "bootDiagnostics": {
	•	  "enabled": "true",
	•	  "storageUri": "[reference(variables('storageAccountName')).primaryEndpoints.blob]"
	•	 }
	•	}
	•	 You also can reference an existing storage account that's in a different resource group. "diagnosticsProfile": {
	•	 "bootDiagnostics": {
	•	  "enabled": "true",
	•	  "storageUri": "[reference(resourceId(parameters('existingResourceGroup'), 'Microsoft.Storage/storageAccounts', parameters('existingStorageAccountName')), '2019-06-01').primaryEndpoints.blob]"
	•	 }
	•	}
	•	
	•	Assign public IP addresses to a virtual machine only when an application requires it. To connect to a virtual machine for administrative purposes, use inbound NAT rules, a virtual network gateway, or a jumpbox. For more information about connecting to virtual machines, see:
	◦	What is Azure Bastion?
	◦	How to connect and sign on to an Azure virtual machine running Windows
	◦	Setting up WinRM access for Virtual Machines in Azure Resource Manager
	◦	Connect to a Linux VM
	•	The domainNameLabel property for public IP addresses must be unique. The domainNameLabel value must be between 3 and 63 characters long, and follow the rules specified by this regular expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$. Because the uniqueString function generates a string that is 13 characters long, the dnsPrefixString parameter is limited to 50 characters. "parameters": {
	•	 "dnsPrefixString": {
	•	  "type": "string",
	•	  "maxLength": 50,
	•	  "metadata": {
	•	   "description": "The DNS label for the public IP address. It must be lowercase. It should match the following regular expression, or it will raise an error: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$"
	•	  }
	•	 }
	•	},
	•	"variables": {
	•	 "dnsPrefix": "[concat(parameters('dnsPrefixString'),uniquestring(resourceGroup().id))]"
	•	}
	•	
	•	When you add a password to a custom script extension, use the commandToExecute property in the protectedSettings property. "properties": {
	•	 "publisher": "Microsoft.Azure.Extensions",
	•	 "type": "CustomScript",
	•	 "typeHandlerVersion": "2.0",
	•	 "autoUpgradeMinorVersion": true,
	•	 "settings": {
	•	  "fileUris": [
	•	   "[concat(variables('template').assets, '/lamp-app/install_lamp.sh')]"
	•	  ]
	•	 },
	•	 "protectedSettings": {
	•	  "commandToExecute": "[concat('sh install_lamp.sh ', parameters('mySqlPassword'))]"
	•	 }
	•	}
	•	 Note To ensure that secrets are encrypted when they are passed as parameters to VMs and extensions, use the protectedSettings property of the relevant extensions. 
	•	Specify explicit values for properties that have default values that could change over time. For example, if you're deploying an AKS cluster, you can either specify or omit the kubernetesVersion property. If you don't specify it, then the cluster is defaulted to the N-1 minor version and latest patch. When you deploy the cluster using an ARM template, this default behavior might not be what you expect. Redeploying your template may result in the cluster being upgraded to a new Kubernetes version unexpectedly. Instead, consider specifying an explicit version number and then manually changing it when you're ready to upgrade your cluster.
Comments
In addition to the comments property, comments using the // syntax are supported. For more details about comments and metadata, see Understand the structure and syntax of ARM templates. You may choose to save JSON files that contain // comments using the .jsonc file extension, to indicate the JSON file contains comments. The ARM service will also accept comments in any JSON file including parameters files.
Visual Studio Code ARM Tools
Working with ARM templates is easier with the Azure Resource Manager (ARM) Tools for Visual Studio Code. This extension provides language support, resource snippets, and resource auto-completion to help you create and validate Azure Resource Manager templates. To learn more and install the extension, see Azure Resource Manager (ARM) Tools.
Use test toolkit
The ARM template test toolkit is a script that checks whether your template uses recommended practices. When your template isn't compliant with recommended practices, it returns a list of warnings with suggested changes. The test toolkit can help you learn how to implement best practices in your template.
After you've completed your template, run the test toolkit to see if there are ways you can improve its implementation. For more information, see Use ARM template test toolkit.
Next steps
	•	For information about the structure of the template file, see Understand the structure and syntax of ARM templates.
	•	For recommendations about how to build templates that work in all Azure cloud environments, see Develop ARM templates for cloud consistency.




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 3>

————————————————————————

<doc 4>

Skip to main content





Table of contents Exit focus mode



Table of contents Add

Share via
Facebook x.com LinkedIn Email

Print
Define resources with Bicep, ARM templates, and Terraform AzAPI provider
	•	2023-03-22
In this article
When deploying Azure resources with an Infrastructure as Code tool, you need to understand what resource types are available, and what values to use in your files. The Azure resource reference documentation provides these values. The syntax is shown for Bicep, ARM template JSON, and Terraform AzAPI provider.
Choose language
Select the deployment language you wish to use for viewing the resource reference. The options are available at the top of each article.

Bicep
For an introduction to working with Bicep files, see Quickstart: Create Bicep files with Visual Studio Code. To learn about the sections of a Bicep file, see Understand the structure and syntax of Bicep files.
To learn about Bicep files through a guided set of Learn modules, see Deploy and manage resources in Azure by using Bicep.
Microsoft recommends that you use VS Code to create Bicep files. For more information, see Install Bicep tools.
ARM templates
Tip
Bicep is a new language that offers the same capabilities as ARM templates but with a syntax that's easier to use. If you're deciding between the two languages, we recommend Bicep.
To learn about the sections of an ARM template, see Understand the structure and syntax of ARM templates. For an introduction to working with templates, see Tutorial: Create and deploy your first ARM template.
Microsoft recommends that you use VS Code to create ARM templates. When you add the Azure Resource Managed tools extension, you get intellisense for the template properties. For more information, see Quickstart: Create ARM templates with Visual Studio Code.
Terraform AzAPI provider
To learn about the Terraform AzAPI provider, see Overview of the Terraform AzAPI provider.
For an introduction to creating a configuration file for the Terraform AzAPI provider, see Quickstart: Deploy your first Azure resource with the AzAPI Terraform provider.
Find resources
If you know the resource type, you can go directly to it with the following URL format: https://learn.microsoft.com/azure/templates/{provider-namespace}/{resource-type}. For example, the SQL database reference content is available at: https://learn.microsoft.com/azure/templates/microsoft.sql/servers/databases.
The resource types are located under the Reference node. Expand the resource provider that contains the type you are looking for. The following image shows the types for Storage.

Or, you can filter the resource types in navigation pane:

See changes in versions
Each resource provider contains a list of changes for each API version. You can locate the change log in the left navigation pane.





Feedback
Was this page helpful?
Yes No


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 4>

————————————————————————

<doc 5>

Skip to main content





Table of contents Exit focus mode



Table of contents Add

Share via
Facebook x.com LinkedIn Email

Print
Microsoft.Sql servers/databases
	•	2024-12-09
In this article
	•	Latest
	•	2024-05-01-preview
	•	2023-08-01
	•	2023-08-01-preview
	•	2023-05-01-preview
	•	2023-02-01-preview
	•	2022-11-01-preview
	•	2022-08-01-preview
	•	2022-05-01-preview
	•	2022-02-01-preview
	•	2021-11-01
	•	2021-11-01-preview
	•	2021-08-01-preview
	•	2021-05-01-preview
	•	2021-02-01-preview
	•	2020-11-01-preview
	•	2020-08-01-preview
	•	2020-02-02-preview
	•	2019-06-01-preview
	•	2017-10-01-preview
	•	2017-03-01-preview
	•	2014-04-01
Bicep resource definition
The servers/databases resource type can be deployed with operations that target:
	•	Resource groups - See resource group deployment commands
For a list of changed properties in each API version, see change log.
Resource format
To create a Microsoft.Sql/servers/databases resource, add the following Bicep to your template.
resource symbolicname 'Microsoft.Sql/servers/databases@2024-05-01-preview' = {
 parent: resourceSymbolicName
 identity: {
  type: 'string'
  userAssignedIdentities: {
   {customized property}: {}
  }
 }
 location: 'string'
 name: 'string'
 properties: {
  autoPauseDelay: int
  availabilityZone: 'string'
  catalogCollation: 'string'
  collation: 'string'
  createMode: 'string'
  elasticPoolId: 'string'
  encryptionProtector: 'string'
  encryptionProtectorAutoRotation: bool
  federatedClientId: 'string'
  freeLimitExhaustionBehavior: 'string'
  highAvailabilityReplicaCount: int
  isLedgerOn: bool
  keys: {
   {customized property}: {}
  }
  licenseType: 'string'
  longTermRetentionBackupResourceId: 'string'
  maintenanceConfigurationId: 'string'
  manualCutover: bool
  maxSizeBytes: int
  minCapacity: int
  performCutover: bool
  preferredEnclaveType: 'string'
  readScale: 'string'
  recoverableDatabaseId: 'string'
  recoveryServicesRecoveryPointId: 'string'
  requestedBackupStorageRedundancy: 'string'
  restorableDroppedDatabaseId: 'string'
  restorePointInTime: 'string'
  sampleName: 'string'
  secondaryType: 'string'
  sourceDatabaseDeletionDate: 'string'
  sourceDatabaseId: 'string'
  sourceResourceId: 'string'
  useFreeLimit: bool
  zoneRedundant: bool
 }
 sku: {
  capacity: int
  family: 'string'
  name: 'string'
  size: 'string'
  tier: 'string'
 }
 tags: {
  {customized property}: 'string'
 }
}
Property Values
Microsoft.Sql/servers/databases
Name
Description
Value
identity
The Azure Active Directory identity of the database.
DatabaseIdentity
location
Resource location.
string (required)
name
The resource name
string (required)
parent
In Bicep, you can specify the parent resource for a child resource. You only need to add this property when the child resource is declared outside of the parent resource.

For more information, see Child resource outside parent resource.
Symbolic name for resource of type: servers
properties
Resource properties.
DatabaseProperties
sku
The database SKU.

The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the Capabilities_ListByLocation REST API or one of the following commands:

azurecli<br />az sql db list-editions -l &lt;location&gt; -o table<br />````<br /><br />powershell
Get-AzSqlServerServiceObjective -Location <location>
````
Sku
tags
Resource tags
Dictionary of tag names and values. See Tags in templates
DatabaseIdentity
Name
Description
Value
type
The identity type
'None'
'UserAssigned'
userAssignedIdentities
The resource ids of the user assigned identities to use
DatabaseIdentityUserAssignedIdentities
DatabaseIdentityUserAssignedIdentities
Name
Description
Value
DatabaseKey
Name
Description
Value
DatabaseProperties
Name
Description
Value
autoPauseDelay
Time in minutes after which database is automatically paused. A value of -1 means that automatic pause is disabled
int
availabilityZone
Specifies the availability zone the database is pinned to.
'1'
'2'
'3'
'NoPreference'
catalogCollation
Collation of the metadata catalog.
'DATABASE_DEFAULT'
'SQL_Latin1_General_CP1_CI_AS'
collation
The collation of the database.
string
createMode
Specifies the mode of database creation.

Default: regular database creation.

Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.

Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.

PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.

Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.

Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.

RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.

Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
'Copy'
'Default'
'OnlineSecondary'
'PointInTimeRestore'
'Recovery'
'Restore'
'RestoreExternalBackup'
'RestoreExternalBackupSecondary'
'RestoreLongTermRetentionBackup'
'Secondary'
elasticPoolId
The resource identifier of the elastic pool containing this database.
string
encryptionProtector
The azure key vault URI of the database if it's configured with per Database Customer Managed Keys.
string
encryptionProtectorAutoRotation
The flag to enable or disable auto rotation of database encryption protector AKV key.
bool
federatedClientId
The Client id used for cross tenant per database CMK scenario
string 

Constraints:
Min length = 36
Max length = 36
Pattern = ^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$
freeLimitExhaustionBehavior
Specifies the behavior when monthly free limits are exhausted for the free database.

AutoPause: The database will be auto paused upon exhaustion of free limits for remainder of the month.

BillForUsage: The database will continue to be online upon exhaustion of free limits and any overage will be billed.
'AutoPause'
'BillOverUsage'
highAvailabilityReplicaCount
The number of secondary replicas associated with the Business Critical, Premium, or Hyperscale edition database that are used to provide high availability. Not applicable to a Hyperscale database within an elastic pool.
int
isLedgerOn
Whether or not this database is a ledger database, which means all tables in the database are ledger tables. Note: the value of this property cannot be changed after the database has been created.
bool
keys
The resource ids of the user assigned identities to use
DatabasePropertiesKeys
licenseType
The license type to apply for this database. LicenseIncluded if you need a license, or BasePrice if you have a license and are eligible for the Azure Hybrid Benefit.
'BasePrice'
'LicenseIncluded'
longTermRetentionBackupResourceId
The resource identifier of the long term retention backup associated with create operation of this database.
string
maintenanceConfigurationId
Maintenance configuration id assigned to the database. This configuration defines the period when the maintenance updates will occur.
string
manualCutover
Whether or not customer controlled manual cutover needs to be done during Update Database operation to Hyperscale tier.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier.

When manualCutover is specified, the scaling operation will wait for user input to trigger cutover to Hyperscale database.

To trigger cutover, please provide 'performCutover' parameter when the Scaling operation is in Waiting state.
bool
maxSizeBytes
The max size of the database expressed in bytes.
int
minCapacity
Minimal capacity that database will always have allocated, if not paused
int
performCutover
To trigger customer controlled manual cutover during the wait state while Scaling operation is in progress.

This property parameter is only applicable for scaling operations that are initiated along with 'manualCutover' parameter.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier is already in progress.

When performCutover is specified, the scaling operation will trigger cutover and perform role-change to Hyperscale database.
bool
preferredEnclaveType
Type of enclave requested on the database i.e. Default or VBS enclaves.
'Default'
'VBS'
readScale
The state of read-only routing. If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale database within an elastic pool.
'Disabled'
'Enabled'
recoverableDatabaseId
The resource identifier of the recoverable database associated with create operation of this database.
string
recoveryServicesRecoveryPointId
The resource identifier of the recovery point associated with create operation of this database.
string
requestedBackupStorageRedundancy
The storage account type to be used to store backups for this database.
'Geo'
'GeoZone'
'Local'
'Zone'
restorableDroppedDatabaseId
The resource identifier of the restorable dropped database associated with create operation of this database.
string
restorePointInTime
Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
string
sampleName
The name of the sample schema to apply when creating this database.
'AdventureWorksLT'
'WideWorldImportersFull'
'WideWorldImportersStd'
secondaryType
The secondary type of the database if it is a secondary. Valid values are Geo, Named and Standby.
'Geo'
'Named'
'Standby'
sourceDatabaseDeletionDate
Specifies the time that the database was deleted.
string
sourceDatabaseId
The resource identifier of the source database associated with create operation of this database.
string
sourceResourceId
The resource identifier of the source associated with the create operation of this database.

This property is only supported for DataWarehouse edition and allows to restore across subscriptions.

When sourceResourceId is specified, sourceDatabaseId, recoverableDatabaseId, restorableDroppedDatabaseId and sourceDatabaseDeletionDate must not be specified and CreateMode must be PointInTimeRestore, Restore or Recover.

When createMode is PointInTimeRestore, sourceResourceId must be the resource ID of the existing database or existing sql pool, and restorePointInTime must be specified.

When createMode is Restore, sourceResourceId must be the resource ID of restorable dropped database or restorable dropped sql pool.

When createMode is Recover, sourceResourceId must be the resource ID of recoverable database or recoverable sql pool.

When source subscription belongs to a different tenant than target subscription, “x-ms-authorization-auxiliary” header must contain authentication token for the source tenant. For more details about “x-ms-authorization-auxiliary” header see /azure/azure-resource-manager/management/authenticate-multi-tenant
string
useFreeLimit
Whether or not the database uses free monthly limits. Allowed on one database in a subscription.
bool
zoneRedundant
Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
bool
DatabasePropertiesKeys
Name
Description
Value
DatabaseUserIdentity
Name
Description
Value
Sku
Name
Description
Value
capacity
Capacity of the particular SKU.
int
family
If the service has different generations of hardware, for the same SKU, then that can be captured here.
string
name
The name of the SKU, typically, a letter + Number code, e.g. P3.
string (required)
size
Size of the particular SKU
string
tier
The tier or edition of the particular SKU, e.g. Basic, Premium.
string
TrackedResourceTags
Name
Description
Value
Usage Examples
Azure Quickstart Samples
The following Azure Quickstart templates contain Bicep samples for deploying this resource type.
Bicep File
Description
Azure SQL Server with Auditing written to Log Analytics
This template allows you to deploy an Azure SQL server with Auditing enabled to write audit logs to Log Analytics (OMS workspace)
Create a SQL Server and Database
This template allows you to create SQL Database and Server.
Dedicated SQL pool with Transparent Encryption
Creates a SQL Server and a Dedicated SQL pool (formerly SQL DW) with Transparent Data Encryption.
Deploy the Sports Analytics on Azure Architecture
Creates an Azure storage account with ADLS Gen 2 enabled, an Azure Data Factory instance with linked services for the storage account (an the Azure SQL Database if deployed), and an Azure Databricks instance. The AAD identity for the user deploying the template and the managed identity for the ADF instance will be granted the Storage Blob Data Contributor role on the storage account. There are also options to deploy an Azure Key Vault instance, an Azure SQL Database, and an Azure Event Hub (for streaming use cases). When an Azure Key Vault is deployed, the data factory managed identity and the AAD identity for the user deploying the template will be granted the Key Vault Secrets User role.
Private Endpoint example
This template shows how to create a private endpoint pointing to Azure SQL Server
Provision a Web App with a SQL Database
This template provisions a Web App, a SQL Database, AutoScale settings, Alert rules, and App Insights. It configures a connection string in the web app for the database.
Sonarqube Docker Web App on Linux with Azure SQL
This template deploys Sonarqube in an Azure App Service web app Linux container using the official Sonarqube image and backed by an Azure SQL Server.
Web App with Managed Identity, SQL Server and ΑΙ
Simple example to deploy Azure infrastructure for app + data + managed identity + monitoring
ARM template resource definition
The servers/databases resource type can be deployed with operations that target:
	•	Resource groups - See resource group deployment commands
For a list of changed properties in each API version, see change log.
Resource format
To create a Microsoft.Sql/servers/databases resource, add the following JSON to your template.
{
 "type": "Microsoft.Sql/servers/databases",
 "apiVersion": "2024-05-01-preview",
 "name": "string",
 "identity": {
  "type": "string",
  "userAssignedIdentities": {
   "{customized property}": {
   }
  }
 },
 "location": "string",
 "properties": {
  "autoPauseDelay": "int",
  "availabilityZone": "string",
  "catalogCollation": "string",
  "collation": "string",
  "createMode": "string",
  "elasticPoolId": "string",
  "encryptionProtector": "string",
  "encryptionProtectorAutoRotation": "bool",
  "federatedClientId": "string",
  "freeLimitExhaustionBehavior": "string",
  "highAvailabilityReplicaCount": "int",
  "isLedgerOn": "bool",
  "keys": {
   "{customized property}": {
   }
  },
  "licenseType": "string",
  "longTermRetentionBackupResourceId": "string",
  "maintenanceConfigurationId": "string",
  "manualCutover": "bool",
  "maxSizeBytes": "int",
  "minCapacity": "int",
  "performCutover": "bool",
  "preferredEnclaveType": "string",
  "readScale": "string",
  "recoverableDatabaseId": "string",
  "recoveryServicesRecoveryPointId": "string",
  "requestedBackupStorageRedundancy": "string",
  "restorableDroppedDatabaseId": "string",
  "restorePointInTime": "string",
  "sampleName": "string",
  "secondaryType": "string",
  "sourceDatabaseDeletionDate": "string",
  "sourceDatabaseId": "string",
  "sourceResourceId": "string",
  "useFreeLimit": "bool",
  "zoneRedundant": "bool"
 },
 "sku": {
  "capacity": "int",
  "family": "string",
  "name": "string",
  "size": "string",
  "tier": "string"
 },
 "tags": {
  "{customized property}": "string"
 }
}
Property Values
Microsoft.Sql/servers/databases
Name
Description
Value
apiVersion
The api version
'2024-05-01-preview'
identity
The Azure Active Directory identity of the database.
DatabaseIdentity
location
Resource location.
string (required)
name
The resource name
string (required)
properties
Resource properties.
DatabaseProperties
sku
The database SKU.

The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the Capabilities_ListByLocation REST API or one of the following commands:

azurecli<br />az sql db list-editions -l &lt;location&gt; -o table<br />````<br /><br />powershell
Get-AzSqlServerServiceObjective -Location <location>
````
Sku
tags
Resource tags
Dictionary of tag names and values. See Tags in templates
type
The resource type
'Microsoft.Sql/servers/databases'
DatabaseIdentity
Name
Description
Value
type
The identity type
'None'
'UserAssigned'
userAssignedIdentities
The resource ids of the user assigned identities to use
DatabaseIdentityUserAssignedIdentities
DatabaseIdentityUserAssignedIdentities
Name
Description
Value
DatabaseKey
Name
Description
Value
DatabaseProperties
Name
Description
Value
autoPauseDelay
Time in minutes after which database is automatically paused. A value of -1 means that automatic pause is disabled
int
availabilityZone
Specifies the availability zone the database is pinned to.
'1'
'2'
'3'
'NoPreference'
catalogCollation
Collation of the metadata catalog.
'DATABASE_DEFAULT'
'SQL_Latin1_General_CP1_CI_AS'
collation
The collation of the database.
string
createMode
Specifies the mode of database creation.

Default: regular database creation.

Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.

Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.

PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.

Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.

Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.

RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.

Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
'Copy'
'Default'
'OnlineSecondary'
'PointInTimeRestore'
'Recovery'
'Restore'
'RestoreExternalBackup'
'RestoreExternalBackupSecondary'
'RestoreLongTermRetentionBackup'
'Secondary'
elasticPoolId
The resource identifier of the elastic pool containing this database.
string
encryptionProtector
The azure key vault URI of the database if it's configured with per Database Customer Managed Keys.
string
encryptionProtectorAutoRotation
The flag to enable or disable auto rotation of database encryption protector AKV key.
bool
federatedClientId
The Client id used for cross tenant per database CMK scenario
string 

Constraints:
Min length = 36
Max length = 36
Pattern = ^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$
freeLimitExhaustionBehavior
Specifies the behavior when monthly free limits are exhausted for the free database.

AutoPause: The database will be auto paused upon exhaustion of free limits for remainder of the month.

BillForUsage: The database will continue to be online upon exhaustion of free limits and any overage will be billed.
'AutoPause'
'BillOverUsage'
highAvailabilityReplicaCount
The number of secondary replicas associated with the Business Critical, Premium, or Hyperscale edition database that are used to provide high availability. Not applicable to a Hyperscale database within an elastic pool.
int
isLedgerOn
Whether or not this database is a ledger database, which means all tables in the database are ledger tables. Note: the value of this property cannot be changed after the database has been created.
bool
keys
The resource ids of the user assigned identities to use
DatabasePropertiesKeys
licenseType
The license type to apply for this database. LicenseIncluded if you need a license, or BasePrice if you have a license and are eligible for the Azure Hybrid Benefit.
'BasePrice'
'LicenseIncluded'
longTermRetentionBackupResourceId
The resource identifier of the long term retention backup associated with create operation of this database.
string
maintenanceConfigurationId
Maintenance configuration id assigned to the database. This configuration defines the period when the maintenance updates will occur.
string
manualCutover
Whether or not customer controlled manual cutover needs to be done during Update Database operation to Hyperscale tier.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier.

When manualCutover is specified, the scaling operation will wait for user input to trigger cutover to Hyperscale database.

To trigger cutover, please provide 'performCutover' parameter when the Scaling operation is in Waiting state.
bool
maxSizeBytes
The max size of the database expressed in bytes.
int
minCapacity
Minimal capacity that database will always have allocated, if not paused
int
performCutover
To trigger customer controlled manual cutover during the wait state while Scaling operation is in progress.

This property parameter is only applicable for scaling operations that are initiated along with 'manualCutover' parameter.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier is already in progress.

When performCutover is specified, the scaling operation will trigger cutover and perform role-change to Hyperscale database.
bool
preferredEnclaveType
Type of enclave requested on the database i.e. Default or VBS enclaves.
'Default'
'VBS'
readScale
The state of read-only routing. If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale database within an elastic pool.
'Disabled'
'Enabled'
recoverableDatabaseId
The resource identifier of the recoverable database associated with create operation of this database.
string
recoveryServicesRecoveryPointId
The resource identifier of the recovery point associated with create operation of this database.
string
requestedBackupStorageRedundancy
The storage account type to be used to store backups for this database.
'Geo'
'GeoZone'
'Local'
'Zone'
restorableDroppedDatabaseId
The resource identifier of the restorable dropped database associated with create operation of this database.
string
restorePointInTime
Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
string
sampleName
The name of the sample schema to apply when creating this database.
'AdventureWorksLT'
'WideWorldImportersFull'
'WideWorldImportersStd'
secondaryType
The secondary type of the database if it is a secondary. Valid values are Geo, Named and Standby.
'Geo'
'Named'
'Standby'
sourceDatabaseDeletionDate
Specifies the time that the database was deleted.
string
sourceDatabaseId
The resource identifier of the source database associated with create operation of this database.
string
sourceResourceId
The resource identifier of the source associated with the create operation of this database.

This property is only supported for DataWarehouse edition and allows to restore across subscriptions.

When sourceResourceId is specified, sourceDatabaseId, recoverableDatabaseId, restorableDroppedDatabaseId and sourceDatabaseDeletionDate must not be specified and CreateMode must be PointInTimeRestore, Restore or Recover.

When createMode is PointInTimeRestore, sourceResourceId must be the resource ID of the existing database or existing sql pool, and restorePointInTime must be specified.

When createMode is Restore, sourceResourceId must be the resource ID of restorable dropped database or restorable dropped sql pool.

When createMode is Recover, sourceResourceId must be the resource ID of recoverable database or recoverable sql pool.

When source subscription belongs to a different tenant than target subscription, “x-ms-authorization-auxiliary” header must contain authentication token for the source tenant. For more details about “x-ms-authorization-auxiliary” header see /azure/azure-resource-manager/management/authenticate-multi-tenant
string
useFreeLimit
Whether or not the database uses free monthly limits. Allowed on one database in a subscription.
bool
zoneRedundant
Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
bool
DatabasePropertiesKeys
Name
Description
Value
DatabaseUserIdentity
Name
Description
Value
Sku
Name
Description
Value
capacity
Capacity of the particular SKU.
int
family
If the service has different generations of hardware, for the same SKU, then that can be captured here.
string
name
The name of the SKU, typically, a letter + Number code, e.g. P3.
string (required)
size
Size of the particular SKU
string
tier
The tier or edition of the particular SKU, e.g. Basic, Premium.
string
TrackedResourceTags
Name
Description
Value
Usage Examples
Azure Quickstart Templates
The following Azure Quickstart templates deploy this resource type.
Template
Description
Azure SQL Server with Auditing written to Log Analytics

This template allows you to deploy an Azure SQL server with Auditing enabled to write audit logs to Log Analytics (OMS workspace)
Create a SQL Server and Database

This template allows you to create SQL Database and Server.
Dedicated SQL pool with Transparent Encryption

Creates a SQL Server and a Dedicated SQL pool (formerly SQL DW) with Transparent Data Encryption.
Deploy a new SQL Elastic Pool

This template allows you to deploy a new SQL Elastic Pool with its new associated SQL Server and new SQL Databases to assign to it.
Deploy the Sports Analytics on Azure Architecture

Creates an Azure storage account with ADLS Gen 2 enabled, an Azure Data Factory instance with linked services for the storage account (an the Azure SQL Database if deployed), and an Azure Databricks instance. The AAD identity for the user deploying the template and the managed identity for the ADF instance will be granted the Storage Blob Data Contributor role on the storage account. There are also options to deploy an Azure Key Vault instance, an Azure SQL Database, and an Azure Event Hub (for streaming use cases). When an Azure Key Vault is deployed, the data factory managed identity and the AAD identity for the user deploying the template will be granted the Key Vault Secrets User role.
HDInsight with custom Ambari + Hive Metastore DB in VNET

This template allows you to create an HDInsight cluster in an existing virtual network with a new SQL DB that serves as both a custom Ambari DB and Hive Metastore. You must have an existing SQL Sever, storage account, and VNET.
Private Endpoint example

This template shows how to create a private endpoint pointing to Azure SQL Server
Provision a Web App with a SQL Database

This template provisions a Web App, a SQL Database, AutoScale settings, Alert rules, and App Insights. It configures a connection string in the web app for the database.
Remote Desktop Services with High Availability

This ARM Template sample code will deploy a Remote Desktop Services 2019 Session Collection lab with high availability. The goal is to deploy a fully redundant, highly available solution for Remote Desktop Services, using Windows Server 2019.
Sonarqube Docker Web App on Linux with Azure SQL

This template deploys Sonarqube in an Azure App Service web app Linux container using the official Sonarqube image and backed by an Azure SQL Server.
Web App with Managed Identity, SQL Server and ΑΙ

Simple example to deploy Azure infrastructure for app + data + managed identity + monitoring
WebApp consuming a Azure SQL Private Endpoint

This template shows how to create a Web app that consumes a private endpoint pointing to Azure SQL Server
Terraform (AzAPI provider) resource definition
The servers/databases resource type can be deployed with operations that target:
	•	Resource groups
For a list of changed properties in each API version, see change log.
Resource format
To create a Microsoft.Sql/servers/databases resource, add the following Terraform to your template.
resource "azapi_resource" "symbolicname" {
 type = "Microsoft.Sql/servers/databases@2024-05-01-preview"
 name = "string"
 parent_id = "string"
 identity {
  type = "string"
  identity_ids = [
   "string"
  ]
 }
 location = "string"
 tags = {
  {customized property} = "string"
 }
 body = {
  properties = {
   autoPauseDelay = int
   availabilityZone = "string"
   catalogCollation = "string"
   collation = "string"
   createMode = "string"
   elasticPoolId = "string"
   encryptionProtector = "string"
   encryptionProtectorAutoRotation = bool
   federatedClientId = "string"
   freeLimitExhaustionBehavior = "string"
   highAvailabilityReplicaCount = int
   isLedgerOn = bool
   keys = {
    {customized property} = {
    }
   }
   licenseType = "string"
   longTermRetentionBackupResourceId = "string"
   maintenanceConfigurationId = "string"
   manualCutover = bool
   maxSizeBytes = int
   minCapacity = int
   performCutover = bool
   preferredEnclaveType = "string"
   readScale = "string"
   recoverableDatabaseId = "string"
   recoveryServicesRecoveryPointId = "string"
   requestedBackupStorageRedundancy = "string"
   restorableDroppedDatabaseId = "string"
   restorePointInTime = "string"
   sampleName = "string"
   secondaryType = "string"
   sourceDatabaseDeletionDate = "string"
   sourceDatabaseId = "string"
   sourceResourceId = "string"
   useFreeLimit = bool
   zoneRedundant = bool
  }
  sku = {
   capacity = int
   family = "string"
   name = "string"
   size = "string"
   tier = "string"
  }
 }
}
Property Values
Microsoft.Sql/servers/databases
Name
Description
Value
identity
The Azure Active Directory identity of the database.
DatabaseIdentity
location
Resource location.
string (required)
name
The resource name
string (required)
parent_id
The ID of the resource that is the parent for this resource.
ID for resource of type: servers
properties
Resource properties.
DatabaseProperties
sku
The database SKU.

The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the Capabilities_ListByLocation REST API or one of the following commands:

azurecli<br />az sql db list-editions -l &lt;location&gt; -o table<br />````<br /><br />powershell
Get-AzSqlServerServiceObjective -Location <location>
````
Sku
tags
Resource tags
Dictionary of tag names and values.
type
The resource type
"Microsoft.Sql/servers/databases@2024-05-01-preview"
DatabaseIdentity
Name
Description
Value
type
The identity type
'None'
'UserAssigned'
userAssignedIdentities
The resource ids of the user assigned identities to use
DatabaseIdentityUserAssignedIdentities
DatabaseIdentityUserAssignedIdentities
Name
Description
Value
DatabaseKey
Name
Description
Value
DatabaseProperties
Name
Description
Value
autoPauseDelay
Time in minutes after which database is automatically paused. A value of -1 means that automatic pause is disabled
int
availabilityZone
Specifies the availability zone the database is pinned to.
'1'
'2'
'3'
'NoPreference'
catalogCollation
Collation of the metadata catalog.
'DATABASE_DEFAULT'
'SQL_Latin1_General_CP1_CI_AS'
collation
The collation of the database.
string
createMode
Specifies the mode of database creation.

Default: regular database creation.

Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.

Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.

PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.

Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.

Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.

RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.

Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
'Copy'
'Default'
'OnlineSecondary'
'PointInTimeRestore'
'Recovery'
'Restore'
'RestoreExternalBackup'
'RestoreExternalBackupSecondary'
'RestoreLongTermRetentionBackup'
'Secondary'
elasticPoolId
The resource identifier of the elastic pool containing this database.
string
encryptionProtector
The azure key vault URI of the database if it's configured with per Database Customer Managed Keys.
string
encryptionProtectorAutoRotation
The flag to enable or disable auto rotation of database encryption protector AKV key.
bool
federatedClientId
The Client id used for cross tenant per database CMK scenario
string 

Constraints:
Min length = 36
Max length = 36
Pattern = ^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$
freeLimitExhaustionBehavior
Specifies the behavior when monthly free limits are exhausted for the free database.

AutoPause: The database will be auto paused upon exhaustion of free limits for remainder of the month.

BillForUsage: The database will continue to be online upon exhaustion of free limits and any overage will be billed.
'AutoPause'
'BillOverUsage'
highAvailabilityReplicaCount
The number of secondary replicas associated with the Business Critical, Premium, or Hyperscale edition database that are used to provide high availability. Not applicable to a Hyperscale database within an elastic pool.
int
isLedgerOn
Whether or not this database is a ledger database, which means all tables in the database are ledger tables. Note: the value of this property cannot be changed after the database has been created.
bool
keys
The resource ids of the user assigned identities to use
DatabasePropertiesKeys
licenseType
The license type to apply for this database. LicenseIncluded if you need a license, or BasePrice if you have a license and are eligible for the Azure Hybrid Benefit.
'BasePrice'
'LicenseIncluded'
longTermRetentionBackupResourceId
The resource identifier of the long term retention backup associated with create operation of this database.
string
maintenanceConfigurationId
Maintenance configuration id assigned to the database. This configuration defines the period when the maintenance updates will occur.
string
manualCutover
Whether or not customer controlled manual cutover needs to be done during Update Database operation to Hyperscale tier.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier.

When manualCutover is specified, the scaling operation will wait for user input to trigger cutover to Hyperscale database.

To trigger cutover, please provide 'performCutover' parameter when the Scaling operation is in Waiting state.
bool
maxSizeBytes
The max size of the database expressed in bytes.
int
minCapacity
Minimal capacity that database will always have allocated, if not paused
int
performCutover
To trigger customer controlled manual cutover during the wait state while Scaling operation is in progress.

This property parameter is only applicable for scaling operations that are initiated along with 'manualCutover' parameter.

This property is only applicable when scaling database from Business Critical/General Purpose/Premium/Standard tier to Hyperscale tier is already in progress.

When performCutover is specified, the scaling operation will trigger cutover and perform role-change to Hyperscale database.
bool
preferredEnclaveType
Type of enclave requested on the database i.e. Default or VBS enclaves.
'Default'
'VBS'
readScale
The state of read-only routing. If enabled, connections that have application intent set to readonly in their connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale database within an elastic pool.
'Disabled'
'Enabled'
recoverableDatabaseId
The resource identifier of the recoverable database associated with create operation of this database.
string
recoveryServicesRecoveryPointId
The resource identifier of the recovery point associated with create operation of this database.
string
requestedBackupStorageRedundancy
The storage account type to be used to store backups for this database.
'Geo'
'GeoZone'
'Local'
'Zone'
restorableDroppedDatabaseId
The resource identifier of the restorable dropped database associated with create operation of this database.
string
restorePointInTime
Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
string
sampleName
The name of the sample schema to apply when creating this database.
'AdventureWorksLT'
'WideWorldImportersFull'
'WideWorldImportersStd'
secondaryType
The secondary type of the database if it is a secondary. Valid values are Geo, Named and Standby.
'Geo'
'Named'
'Standby'
sourceDatabaseDeletionDate
Specifies the time that the database was deleted.
string
sourceDatabaseId
The resource identifier of the source database associated with create operation of this database.
string
sourceResourceId
The resource identifier of the source associated with the create operation of this database.

This property is only supported for DataWarehouse edition and allows to restore across subscriptions.

When sourceResourceId is specified, sourceDatabaseId, recoverableDatabaseId, restorableDroppedDatabaseId and sourceDatabaseDeletionDate must not be specified and CreateMode must be PointInTimeRestore, Restore or Recover.

When createMode is PointInTimeRestore, sourceResourceId must be the resource ID of the existing database or existing sql pool, and restorePointInTime must be specified.

When createMode is Restore, sourceResourceId must be the resource ID of restorable dropped database or restorable dropped sql pool.

When createMode is Recover, sourceResourceId must be the resource ID of recoverable database or recoverable sql pool.

When source subscription belongs to a different tenant than target subscription, “x-ms-authorization-auxiliary” header must contain authentication token for the source tenant. For more details about “x-ms-authorization-auxiliary” header see /azure/azure-resource-manager/management/authenticate-multi-tenant
string
useFreeLimit
Whether or not the database uses free monthly limits. Allowed on one database in a subscription.
bool
zoneRedundant
Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
bool
DatabasePropertiesKeys
Name
Description
Value
DatabaseUserIdentity
Name
Description
Value
Sku
Name
Description
Value
capacity
Capacity of the particular SKU.
int
family
If the service has different generations of hardware, for the same SKU, then that can be captured here.
string
name
The name of the SKU, typically, a letter + Number code, e.g. P3.
string (required)
size
Size of the particular SKU
string
tier
The tier or edition of the particular SKU, e.g. Basic, Premium.
string
TrackedResourceTags
Name
Description
Value




Feedback
Was this page helpful?
Yes No


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 5>

————————————————————————

<doc 6>

Skip to main content







Add
	•	
Achievements
Introduction
Completed
	•	1 minute
Infrastructure as code, sometimes referred to as IaC, is a way to provision infrastructure resources that's similar to how software is deployed. These resources include virtual machines, virtual networks, and web applications. Infrastructure as code can help automate your deployments, increase confidence in your deployments, and increase efficiency and repeatability.
Example scenario
Suppose you work as an Azure infrastructure administrator at a toy company that's experiencing significant growth in the global market. As a result, your infrastructure needs to scale with the company's growth, including:
	•	Deployments of new applications for internal teams and customers.
	•	Multiple region deployments to support your customers and partners around the world.
	•	Multiple environment deployments to ensure consistency.
You're asked to evaluate whether infrastructure as code might be a valuable approach to resource provisioning at your company. You also need to decide which technology to use when you deploy your Azure infrastructure.
What are we doing?
In this module, you learn about the concept of infrastructure as code and its benefits. You also learn the purpose of Bicep as an infrastructure-as-code language and understand how it works. This module helps you find answers to these questions:
	•	What is infrastructure as code?
	•	How can infrastructure as code help you automate resource provisioning?
	•	What is Bicep and how does it work?
	•	When should you use Bicep instead of other tooling options?
What is the main goal?
After completing this module, you're able to determine whether infrastructure as code is the right approach and tool for your organization.
Prerequisites
You should be familiar with:
	•	Basic cloud computing concepts and terminology.
	•	Different types of cloud resources.


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 6>

————————————————————————

<doc 7>

Skip to main content







Add
	•	
Achievements
What is infrastructure as code?
Completed
	•	10 minutes
You're asked to evaluate whether infrastructure as code might be a valuable approach to resource provisioning at your company. You're reviewing the available options for deployment, including:
	•	Azure portal
	•	Azure CLI
	•	Azure PowerShell
	•	Azure Resource Manager templates (JSON and Bicep)
You're looking for a repeatable option, and you need to decide which technology to use to deploy your Azure infrastructure.
In this unit, you learn how and why infrastructure as code can help you deploy your Azure infrastructure in an automated and repeatable way.
Azure CLI commands are used to illustrate concepts. You learn more about using commands to deploy resources in other modules of the Bicep learning path.
Defining infrastructure as code
Your company designs new toys for release to the market, and most new toys require some assembly after purchase. The company's design team creates instruction manuals to include with each toy. Each manual provides details about how to properly assemble the toy.
You can think of infrastructure as code as being like the instruction manual for your infrastructure. The manual details the end configuration of your resources and how to reach that configuration state.
Infrastructure as code is the process of automating your infrastructure provisioning. It uses a descriptive coding language and versioning system that's similar to what's used for source code. When you create an application, your source code generates the same result each time you compile it. In a similar manner, infrastructure-as-code deployments are automated, consistent, and repeatable. Infrastructure as code can automate the deployments of your infrastructure resources, like virtual networks, virtual machines, applications, and storage.

If you recall the instruction manual for the new toy, there are multiple ways to write the instruction manual. One option is to detail each step of the build process. Another option is to show an exploded view of the pieces and parts needed to assemble the toy. Later in this unit, you learn about the differences between imperative and declarative code and how they relate to your company's instruction manuals.
Why use infrastructure as code?
Adopting an infrastructure as code approach offers many benefits to resource provisioning. With infrastructure as code, you can:
	•	Increase confidence in your deployments.
	•	Manage multiple environments.
	•	Better understand your cloud resources.
Increase confidence
One of the benefits of using infrastructure as code is the level of confidence you gain in your deployments from improvements in consistency and security.
	•	Integration with current processes: If your organization already uses standard software development practices, you can adopt those same processes for your infrastructure deployments. For example, peer reviews can help in detecting problems in configurations that might be difficult to detect when making manual changes.
	•	Consistency: Adopting an infrastructure as code approach helps your team follow well-established processes to deploy infrastructure. By following these processes, responsibility shifts from a small group of individuals to your automation process and tooling. Infrastructure as code helps reduce human error in resource provisioning and ensure consistent deployments.
	•	Automated scanning: You can scan Infrastructure-as-code configurations with automated tooling that can check for errors in the code. Automated tooling can also review proposed changes to ensure that security and performance practices are followed.
	•	Secret management: Many solutions require secrets, like connection strings, encryption keys, client secrets, and certificates. In Azure, an Azure Key Vault is the service that's used to securely store these secrets. Many infrastructure-as-code tools can integrate with Key Vault to access these secrets securely at deployment.
	•	Access control: With infrastructure-as-code deployments, you have the option of using managed identities or service accounts to automate resource provisioning. This process ensures that only these identities can modify your cloud resources. It also helps prevent incorrect configurations deployed to production. If necessary, you can override this process by using an emergency access account (often called a break glass account) or by using the Microsoft Entra ID Privileged Identity Management feature.
	•	Avoid configuration drift: Idempotence is a term frequently associated with infrastructure as code. When an operation is idempotent, it means that it provides the same result each time you run it. If you choose tooling that uses idempotent operations, you can avoid configuration drift.
As an example of idempotence, consider the following Azure CLI command. The command creates an Azure resource group named storage-resource-group in the East US region.
az group create \
 --name storage-resource-group \
 --location eastus
If you run this command a second time, you receive the exact same output because this Azure CLI command was designed to be idempotent. You don't receive an error or a duplicate resource group.
When you use infrastructure as code, you can redeploy your environment at each release of your solution. These releases might incorporate small configuration changes or even significant updates. This process helps avoid configuration drift. If an accidental change is made to a resource, it can be corrected by redeploying the configuration. By following this approach, you're documenting your environment by using code.
Manage multiple environments
Many organizations maintain multiple application environments. The developers in your toy company might have multiple versions of application code staged in a repository for release to different environments. The environments might include development, testing, and production. Some organizations maintain multiple production environments for applications that are distributed globally. Other organizations, like independent software vendors (ISVs), maintain multiple tenant environments for their customers.
Here are some of the key ways infrastructure as code can help you manage your environments:
	•	Provision new environments: One of the main benefits of cloud computing is the ability to scale. Infrastructure as code can help you scale to multiple instances of your application. These instances can help during times of increased load, or you can deploy them for users in other areas of the world. This agility also can be beneficial when you test your application, like during penetration testing, load testing, and bug testing. With a well-defined code base, you can dynamically provision these new environments in a consistent manner.
	•	Nonproduction environments: A common problem organizations face is differentiation between production and nonproduction environments. When you manually provision resources in separate environments, it's possible that the end configurations don't match. An example is when you deploy a new feature to a nonproduction environment that differs from the production environment. It's possible that the new feature doesn't work as expected in the production environment because of the differences between the two environments. Using infrastructure as code can help minimize these problems. You can use the same configuration files for each environment but supply different input parameters to create uniqueness.
	•	Disaster recovery: In some situations, infrastructure as code can be used as part of an organization's disaster recovery plan. For example, you might need to re-create your environment in another region because of a service outage. By using infrastructure as code, you can quickly provision a new instance to fail over to instead of manually deploying and reconfiguring everything.
Better understand your cloud resources
Infrastructure as code can help you better understand the state of your cloud resources:
	•	Audit trail: Changes to your infrastructure-as-code configurations are version controlled in the same way as your application source code. These changes are tracked in your tooling, like with Git's version history. This audit trail means that you can review the details of each change, who made the change, and when the change was made.
	•	Documentation: You can use many infrastructure-as-code configurations to add metadata, like comments, which describe the purpose of the code in your configuration. If your organization already follows a code documentation process, consider adopting these same procedures with your infrastructure code.
	•	Unified system: Many times, when a developer is working on a new feature, they must make changes to application code and infrastructure code. When you use a common system, your organization can better understand the relationship between your applications and your infrastructure.
	•	Better understanding of cloud infrastructure: When you use the Azure portal to provision resources, many of the processes are abstracted from view. Infrastructure as code can help provide a better understanding of how Azure works and how to troubleshoot issues that might arise. For example, when you create a virtual machine by using the Azure portal, some created resources are abstracted from view. Managed disks and network interface cards are deployed behind the scenes. When you deploy the same virtual machine by using infrastructure as code, you have complete control over all resources that are created.
Imperative and declarative code
You can write an instruction manual for new toy assembly in different ways. When you automate the deployment of services and infrastructure, you can take two approaches: imperative and declarative.
	•	With imperative code, you execute a sequence of commands, in a specific order, to reach an end configuration. This process defines what the code should accomplish, and it defines how to accomplish the task. The imperative approach is like a step-by-step instruction manual.
	•	With declarative code, you specify only the end configuration. The code doesn't define how to accomplish the task. The declarative approach is like the exploded view instruction manual.
When you choose between using an imperative approach and a declarative approach to resource provisioning, consider the tools that might already be in use in your organization. Also consider which approach might match your own skills.
Imperative code
In Azure, an imperative code approach is accomplished programmatically by using a scripting language like Bash or Azure PowerShell. The scripts execute a series of steps to create, modify, and even remove your resources.
This example shows two Azure CLI commands that create a resource group and a storage account.
#!/usr/bin/env bash
az group create \
 --name storage-resource-group \
 --location eastus

az storage account create \
 --name mystorageaccount \
 --resource-group storage-resource-group \
 --location eastus \
 --sku Standard_LRS \
 --kind StorageV2 \
 --access-tier Hot \
 --https-only true
The first command creates a resource group named storage-resource-group in the East US region. The second command creates a storage account named mystorageaccount in the storage-resource-group resource group that was created in the first command. The second command also configures some properties for the storage account, including the kind of storage account and its access tier.
You can use an imperative approach to fully automate resource provisioning, but the approach has some disadvantages. As your architecture matures, scripts can become complex to manage. Commands could be updated or deprecated, which requires reviews of existing scripts.
Declarative code
In Azure, a declarative code approach is accomplished by using templates. Many types of templates are available to use, including:
	•	JSON
	•	Bicep
	•	Ansible, by RedHat
	•	Terraform, by HashiCorp
Note
This module focuses on using Bicep templates.
Take a look at the following example of a Bicep template that configures a storage account. The configuration of the storage account matches the Azure CLI example.
resource storageAccount 'Microsoft.Storage/storageAccounts@2023-05-01' = {
 name: 'mystorageaccount'
 location: 'eastus'
 sku: {
  name: 'Standard_LRS'
 }
 kind: 'StorageV2'
 properties: {
  accessTier: 'Hot'
  supportsHttpsTrafficOnly: true
 }
}
The resources section defines the storage account configuration. This section contains the name, location, and properties of the storage account, including its SKU and the kind of account.
You might notice that the Bicep template doesn't specify how to deploy the storage account. It specifies only what the storage account needs to look like. The actual steps that are executed behind the scenes to create this storage account or to update it to match the specification are left for Azure to decide.


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 7>

————————————————————————

<doc 8>

Skip to main content







Add
	•	
Achievements
What is Azure Resource Manager?
Completed
	•	7 minutes
You spent some time with your team learning the benefits of infrastructure as code and the different approaches that are available. Your company is growing at a rapid pace and your team knows it's going to deploy a significant number of resources to Azure. As a team, you decided that declarative infrastructure as code is the right approach to resource provisioning. The team doesn't want to maintain scripts that list every deployment step. Before beginning the process of building your first template, you need to understand how Azure Resource Manager works. Investigating the types of templates that are available to use with Azure will help you determine the next steps in your infrastructure-as-code strategy.
In this unit, you learn about Resource Manager and the two types of Resource Manager templates.
Azure Resource Manager concepts
Azure Resource Manager is the service that's used to deploy and manage resources in Azure. You can use Resource Manager to create, update, and delete resources in your Azure subscription. You can interact with Resource Manager by using many tools, including the Azure portal. Resource Manager also provides a series of other features, like access control, auditing, and tagging, to help manage your resources after deployment.
Terminology
As you begin your cloud journey with Resource Manager, it's important to understand some terms and concepts:
	•	Resource: A manageable item that's available on the Azure platform. Virtual networks, virtual machines, storage accounts, web apps, and databases are examples of resources.
	•	Resource group: A logical container that holds related resources for an Azure solution. The resource group includes resources you want to manage as a group. Most Azure resources are contained in a resource group. You decide which resources belong in a resource group based on what makes the most sense for your solution. Note A small number of resources aren't contained in resource groups. These resource types are for specific purposes like managing access control and enforcing policies. You learn more about these resources in a later module. 
	•	Subscription: A logical container and billing boundary for your resources and resource groups. Each Azure resource and resource group is associated with only one subscription.
	•	Management group: A logical container that you use to manage more than one subscription. You can define a hierarchy of management groups, subscriptions, resource groups, and resources to efficiently manage access, policies, and compliance through inheritance.
	•	Azure Resource Manager template (ARM template): A template file that defines one or more resources to deploy to a resource group, subscription, management group, or tenant. You can use the template to deploy the resources in a consistent and repeatable way. There are two types of ARM template files: JSON and Bicep. This module focuses on Bicep.
Benefits
Resource Manager provides many benefits and capabilities related to infrastructure-as-code resource provisioning:
	•	You can deploy, manage, and monitor the resources in your solution as a group instead of individually.
	•	You can redeploy your solution throughout the development lifecycle and have confidence that your resources are deployed in a consistent state.
	•	You can manage your infrastructure through declarative templates instead of by using scripts.
	•	You can specify resource dependencies to ensure that resources are deployed in the correct order.
Operations: Control plane and data plane
You can execute two types of operations in Azure: control plane operations and data plane operations. Use the control plane to manage the resources in your subscription. Use the data plane to access features that are exposed by a resource.
For example, you use a control plane operation to create a virtual machine, but you use a data plane operation to connect to the virtual machine by using Remote Desktop Protocol (RDP).
Control plane
When you send a request from any of the Azure tools, APIs, or Software Development Kits (SDKs), Resource Manager receives, authenticates, and authorizes the request. Then, it sends the request to the Azure resource provider, which takes the requested action. Because all requests are handled through the same API, you see consistent results and capabilities in all the different tools that are available in Azure.
The following image shows the role that Resource Manager plays in handling Azure requests:

All control plane operation requests are sent to a Resource Manager URL. For example, the create or update operation for virtual machines is a control plane operation. Here's the request URL for this operation:
PUT https://management.azure.com/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Compute/virtualMachines/{virtualMachineName}?api-version=2022-08-01
The control plane understands which resources need to be created and which resources already exist. Resource Manager understands the difference between these requests and doesn't create identical resources or delete existing resources, although there are ways to override this behavior.
Data plane
When a data plane operation starts, the requests are sent to a specific endpoint in your Azure subscription. For example, the Detect Language operation in Azure AI services is a data plane operation because the request URL is:
POST https://eastus.api.cognitive.microsoft.com/text/analytics/v2.0/languages
Resource Manager features like access control and locks don't always apply to data plane operations. For example, a user might not have permissions to manage a virtual machine by using the control plane, but the user can sign in to the operating system.
What are ARM templates?
Azure Resource Manager templates are files that define the infrastructure and configuration for your deployment. When you write an ARM template, you take a declarative approach to your resource provisioning. These templates describe each resource in the deployment, but they don't describe how to deploy the resources. When you submit a template to Resource Manager for deployment, the control plane can deploy the defined resources in an organized and consistent manner. In the preceding unit, you learned about the differences between imperative code and declarative code.
Why use ARM templates?
There are many benefits to using ARM templates, either JSON or Bicep, for your resource provisioning.
	•	Repeatable results: ARM templates are idempotent, which means that you can repeatedly deploy the same template and get the same result. The template doesn't duplicate resources.
	•	Orchestration: When a template deployment is submitted to Resource Manager, the resources in the template are deployed in parallel. This process allows deployments to finish faster. Resource Manager orchestrates these deployments in the correct order if one resource depends on another.
	•	Preview: The what-if tool, available in Azure PowerShell and Azure CLI, allows you to preview changes to your environment before template deployment. This tool details any creations, modification, and deletions that are made by your template.
	•	Testing and Validation: You can use tools like the Bicep linter to check the quality of your templates before deployment. ARM templates submitted to Resource Manager are validated before the deployment process. This validation alerts you to any errors in your template before resource provisioning.
	•	Modularity: You can break up your templates into smaller components and link them together at deployment.
	•	CI/CD integration: Your ARM templates can be integrated into multiple CI/CD tools, like Azure DevOps and GitHub Actions. You can use these tools to version templates through source control and build release pipelines.
	•	Extensibility: With deployment scripts, you can run Bash or PowerShell scripts from within your ARM templates. These scripts perform tasks, like data plane operations, at deployment. Through extensibility, you can use a single ARM template to deploy a complete solution.
JSON and Bicep templates
Two types of ARM templates are available for use today: JSON templates and Bicep templates. JavaScript Object Notation (JSON) is an open-standard file format that multiple languages can use. Bicep is a new domain-specific language that was recently developed for authoring ARM templates by using an easier syntax. You can use either template format for your ARM templates and resource deployments.


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 8>

————————————————————————

<doc 9>

Skip to main content







Add
	•	
Achievements
What is Bicep?
Completed
	•	3 minutes
Now that your team understands how Azure Resource Manager works, you decide to use ARM templates for your resource provisioning. You understand that you can write ARM templates in two different ways: by using JSON or by using Bicep. You want to learn more about Bicep templates so that you can make an informed decision about which language to use.
In this unit, you learn about the Bicep template language and the benefits it provides to template authoring.
Bicep language
Bicep is a Resource Manager template language that's used to declaratively deploy Azure resources. Bicep is designed for a specific scenario or domain, which makes it a domain-specific language. Bicep isn't meant to be used as a standard programming language for writing applications. Bicep is used only to create Resource Manager templates. Bicep is intended to be easy to understand and straightforward to learn, regardless of your experience with other programming languages. All resource types, API versions, and properties are valid in Bicep templates.
Note
If you previously looked into using JSON templates, you might have noticed that Bicep simplifies the template creation experience. It provides a syntax that's easier to understand, better support for modularity and reusable code, and improved type safety. Creating a JSON ARM template requires complicated expressions, and the final result might be verbose.
Benefits of Bicep
Bicep provides many improvements over JSON for template authoring, including:
	•	Simpler syntax: Bicep provides a simpler syntax for writing templates. You can reference parameters and variables directly, without using complicated functions. String interpolation is used in place of concatenation to combine values for names and other items. You can reference the properties of a resource directly by using its symbolic name instead of complex reference statements. These syntax improvements help both with authoring and reading Bicep templates.
	•	Modules: You can break down complex template deployments into smaller module files and reference them in a main template. These modules provide easier management and greater reusability. You can even share your modules with your team.
	•	Automatic dependency management: In most situations, Bicep automatically detects dependencies between your resources. This process removes some of the work involved in template authoring.
	•	Type validation and IntelliSense: The Bicep extension for Visual Studio Code features rich validation and IntelliSense for all Azure resource type API definitions. This feature helps provide an easier authoring experience.
Take a look at the following example of a Bicep template that defines an Azure storage account. The template automatically generates the name of the storage account. After deployment, the resource ID is returned as output to the user who executes the template.
param location string = resourceGroup().location
param namePrefix string = 'storage'

var storageAccountName = '${namePrefix}${uniqueString(resourceGroup().id)}'
var storageAccountSku = 'Standard_RAGRS'

resource storageAccount 'Microsoft.Storage/storageAccounts@2023-05-01' = {
 name: storageAccountName
 location: location
 kind: 'StorageV2'
 sku: {
  name: storageAccountSku
 }
 properties: {
  accessTier: 'Hot'
  supportsHttpsTrafficOnly: true
 }
}

output storageAccountId string = storageAccount.id


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 9>

————————————————————————

<doc 10>

Skip to main content







Add
	•	
Achievements
How Bicep works
Completed
	•	3 minutes
You developed an understanding of the Bicep template language and the benefits that it provides for template authoring. Before you begin the process of writing Bicep templates to provision your resources, you want to learn more about how Bicep works.
In this unit, you learn about how Bicep works with Azure Resource Manager.
Bicep deployment
In the preceding unit, you learned that Bicep is designed for a specific scenario or domain, which makes it a domain-specific language. Bicep is built to make it easy to deploy and configure Azure resources.
When you deploy a resource or series of resources to Azure, you submit the Bicep template to Resource Manager, which still requires JSON templates. The tooling built into Bicep converts your Bicep template into a JSON template. This process is known as transpilation, which essentially treats the ARM template as an intermediate language. The conversion happens automatically when you submit your deployment, or you can do it manually.

Note
Transpilation is the process of converting source code written in one language into another language.
The latest versions of Azure CLI and Azure PowerShell have built-in Bicep support. You can use the same deployment commands to deploy Bicep and JSON templates. For example, the following command deploys a Bicep template to a resource group named storage-resource-group:
az deployment group create \
 --template-file main.bicep \
 --resource-group storage-resource-group
After this deployment is submitted, Resource Manager looks at the resources currently deployed in Azure. It then looks at what you're trying to deploy, and it sets up a sequence of steps to achieve this state. All these activities involve invoking the Resource Manager API.
You can view the JSON template you submitted to Resource Manager by using the bicep build command. In the next example, a Bicep template is converted into its corresponding JSON template:
bicep build main.bicep
Comparing JSON and Bicep
Bicep provides a simpler syntax to use when you're writing templates. Look at the following examples of two templates. The template on the left side of the screen is a Bicep template. The template on the right side of the screen is a JSON template.

Notice that the Bicep template contains less code. The syntax is easier to read and comprehend, and there are no complex expressions like in the JSON template on the right.
Note
To view equivalent JSON and Bicep files side by side, see Bicep Playground.


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 10>

————————————————————————

<doc 11>

Skip to main content







Add
	•	
Achievements
When to use Bicep
Completed
	•	2 minutes
You found that many tool sets are available for infrastructure-as-code resource deployments. Now, you want to learn more about when Bicep might be the right tool for you and your organization.
Is Bicep the right tool?
There are many reasons to choose Bicep as the main tool set for your infrastructure-as-code deployments. For Azure deployments, Bicep has some advantages, but Bicep doesn't work as a language for other cloud providers.
When is Bicep the right tool?
If you use Azure as your cloud platform, consider these advantages of using Bicep:
	•	Azure-native: With Bicep, you're using a language that is native to Azure. When new Azure resources are released or updated, Bicep supports those features on day one. When you use other third-party tools, it might take some time for new features to be defined in the tool set.
	•	Azure integration: Azure Resource Manager (ARM) templates, both JSON and Bicep, are fully integrated within the Azure platform. With Resource Manager deployments, you can monitor the progress of your deployment in the Azure portal.
	•	Azure support: Bicep is a fully supported product with Microsoft Support.
	•	No state management: Bicep deployments compare the current state of your Azure resources with the state that you define in the template. You don't need to keep your resource state information somewhere else, like in a storage account. Azure automatically keeps track of this state for you.
	•	Easy transition from JSON: If you already use JSON templates as your declarative ARM template language, it isn't a difficult process to transition to using Bicep. You can use the Bicep CLI to decompile any ARM template into a Bicep template by using the bicep decompile command.
When is Bicep not the right tool?
Some situations might call for another tool set. Consider the following reasons not to use Bicep as your main tool set:
	•	Existing tool set: When you're determining when to use Bicep, the first question to ask is, does my organization already have a tool set in use? Many tooling options are available that can be used for infrastructure-as-code resource provisioning. Sometimes, it makes sense to use existing financial and knowledge investments when you consider adopting a new process.
	•	Multicloud: If your organization uses multiple cloud providers to host its infrastructure, Bicep might not be the right tool. Other cloud providers don't support Bicep as a template language. Open source tools like Terraform can be used for multicloud deployments, including deployments to Azure.


Feedback
Was this page helpful?
Yes No


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 11>

————————————————————————

<doc 12>

Skip to main content
If you like SWA CLI, give it a star on GitHub and follow us on Twitter

SWA CLIGet StartedAboutDocsContributeStackOverflow


	•	About SWA CLI
	•	Get Started
	•	CLI
	•	Contribute
	•	🏠
	•	About SWA CLI
On this page
About SWA CLI
The Static Web Apps (SWA) CLI is an open-source commandline tool that streamlines local development and deployment for Azure Static Web Apps.
	•	Find it on npm: @azure/static-web-apps-cli
	•	Get Started: Install the SWA CLI
	•	Contribute: Build from Source


Static Web Apps
Azure Static Web Apps is a turnkey service for modern full-stack applications with pre-built or pre-rendered front-ends, and serverless backends. It became generally available in May 2021.
The Static Web Apps architecture views web apps as two components:
	•	static content like HTML, CSS, JS and media assets
	•	dynamic API for client interactions requiring data or processing
This allows the architecture to scale each component using technologies best suited to its type and purpose. Static content is hosted in globally-distributed content servers for fast delivery. Dynamic APIs are implemented using a serverless architecture, for cost-effective scaling on-demand.

Developer benefits to using Static Web Apps:
	•	works with popular web frameworks and static site generators
	•	quickstarts with VS Code, Azure Portal and CLI options
	•	automated CI/CD with GitHub, GitLab and Bit Bucket options.
Visit the Azure Static Web Apps Documentation for more information.
About SWA CLI
The Static Web Apps CLI (SWA CLI or swa) is an open-source command-line tool to streamline the local development experience for Azure Static Web Apps - from setup to deployment.
Key Features of SWA CLI:
	•	Serve static app assets, or proxy to your app dev server
	•	Serve API requests or proxy to APIs in Azure Functions Core Tools
	•	Emulate authentication and authorization (with mock responses)
	•	Emulate Static Web Apps configuration (for routing & role-based auth)
	•	Deploy to Azure Static Web Apps (streamlined develop-deploy workflow)
Components of CLI
The figure illustrates the high-level architecture for the Static Web Apps CLI, identifying the key components and their relationships:

1. Reverse Proxy: This is the heart of SWA CLI. It intercepts and forwards HTTP requests to the right components based on the purpose:
	•	/.auth/** requests => forwarded to the Auth emulator server.
	•	/api/** requests => forwarded to localhost functions (if present).
	•	/** => all other requests forwarded to the static assets content server.
2. Authentication Server (Emulator):
	•	Emulates auth flow
	•	Returns mock responses.
3. Static Content Server.
	•	Serves static assets (HTML, CSS, JS, media files)
	•	Useful for local testing, validation of user experience
	•	Default target for requests not handled by other components
4. Serverless API server.
	•	Useful for local API testing (if used)
	•	Requires (and has API endpoints served by) Azure Functions Core Tools.
Always test on Azure for production!
The Static Web Apps CLI is a convenience for local development and testing. It uses emulated services so differences from real-world behaviors are to be expected. Always test final application on Azure using preview and production environments, to validate behavior.
Contributing to CLI
This is an open-source project made for the benefit of our developer community. Your feedback and contributions are key to its success.
Here are some ways to help:
	•	Discovered buggy or unusual behavior? Send us a bug report
	•	Have a feature request? Send us a Feature Request
	•	Found a security vulnerability? Report Security Issues
	•	Have other questions or comments? Post to our Discussions board
	•	Posting questions to Stack Overflow? Post to the swa-cli tag
Contribute directly to the project by fixing bugs, writing (or improving) documentation, and proposing (or implementing) new features. To start:
	•	Review our Contributor Guidelines!
	•	Learn to Build Project From Source!
Thank you for your continued support! ♥️
Edit this page


Next
1. Install the SWA CLI
	•	Static Web Apps
	•	About SWA CLI
	•	Components of CLI
	•	Contributing to CLI
Copyright © 2025 Microsoft | Built with Docusaurus and Iconcloud.design 
build: main+sha.08ac5a1


</doc 12>

————————————————————————

<doc 13>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Troubleshoot common Azure deployment errors
	•	2025-04-28
In this article
This article describes how to troubleshoot common Azure deployment errors, and provides information about solutions. Azure resources can be deployed with Bicep files or Azure Resource Manager templates (ARM templates). If you can't find the error code for your deployment error, see Find error code.
If your error code isn't listed, submit a GitHub issue. On the right side of the page, select Feedback. At the bottom of the page, under Feedback select This page. Provide your documentation feedback but don't include confidential information because GitHub issues are public.
Error codes
Error code
Mitigation
More information
AccountNameInvalid
Follow naming guidelines for storage accounts.
Resolve errors for storage account names
AccountPropertyCannotBeSet
Check available storage account properties.
storageAccounts
AllocationFailed
The cluster or region doesn't have resources available or can't support the requested VM size. Retry the request at a later time, or request a different VM size.
Provisioning and allocation issues for Linux 

Provisioning and allocation issues for Windows 

Troubleshoot allocation failures
AnotherOperationInProgress
Wait for concurrent operation to complete.

AuthorizationFailed
Your account or service principal doesn't have sufficient access to complete the deployment. Check the role your account belongs to, and its access for the deployment scope.

You might receive this error when a required resource provider isn't registered.
Azure role-based access control (Azure RBAC)

Resolve registration
BadRequest
You sent deployment values that don't match what is expected by Resource Manager. Check the inner status message for help with troubleshooting. 

Validate the template's syntax to resolve deployment errors when using a template that was exported from an existing Azure resource.
Template reference 

Resource location in ARM template 

Resource location in Bicep file 

Resolve invalid template
Conflict
You're requesting an operation that isn't allowed in the resource's current state. For example, disk resizing is allowed only when creating a VM or when the VM is deallocated.

DeploymentActiveAndUneditable
Wait for concurrent deployment to this resource group to complete.

DeploymentFailedCleanUp
When you deploy in complete mode, any resources that aren't in the template are deleted. You get this error when you don't have adequate permissions to delete all of the resources not in the template. To avoid the error, change the deployment mode to incremental.
Azure Resource Manager deployment modes
DeploymentNameInvalidCharacters
The deployment name can only contain letters, digits, hyphen (-), dot (.) or underscore (_).

DeploymentNameLengthLimitExceeded
The deployment names are limited to 64 characters.

DeploymentFailed
The DeploymentFailed error is a general error that doesn't provide the details you need to solve the error. Look in the error details for an error code that provides more information.
Find error code
DeploymentQuotaExceeded
If you reach the limit of 800 deployments per resource group, delete deployments from the history that are no longer needed.
Resolve error when deployment count exceeds 800
DeploymentJobSizeExceeded
Simplify your template to reduce size.
Resolve template size errors
DnsRecordInUse
The DNS record name must be unique. Enter a different name.

ImageNotFound
Check VM image settings.

InaccessibleImage
Azure Container Instance deployment fails. You might need to include the image's tag with the syntax registry/image:tag to deploy the container. For a private registry, verify your credentials are correct.
Find error code
InternalServerError
Caused by a temporary problem. Retry the deployment.

InUseSubnetCannotBeDeleted
This error can occur when you try to update a resource, if the request process deletes and creates the resource. Make sure to specify all unchanged values.
Update resource
InvalidAuthenticationTokenTenant
Get access token for the appropriate tenant. You can only get the token from the tenant that your account belongs to.

InvalidContentLink
You've most likely attempted to link to a nested template that isn't available. Double check the URI you provided for the nested template. If the template exists in a storage account, make sure the URI is accessible. You might need to pass a SAS token. Currently, you can't link to a template that is in a storage account behind an Azure Storage firewall. Consider moving your template to another repository, like GitHub.
Linked and nested ARM templates 

Bicep modules
InvalidDeploymentLocation
When deploying at the subscription level, you've provided a different location for a previously used deployment name.
ARM template subscription deployment 

Bicep subscription deployment
InvalidParameter
One of the values you provided for a resource doesn't match the expected value. This error can result from many different conditions. For example, a password may be insufficient, or a blob name may be incorrect. The error message should indicate which value needs to be corrected.
ARM template parameters 

Bicep parameters
InvalidRequestContent
The deployment values either include values that aren't recognized, or required values are missing. Confirm the values for your resource type.
Template reference
InvalidRequestFormat
Enable debug logging when running the deployment, and verify the contents of the request.
Debug logging
InvalidResourceLocation
Provide a unique name for the storage account.
Resolve errors for storage account names
InvalidResourceNamespace
Check the resource namespace you specified in the type property.
Template reference
InvalidResourceReference
The resource either doesn't yet exist or is incorrectly referenced. Check whether you need to add a dependency. Verify that your use of the reference function includes the required parameters for your scenario.
Resolve dependencies
InvalidResourceType
Check the resource type you specified in the type property.
Template reference
InvalidSubscriptionRegistrationState
Register your subscription with the resource provider.
Resolve registration
InvalidTemplateDeployment 
InvalidTemplate
Check your template syntax for errors.
Resolve invalid template
InvalidTemplateCircularDependency
Remove unnecessary dependencies.
Resolve circular dependencies
JobSizeExceeded
Simplify your template to reduce size.
Resolve template size errors
LinkedAuthorizationFailed
Check if your account belongs to the same tenant as the resource group that you're deploying to.

LinkedInvalidPropertyId
The resource ID for a resource isn't resolved. Check that you provided all required values for the resource ID. For example, subscription ID, resource group name, resource type, parent resource name (if needed), and resource name.
Resolve errors for resource name and type
LocationRequired
Provide a location for the resource.
Resource location in ARM template 

Resource location in Bicep file
MismatchingResourceSegments
Make sure a nested resource has the correct number of segments in name and type.
Resolve resource segments
MissingRegistrationForLocation
Check resource provider registration status and supported locations.
Resolve registration
MissingSubscriptionRegistration
Register your subscription with the resource provider.
Resolve registration
NoRegisteredProviderFound
Check resource provider registration status.
Resolve registration
NotFound
You might be attempting to deploy a dependent resource in parallel with a parent resource. Check if you need to add a dependency.
Resolve dependencies
OperationNotAllowed
There can be several reasons for this error message.

1. The deployment is attempting an operation which is not allowed on specified SKU.

2. The deployment is attempting an operation that exceeds the quota for the subscription, resource group, or region. If possible, revise your deployment to stay within the quotas. Otherwise, consider requesting a change to your quotas.
Resolve quotas
OperationNotAllowedOnVMImageAsVMsBeingProvisioned
You might be attempting to delete an image that is currently being used to provision VMs. You cannot delete an image that is being used by any virtual machine during the deployment process. Retry the image delete operation after the deployment of the VM is complete.

ParentResourceNotFound
Make sure a parent resource exists before creating the child resources.
Resolve parent resource
PasswordTooLong
You might have selected a password with too many characters, or converted your password value to a secure string before passing it as a parameter. If the template includes a secure string parameter, you don't need to convert the value to a secure string. Provide the password value as text.

PrivateIPAddressInReservedRange
The specified IP address includes an address range required by Azure. Change IP address to avoid reserved range.
Private IP addresses
PrivateIPAddressNotInSubnet
The specified IP address is outside of the subnet range. Change IP address to fall within subnet range.
Private IP addresses
PropertyChangeNotAllowed
Some properties can't be changed on a deployed resource. When updating a resource, limit your changes to permitted properties.
Update resource
PublicIPCountLimitReached
You've reached the limit for the number of running public IPs. Shut down unneeded resources or contact Azure support to request an increase. For example, in Azure Databricks, see Unexpected cluster termination and IP address limit prevents cluster creation.
Public IP address limits
RegionDoesNotAllowProvisioning
Select a different region or submit a quota support request for Region access.

RequestDisallowedByPolicy
Your subscription includes a resource policy that prevents an action you're trying to do during deployment. Find the policy that blocks the action. If possible, change your deployment to meet the limitations from the policy.
Resolve policies
ReservedResourceName
Provide a resource name that doesn't include a reserved name.
Reserved resource names
ResourceGroupBeingDeleted
Wait for deletion to complete.

ResourceGroupNotFound
Check the name of the target resource group for the deployment. The target resource group must already exist in your subscription. Check your subscription context.
Azure CLI PowerShell
ResourceNotFound
Your deployment references a resource that can't be resolved. Verify that your use of the reference function includes the parameters required for your scenario.
Resolve references
ResourceQuotaExceeded
The deployment is trying to create resources that exceed the quota for the subscription, resource group, or region. If possible, revise your infrastructure to stay within the quotas. Otherwise, consider requesting a change to your quotas.
Resolve quotas
SkuNotAvailable
Select SKU (such as VM size) that is available for the location you've selected.
Resolve SKU
StorageAccountAlreadyTaken 
StorageAccountAlreadyExists
Provide a unique name for the storage account.
Resolve errors for storage account names
StorageAccountInAnotherResourceGroup
Provide a unique name for the storage account.
Resolve errors for storage account names
StorageAccountNotFound
Check the subscription, resource group, and name of the storage account that you're trying to use.

SubnetsNotInSameVnet
A virtual machine can only have one virtual network. When deploying several NICs, make sure they belong to the same virtual network.
Windows VM multiple NICs 

Linux VM multiple NICs
SubnetIsFull
There aren't enough available addresses in the subnet to deploy resources. You can release addresses from the subnet, use a different subnet, or create a new subnet.
Manage subnets and Virtual network FAQ 

Private IP addresses
SubscriptionNotFound
A specified subscription for deployment can't be accessed. It could be the subscription ID is wrong, the user deploying the template doesn't have adequate permissions to deploy to the subscription, or the subscription ID is in the wrong format. When using ARM template nested deployments to deploy across scopes, provide the subscription's GUID.
ARM template deploy across scopes 

Bicep file deploy across scopes
SubscriptionNotRegistered
When a resource is deployed, the resource provider must be registered for your subscription. When you use an Azure Resource Manager template for deployment, the resource provider is automatically registered in the subscription. Sometimes, the automatic registration doesn't complete in time. To avoid this intermittent error, register the resource provider before deployment.
Resolve registration
SubscriptionRequestsThrottled
Azure Resource Manager throttles requests at the subscription level or tenant level. Resource providers like Microsoft.Compute also throttle requests specific to its operations. 

When a limit is reached, you get a message and a value with the amount of time you should wait before sending a new request. For example: Number of requests for subscription '<subscription-id-guid>' and operation '<resource provider>' exceeded the backend storage limit. Please try again after '6' seconds. 

An HTTP response returns a message like HTTP status code 429 Too Many Requests with a Retry-After value that specifies the number of seconds to wait before you send another request.
Throttling Resource Manager requests 

Troubleshooting API throttling errors - virtual machines 

Azure Kubernetes Service throttling
TemplateResourceCircularDependency
Remove unnecessary dependencies.
Resolve circular dependencies
TooManyTargetResourceGroups
Reduce number of resource groups for a single deployment.
ARM template deploy across scopes 

Bicep file deploy across scopes
Next steps
	•	For information about validation or deployment errors, see Find error codes.
	•	To get more details to troubleshoot a deployment, see Enable debug logging.
	•	To isolate the cause of a deployment error, see Create a troubleshooting template.




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 13>

————————————————————————

<doc 14>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Understand the structure and syntax of ARM templates
	•	2025-04-28
In this article
This article describes the structure of an Azure Resource Manager template (ARM template). It presents the different sections of a template and the properties that are available in those sections.
This article is intended for users who have some familiarity with ARM templates. It provides detailed information about the structure of the template. For a step-by-step tutorial that guides you through the process of creating a template, see Tutorial: Create and deploy your first ARM template. To learn about ARM templates through a guided set of Learn modules, see Deploy and manage resources in Azure by using ARM templates.
Tip
Bicep is a new language that offers the same capabilities as ARM templates but with a syntax that's easier to use. If you're considering infrastructure as code options, we recommend looking at Bicep.
To learn about the elements of a Bicep file, see Understand the structure and syntax of Bicep files.
Template format
In its simplest structure, a template has the following elements:
{
 "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
 "languageVersion": "",
 "contentVersion": "",
 "apiProfile": "",
 "definitions": { },
 "parameters": { },
 "variables": { },
 "functions": [ ],
 "resources": [ ], /* or "resources": { } with languageVersion 2.0 */
 "outputs": { }
}
Element name
Required
Description
$schema
Yes
Location of the JavaScript Object Notation (JSON) schema file that describes the version of the template language. The version number you use depends on the scope of the deployment and your JSON editor.

If you're using Visual Studio Code with the Azure Resource Manager tools extension, use the latest version for resource group deployments:
https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#

Other editors (including Visual Studio) may not be able to process this schema. For those editors, use:
https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#

For subscription deployments, use:
https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#

For management group deployments, use:
https://schema.management.azure.com/schemas/2019-08-01/managementGroupDeploymentTemplate.json#

For tenant deployments, use:
https://schema.management.azure.com/schemas/2019-08-01/tenantDeploymentTemplate.json#
languageVersion
No
Language version of the template. To view the enhancements of languageVersion 2.0, see languageVersion 2.0.
contentVersion
Yes
Version of the template (such as 1.0.0.0). You can provide any value for this element. Use this value to document significant changes in your template. When deploying resources using the template, this value can be used to make sure that the right template is being used.
apiProfile
No
An API version that serves as a collection of API versions for resource types. Use this value to avoid having to specify API versions for each resource in the template. When you specify an API profile version and don't specify an API version for the resource type, Resource Manager uses the API version for that resource type that is defined in the profile.

The API profile property is especially helpful when deploying a template to different environments, such as Azure Stack and global Azure. Use the API profile version to make sure your template automatically uses versions that are supported in both environments. For a list of the current API profile versions and the resources API versions defined in the profile, see API Profile.

For more information, see Track versions using API profiles.
definitions
No
Schemas that are used to validate array and object values. Definitions are only supported in languageVersion 2.0.
parameters
No
Values that are provided when deployment is executed to customize resource deployment.
variables
No
Values that are used as JSON fragments in the template to simplify template language expressions.
functions
No
User-defined functions that are available within the template.
resources
Yes
Resource types that are deployed or updated in a resource group or subscription.
outputs
No
Values that are returned after deployment.
Each element has properties you can set. This article describes the sections of the template in greater detail.
Definitions
In the definitions section of the template, specify the schemas used for validating array and object values. Definitions can only be used with languageVersion 2.0.
"definitions": {
 "<definition-name>": {
  "type": "<data-type-of-definition>",
  "allowedValues": [ "<array-of-allowed-values>" ],
  "minValue": <minimum-value-for-int>,
  "maxValue": <maximum-value-for-int>,
  "minLength": <minimum-length-for-string-or-array>,
  "maxLength": <maximum-length-for-string-or-array>,
  "prefixItems": <schema-for-validating-array>,
  "items": <schema-for-validating-array-or-boolean>,
  "properties": <schema-for-validating-object>,
  "additionalProperties": <schema-for-validating-object-or-boolean>,
  "discriminator": <schema-to-apply>,
  "nullable": <boolean>,
  "metadata": {
   "description": "<description-of-the-type-definition>"
  }
 }
}
Element name
Required
Description
definition-name
Yes
Name of the type definition. Must be a valid JavaScript identifier.
type
Yes
Type of the type definition. The allowed types and values are string, securestring, int, bool, object, secureObject, and array. See Data types in ARM templates.
allowedValues
No
Array of allowed values for the type definition to make sure that the right value is provided.
minValue
No
The minimum value for int type definitions, this value is inclusive.
maxValue
No
The maximum value for int type definitions, this value is inclusive.
minLength
No
The minimum length for string, secure string, and array type definitions, this value is inclusive.
maxLength
No
The maximum length for string, secure string, and array type definitions, this value is inclusive.
prefixItems
No
The schema for validating the element of an array at the same index.
items
No
The schema that is applied to all elements of the array whose index is greater than the largest index of the prefixItems constraint, or boolean for controlling the elements of the array whose index is greater than the largest index of the prefixItems constraint.
properties
No
The schema for validating object.
additionalProperties
No
The schema that is applied to all properties not mentioned in the properties constraint, or boolean for accepting any property not defined in the properties constraint.
discriminator
No
The schema to apply based on a discriminator property.
nullable
No
A boolean indicating that the value may be null or omitted.
description
No
Description of the type definition that is displayed to users through the portal. For more information, see Comments in templates.
For examples of how to use type definitions, see Type definitions in ARM templates.
In Bicep, see User-defined data types.
Parameters
In the parameters section of the template, you specify which values you can input when deploying the resources. You're limited to 256 parameters in a template. You can reduce the number of parameters by using objects that contain multiple properties.
The available properties for a parameter are:
"parameters": {
 "<parameter-name>" : {
  "type" : "<type-of-parameter-value>",
  "defaultValue": "<default-value-of-parameter>",
  "allowedValues": [ "<array-of-allowed-values>" ],
  "minValue": <minimum-value-for-int>,
  "maxValue": <maximum-value-for-int>,
  "minLength": <minimum-length-for-string-or-array>,
  "maxLength": <maximum-length-for-string-or-array>,
  "prefixItems": <schema-for-validating-array>,
  "items": <schema-for-validating-array-or-boolean>,
  "properties": <schema-for-validating-object>,
  "additionalProperties": <schema-for-validating-object-or-boolean>,
  "discriminator": <schema-to-apply>,
  "nullable": <boolean>,
  "metadata": {
   "description": "<description-of-the parameter>"
  }
 }
}
Element name
Required
Description
parameter-name
Yes
Name of the parameter. Must be a valid JavaScript identifier.
type
Yes
Type of the parameter value. The allowed types and values are string, securestring, int, bool, object, secureObject, and array. See Data types in ARM templates.
defaultValue
No
Default value for the parameter, if no value is provided for the parameter.
allowedValues
No
Array of allowed values for the parameter to make sure that the right value is provided.
minValue
No
The minimum value for int type parameters, this value is inclusive.
maxValue
No
The maximum value for int type parameters, this value is inclusive.
minLength
No
The minimum length for string, secure string, and array type parameters, this value is inclusive.
maxLength
No
The maximum length for string, secure string, and array type parameters, this value is inclusive.
prefixItems
No
The type definition for validating the element of an array at the same index. prefixItems is only supported in languageVersion 2.0.
items
No
The schema that is applied to all elements of the array whose index is greater than the largest index of the prefixItems constraint, or boolean for controlling the elements of the array whose index is greater than the largest index of the prefixItems constraint. items is only supported in languageVersion 2.0.
properties
No
The schema for validating object. properties is only supported in languageVersion 2.0.
additionalProperties
No
The schema that is applied to all properties not mentioned in the properties constraint, or boolean for accepting any property not defined in the properties constraint. additionalProperties is only supported in languageVersion 2.0.
discriminator
No
The schema to apply based on a discriminator property. discriminator is only supported in languageVersion 2.0.
nullable
No
A boolean indicating that the value may be null or omitted. nullable is only supported in languageVersion 2.0.
description
No
Description of the parameter that is displayed to users through the portal. For more information, see Comments in templates.
For examples of how to use parameters, see Parameters in ARM templates.
In Bicep, see parameters.
Variables
In the variables section, you construct values that can be used throughout your template. You don't need to define variables, but they often simplify your template by reducing complex expressions. The format of each variable matches one of the data types. You're limited to 256 variables in a template.
The following example shows the available options for defining a variable:
"variables": {
 "<variable-name>": "<variable-value>",
 "<variable-name>": {
  <variable-complex-type-value>
 },
 "<variable-object-name>": {
  "copy": [
   {
    "name": "<name-of-array-property>",
    "count": <number-of-iterations>,
    "input": <object-or-value-to-repeat>
   }
  ]
 },
 "copy": [
  {
   "name": "<variable-array-name>",
   "count": <number-of-iterations>,
   "input": <object-or-value-to-repeat>
  }
 ]
}
For information about using copy to create several values for a variable, see Variable iteration.
For examples of how to use variables, see Variables in ARM template.
In Bicep, see variables.
Functions
Within your template, you can create your own functions. These functions are available for use in your template. Typically, you define complicated expressions that you don't want to repeat throughout your template. You create the user-defined functions from expressions and functions that are supported in templates.
When defining a user function, there are some restrictions:
	•	The function can't access variables.
	•	The function can only use parameters that are defined in the function. When you use the parameters function within a user-defined function, you're restricted to the parameters for that function.
	•	The function can't call other user-defined functions.
	•	The function can't use the reference function.
	•	Parameters for the function can't have default values.
"functions": [
 {
  "namespace": "<namespace-for-functions>",
  "members": {
   "<function-name>": {
    "parameters": [
     {
      "name": "<parameter-name>",
      "type": "<type-of-parameter-value>"
     }
    ],
    "output": {
     "type": "<type-of-output-value>",
     "value": "<function-return-value>"
    }
   }
  }
 }
],
Element name
Required
Description
namespace
Yes
Namespace for the custom functions. Use to avoid naming conflicts with template functions.
function-name
Yes
Name of the custom function. When calling the function, combine the function name with the namespace. For example, to call a function named uniqueName in the namespace contoso, use "[contoso.uniqueName()]".
parameter-name
No
Name of the parameter to be used within the custom function.
parameter-value
No
Type of the parameter value. The allowed types and values are string, securestring, int, bool, object, secureObject, and array.
output-type
Yes
Type of the output value. Output values support the same types as function input parameters.
output-value
Yes
Template language expression that is evaluated and returned from the function.
For examples of how to use custom functions, see User-defined functions in ARM template.
In Bicep, user-defined functions aren't supported. Bicep does support various functions and operators.
Resources
In the resources section, you define the resources that are deployed or updated. You're limited to 800 resources in a template.
You define resources with the following structure:
"resources": [
 {
  "condition": "<true-to-deploy-this-resource>",
  "type": "<resource-provider-namespace/resource-type-name>",
  "apiVersion": "<api-version-of-resource>",
  "name": "<name-of-the-resource>",
  "comments": "<your-reference-notes>",
  "location": "<location-of-resource>",
  "dependsOn": [
    "<array-of-related-resource-names>"
  ],
  "tags": {
    "<tag-name1>": "<tag-value1>",
    "<tag-name2>": "<tag-value2>"
  },
  "identity": {
   "type": "<system-assigned-or-user-assigned-identity>",
   "userAssignedIdentities": {
    "<resource-id-of-identity>": {}
   }
  },
  "sku": {
    "name": "<sku-name>",
    "tier": "<sku-tier>",
    "size": "<sku-size>",
    "family": "<sku-family>",
    "capacity": <sku-capacity>
  },
  "kind": "<type-of-resource>",
  "scope": "<target-scope-for-extension-resources>",
  "copy": {
    "name": "<name-of-copy-loop>",
    "count": <number-of-iterations>,
    "mode": "<serial-or-parallel>",
    "batchSize": <number-to-deploy-serially>
  },
  "plan": {
    "name": "<plan-name>",
    "promotionCode": "<plan-promotion-code>",
    "publisher": "<plan-publisher>",
    "product": "<plan-product>",
    "version": "<plan-version>"
  },
  "properties": {
    "<settings-for-the-resource>",
    "copy": [
      {
        "name": "<name-of-copy-loop>",
        "count": <number-of-iterations>,
        "input": {}
      }
    ]
  },
  "resources": [
    "<array-of-child-resources>"
  ]
 }
]
Element name
Required
Description
condition
No
Boolean value that indicates whether the resource is provisioned during this deployment. When true, the resource is created during deployment. When false, the resource is skipped for this deployment. See condition.
type
Yes
Type of the resource. This value is a combination of the namespace of the resource provider and the resource type (such as Microsoft.Storage/storageAccounts). To determine available values, see template reference. For a child resource, the format of the type depends on whether it's nested within the parent resource or defined outside of the parent resource. See Set name and type for child resources.
apiVersion
Yes
Version of the REST API to use for creating the resource. When creating a new template, set this value to the latest version of the resource you're deploying. As long as the template works as needed, keep using the same API version. By continuing to use the same API version, you minimize the risk of a new API version changing how your template works. Consider updating the API version only when you want to use a new feature that is introduced in a later version. To determine available values, see template reference.
name
Yes
Name of the resource. The name must follow URI component restrictions defined in RFC3986. Azure services that expose the resource name to outside parties validate the name to make sure it isn't an attempt to spoof another identity. For a child resource, the format of the name depends on whether it's nested within the parent resource or defined outside of the parent resource. See Set name and type for child resources.
comments
No
Your notes for documenting the resources in your template. For more information, see Comments in templates.
location
Varies
Supported geo-locations of the provided resource. You can select any of the available locations, but typically it makes sense to pick one that is close to your users. Usually, it also makes sense to place resources that interact with each other in the same region. Most resource types require a location, but some types (such as a role assignment) don't require a location. See Set resource location.
dependsOn
No
Resources that must be deployed before this resource is deployed. Resource Manager evaluates the dependencies between resources and deploys them in the correct order. When resources aren't dependent on each other, they're deployed in parallel. The value can be a comma-separated list of a resource names or resource unique identifiers. Only list resources that are deployed in this template. Resources that aren't defined in this template must already exist. Avoid adding unnecessary dependencies as they can slow your deployment and create circular dependencies. For guidance on setting dependencies, see Define the order for deploying resources in ARM templates.
tags
No
Tags that are associated with the resource. Apply tags to logically organize resources across your subscription.
identity
No
Some resources support managed identities for Azure resources. Those resources have an identity object at the root level of the resource declaration. You can set whether the identity is user-assigned or system-assigned. For user-assigned identities, provide a list of resource IDs for the identities. Set the key to the resource ID and the value to an empty object. For more information, see Configure managed identities for Azure resources on an Azure VM using templates.
sku
No
Some resources allow values that define the SKU to deploy. For example, you can specify the type of redundancy for a storage account.
kind
No
Some resources allow a value that defines the type of resource you deploy. For example, you can specify the type of Azure Cosmos DB instance to create.
scope
No
The scope property is only available for extension resource types. Use it when specifying a scope that is different than the deployment scope. See Setting scope for extension resources in ARM templates.
copy
No
If more than one instance is needed, the number of resources to create. The default mode is parallel. Specify serial mode when you don't want all or the resources to deploy at the same time. For more information, see Create several instances of resources in Azure Resource Manager.
plan
No
Some resources allow values that define the plan to deploy. For example, you can specify the marketplace image for a virtual machine.
properties
No
Resource-specific configuration settings. The values for the properties are the same as the values you provide in the request body for the REST API operation (PUT method) to create the resource. You can also specify a copy array to create several instances of a property. To determine available values, see template reference.
resources
No
Child resources that depend on the resource being defined. Only provide resource types that are permitted by the schema of the parent resource. Dependency on the parent resource isn't implied. You must explicitly define that dependency. See Set name and type for child resources.
To support Bicep symbolic name in ARM JSON templates, add languageVersion with the version 2.0 or newer, and change the resource definition from an array to an object.
{
 "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
 "languageVersion": "2.0",
 "contentVersion": "1.0.0.0",
 "resources": {
  "<name-of-the-resource>": {
   ...
  }
 }
}
For more information, see Resources.
In Bicep, see resources.
Outputs
In the outputs section, you specify values that are returned from deployment. Typically, you return values from resources that were deployed. You're limited to 64 outputs in a template.
The following example shows the structure of an output definition:
"outputs": {
 "<output-name>": {
  "condition": "<boolean-value-whether-to-output-value>",
  "type": "<type-of-output-value>",
  "value": "<output-value-expression>",
  "copy": {
   "count": <number-of-iterations>,
   "input": <values-for-the-variable>
  }
 }
}
Element name
Required
Description
output-name
Yes
Name of the output value. Must be a valid JavaScript identifier.
condition
No
Boolean value that indicates whether this output value is returned. When true, the value is included in the output for the deployment. When false, the output value is skipped for this deployment. When not specified, the default value is true.
type
Yes
Type of the output value. Output values support the same types as template input parameters. If you specify securestring for the output type, the value isn't displayed in the deployment history and can't be retrieved from another template. To use a secret value in more than one template, store the secret in a Key Vault and reference the secret in the parameter file. For more information, see Use Azure Key Vault to pass secure parameter value during deployment.
value
No
Template language expression that is evaluated and returned as output value. Specify either value or copy.
copy
No
Used to return more than one value for an output. Specify value or copy. For more information, see Output iteration in ARM templates.
For examples of how to use outputs, see Outputs in ARM template.
In Bicep, see outputs.

Comments and metadata
You have a few options for adding comments and metadata to your template.
Comments
For inline comments, you can use either // or /* ... */. In Visual Studio Code, save the parameter files with comments as the JSON with comments (JSONC) file type, otherwise you get an error message saying "Comments not permitted in JSON".
Note
When using Azure CLI to deploy templates with comments, use version 2.3.0 or later, and specify the --handle-extended-json-format switch.
{
 "type": "Microsoft.Compute/virtualMachines",
 "apiVersion": "2023-03-01",
 "name": "[variables('vmName')]", // to customize name, change it in variables
 "location": "[parameters('location')]", //defaults to resource group location
 "dependsOn": [ /* storage account and network interface must be deployed first */
  "[resourceId('Microsoft.Storage/storageAccounts/', variables('storageAccountName'))]",
  "[resourceId('Microsoft.Network/networkInterfaces/', variables('nicName'))]"
 ],
In Visual Studio Code, the Azure Resource Manager Tools extension can automatically detect an ARM template and change the language mode. If you see Azure Resource Manager Template at the bottom-right corner of Visual Studio Code, you can use the inline comments. The inline comments are no longer marked as invalid.

In Bicep, see comments.
Metadata
You can add a metadata object almost anywhere in your template. Resource Manager ignores the object, but your JSON editor may warn you that the property isn't valid. In the object, define the properties you need.
{
 "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
 "contentVersion": "1.0.0.0",
 "metadata": {
  "comments": "This template was developed for demonstration purposes.",
  "author": "Example Name"
 },
For parameters, add a metadata object with a description property.
"parameters": {
 "adminUsername": {
  "type": "string",
  "metadata": {
   "description": "User name for the Virtual Machine."
  }
 },
When deploying the template through the portal, the text you provide in the description is automatically used as a tip for that parameter.

For resources, add a comments element or a metadata object. The following example shows both a comments element and a metadata object.
"resources": [
 {
  "type": "Microsoft.Storage/storageAccounts",
  "apiVersion": "2022-09-01",
  "name": "[format('{0}{1}', 'storage', uniqueString(resourceGroup().id))]",
  "comments": "Storage account used to store VM disks",
  "location": "[parameters('location')]",
  "metadata": {
   "comments": "These tags are needed for policy compliance."
  },
  "tags": {
   "Dept": "[parameters('deptName')]",
   "Environment": "[parameters('environment')]"
  },
  "sku": {
   "name": "Standard_LRS"
  },
  "kind": "Storage",
  "properties": {}
 }
]
For outputs, add a metadata object to the output value.
"outputs": {
 "hostname": {
  "type": "string",
  "value": "[reference(variables('publicIPAddressName')).dnsSettings.fqdn]",
  "metadata": {
   "comments": "Return the fully qualified domain name"
  }
 },
You can't add a metadata object to user-defined functions.
Multi-line strings
You can break a string into multiple lines. For example, see the location property and one of the comments in the following JSON example.
Note
To deploy templates with multi-line strings, use Azure PowerShell or Azure CLI. For CLI, use version 2.3.0 or later, and specify the --handle-extended-json-format switch.
Multi-line strings aren't supported when you deploy the template through the Azure portal, a DevOps pipeline, or the REST API.
{
 "type": "Microsoft.Compute/virtualMachines",
 "apiVersion": "2023-03-01",
 "name": "[variables('vmName')]", // to customize name, change it in variables
 "location": "[
  parameters('location')
  ]", //defaults to resource group location
 /*
  storage account and network interface
  must be deployed first
 */
 "dependsOn": [
  "[resourceId('Microsoft.Storage/storageAccounts/', variables('storageAccountName'))]",
  "[resourceId('Microsoft.Network/networkInterfaces/', variables('nicName'))]"
 ],
In Bicep, see multi-line strings.
languageVersion 2.0
Note
Using any languageVersion that ends in -experimental is not recommended in production environments because experimental functionality could be changed at any time.
Note
The current release of the Azure Resource Manager Tools extension for Visual Studio Code does not recognize the enhancements made in languageVersion 2.0.
To use languageVersion 2.0, add "languageVersion": "2.0" to your template:
{
 "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
 "languageVersion": "2.0",
 "contentVersion": "1.0.0.0",
 "resources": {
  "<name-of-the-resource>": {
   ...
  }
 }
}
The enhancements and changes that come with languageVersion 2.0:
	•	Use symbolic name in ARM JSON template. For more information, see Use symbolic name.
	•	Use symbolic name in resource copy loops. See Use symbolic name.
	•	Use symbolic name in dependsOn arrays. See DependsOn and Depend on resources in a loop.
	•	Use symbolic name instead of resource name in the reference function. See reference.
	•	A references() function that returns an array of objects representing a resource collection's runtime states. See references.
	•	Use the 'existing' resource property to declare existing resources for ARM to read rather than deploy a resource. See Declare existing resources.
	•	Create user-defined types. See Type definition.
	•	Additional aggregate type validation constraints to be used in parameters and outputs.
	•	The default value for the expressionEvaluationOptions property is inner. The value outer is blocked. See Expression evaluation scope in nested templates.
	•	The deployment function returns a limited subset of properties. See deployment.
	•	If Deployments resource is used in a symbolic-name deployment, use apiVersion 2020-09-01 or later.
	•	In resource definition, double-escaping values within an expression is no longer needed. See Escape characters.
Using any of following Bicep features automatically enables language version 2.0 code generation:
	•	user-defined types
	•	user-defined functions
	•	compile-time imports
	•	experimental features
Next steps
	•	To view complete templates for many different types of solutions, see the Azure Quickstart Templates.
	•	For details about the functions you can use from within a template, see ARM template functions.
	•	To combine several templates during deployment, see Using linked and nested templates when deploying Azure resources.
	•	For recommendations about creating templates, see ARM template best practices.
	•	For answers to common questions, see Frequently asked questions about ARM templates.




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 14>

————————————————————————

<doc 15>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
ARM template functions
	•	2025-02-12
In this article
This article describes all the functions you can use in an Azure Resource Manager template (ARM template). For information about using functions in your template, see template syntax.
To create your own functions, see User-defined functions.
Most functions work the same when deployed to a resource group, subscription, management group, or tenant. A few functions can't be used in all scopes. They're noted in the lists below.
Tip
We recommend Bicep because it offers the same capabilities as ARM templates and the syntax is easier to use. To learn more, see Bicep functions and Bicep operators.

Any function
The any function is available in Bicep to help resolve issues around data type warnings.

Array functions
Resource Manager provides several functions for working with arrays.
	•	array
	•	concat
	•	contains
	•	createArray
	•	empty
	•	first
	•	indexOf
	•	intersection
	•	last
	•	lastIndexOf
	•	length
	•	max
	•	min
	•	range
	•	skip
	•	take
	•	union
For Bicep files, use the array functions.

CIDR functions
The following functions are available for working with CIDR. All of these functions are in the sys namespace.
	•	parseCidr
	•	cidrSubnet
	•	cidrHost

Comparison functions
Resource Manager provides several functions for making comparisons in your templates.
	•	coalesce
	•	equals
	•	greater
	•	greaterOrEquals
	•	less
	•	lessOrEquals
For Bicep files, use the coalesce logical operator. For comparisons, use the comparison operators.

Date functions
Resource Manager provides the following functions for working with dates.
	•	dateTimeAdd
	•	dateTimeFromEpoch
	•	dateTimeToEpoch
	•	utcNow
For Bicep files, use the date functions.

Deployment value functions
Resource Manager provides the following functions for getting values from sections of the template and values related to the deployment:
	•	deployer
	•	deployment
	•	environment
	•	parameters
	•	variables
For Bicep files, use the deployment functions.

Lambda functions
Resource Manager provides the following functions for working with lambda expressions.
	•	filter
	•	groupBy
	•	map
	•	mapValues
	•	reduce
	•	sort
	•	toObject
For Bicep files, use the lambda functions.

Logical functions
Resource Manager provides the following functions for working with logical conditions:
	•	and
	•	bool
	•	false
	•	if
	•	not
	•	or
	•	true
For Bicep files, use the bool logical function. For other logical values, use logical operators.

Numeric functions
Resource Manager provides the following functions for working with integers:
	•	add
	•	copyIndex
	•	div
	•	float
	•	int
	•	min
	•	max
	•	mod
	•	mul
	•	sub
For Bicep files that use int, min, and max use numeric functions. For other numeric values, use numeric operators.

Object functions
Resource Manager provides several functions for working with objects.
	•	contains
	•	createObject
	•	empty
	•	intersection
	•	items
	•	json
	•	length
	•	null
	•	objectKeys
	•	shallowMerge
	•	union
For Bicep files, use the object functions.

Resource functions
Resource Manager provides the following functions for getting resource values:
	•	extensionResourceId
	•	listAccountSas
	•	listKeys
	•	listSecrets
	•	list*
	•	pickZones
	•	providers (deprecated)
	•	reference
	•	references
	•	resourceId - can be used at any scope, but the valid parameters change depending on the scope.
	•	subscriptionResourceId
	•	tenantResourceId
For Bicep files, use the resource functions.

Scope functions
Resource Manager provides the following functions for getting deployment scope values:
	•	managementGroup - can only be used in deployments to a management group.
	•	resourceGroup - can only be used in deployments to a resource group.
	•	subscription - can only be used in deployments to a resource group or subscription.
	•	tenant - can be used for deployments at any scope.
For Bicep files, use the scope functions.

String functions
Resource Manager provides the following functions for working with strings:
	•	base64
	•	base64ToJson
	•	base64ToString
	•	concat
	•	contains
	•	dataUri
	•	dataUriToString
	•	empty
	•	endsWith
	•	first
	•	format
	•	guid
	•	indexOf
	•	join
	•	json
	•	last
	•	lastIndexOf
	•	length
	•	newGuid
	•	padLeft
	•	replace
	•	skip
	•	split
	•	startsWith
	•	string
	•	substring
	•	take
	•	toLower
	•	toUpper
	•	trim
	•	uniqueString
	•	uri
	•	uriComponent
	•	uriComponentToString
For Bicep files, use the string functions.
Next steps
	•	For a description of the sections in an ARM template, see Understand the structure and syntax of ARM templates.
	•	To merge multiple templates, see Using linked and nested templates when deploying Azure resources.
	•	To iterate a specified number of times when creating a type of resource, see Resource iteration in ARM templates.
	•	To see how to deploy the template you've created, see Deploy resources with ARM templates and Azure PowerShell.




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 15>

————————————————————————

<doc 16>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Deploy resources with ARM templates and Azure PowerShell
	•	2025-04-28
In this article
This article explains how to use Azure PowerShell with Azure Resource Manager templates (ARM templates) to deploy your resources to Azure. If you aren't familiar with the concepts of deploying and managing your Azure solutions, see template deployment overview.
Tip
We recommend Bicep because it offers the same capabilities as ARM templates and the syntax is easier to use. To learn more, see Deploy resources with Bicep and Azure PowerShell.
Prerequisites
You need a template to deploy. If you don't already have one, download and save an example template from the Azure Quickstart templates repo. The local file name used in this article is C:\MyTemplates\azuredeploy.json.
You need to install Azure PowerShell and connect to Azure:
	•	Install Azure PowerShell cmdlets on your local computer. For more information, see Get started with Azure PowerShell.
	•	Connect to Azure by using Connect-AZAccount. If you have multiple Azure subscriptions, you might also need to run Set-AzContext. For more information, see Use multiple Azure subscriptions.
If you don't have PowerShell installed, you can use Azure Cloud Shell. For more information, see Deploy ARM templates from Azure Cloud Shell.
Required permissions
To deploy a Bicep file or ARM template, you need write access on the resources you're deploying and access to all operations on the Microsoft.Resources/deployments resource type. For example, to deploy a virtual machine, you need Microsoft.Compute/virtualMachines/write and Microsoft.Resources/deployments/* permissions. The what-if operation has the same permission requirements.
For a list of roles and permissions, see Azure built-in roles.
Deployment scope
You can target your deployment to a resource group, subscription, management group, or tenant. Depending on the scope of the deployment, you use different commands.
	•	To deploy to a resource group, use New-AzResourceGroupDeployment: New-AzResourceGroupDeployment -ResourceGroupName <resource-group-name> -TemplateFile <path-to-template>
	•	
	•	To deploy to a subscription, use New-AzSubscriptionDeployment which is an alias of the New-AzDeployment cmdlet: New-AzSubscriptionDeployment -Location <location> -TemplateFile <path-to-template>
	•	 For more information about subscription level deployments, see Create resource groups and resources at the subscription level.
	•	To deploy to a management group, use New-AzManagementGroupDeployment. New-AzManagementGroupDeployment -Location <location> -TemplateFile <path-to-template>
	•	 For more information about management group level deployments, see Create resources at the management group level.
	•	To deploy to a tenant, use New-AzTenantDeployment. New-AzTenantDeployment -Location <location> -TemplateFile <path-to-template>
	•	 For more information about tenant level deployments, see Create resources at the tenant level.
For every scope, the user deploying the template must have the required permissions to create resources.
Deployment name
When deploying an ARM template, you can give the deployment a name. This name can help you retrieve the deployment from the deployment history. If you don't provide a name for the deployment, the name of the template file is used. For example, if you deploy a template named azuredeploy.json and don't specify a deployment name, the deployment is named azuredeploy.
Every time you run a deployment, an entry is added to the resource group's deployment history with the deployment name. If you run another deployment and give it the same name, the earlier entry is replaced with the current deployment. If you want to maintain unique entries in the deployment history, give each deployment a unique name.
To create a unique name, you can assign a random number.
$suffix = Get-Random -Maximum 1000
$deploymentName = "ExampleDeployment" + $suffix
Or, add a date value.
$today=Get-Date -Format "MM-dd-yyyy"
$deploymentName="ExampleDeployment"+"$today"
If you run concurrent deployments to the same resource group with the same deployment name, only the last deployment is completed. Any deployments with the same name that haven't finished are replaced by the last deployment. For example, if you run a deployment named newStorage that deploys a storage account named storage1, and at the same time run another deployment named newStorage that deploys a storage account named storage2, you deploy only one storage account. The resulting storage account is named storage2.
However, if you run a deployment named newStorage that deploys a storage account named storage1, and immediately after it completes you run another deployment named newStorage that deploys a storage account named storage2, then you have two storage accounts. One is named storage1, and the other is named storage2. But, you only have one entry in the deployment history.
When you specify a unique name for each deployment, you can run them concurrently without conflict. If you run a deployment named newStorage1 that deploys a storage account named storage1, and at the same time run another deployment named newStorage2 that deploys a storage account named storage2, then you have two storage accounts and two entries in the deployment history.
To avoid conflicts with concurrent deployments and to ensure unique entries in the deployment history, give each deployment a unique name.
Deploy local template
You can deploy a template from your local machine or one that is stored externally. This section describes deploying a local template.
If you're deploying to a resource group that doesn't exist, create the resource group. The name of the resource group can only include alphanumeric characters, periods, underscores, hyphens, and parenthesis. It can be up to 90 characters. The name can't end in a period.
New-AzResourceGroup -Name ExampleGroup -Location "Central US"
To deploy a local template, use the -TemplateFile parameter in the deployment command. The following example also shows how to set a parameter value that comes from the template.
New-AzResourceGroupDeployment `
 -Name ExampleDeployment `
 -ResourceGroupName ExampleGroup `
 -TemplateFile <path-to-template>
The deployment can take several minutes to complete.
Deploy remote template
Instead of storing ARM templates on your local machine, you may prefer to store them in an external location. You can store templates in a source control repository (such as GitHub). Or, you can store them in an Azure storage account for shared access in your organization.
Note
To deploy a template or reference a linked template that is stored in a private GitHub repo, see a custom solution documented in Creating a Custom and Secure Azure Portal Offering. You can create an Azure function that pulls the GitHub token out of Azure Key Vault.
If you're deploying to a resource group that doesn't exist, create the resource group. The name of the resource group can only include alphanumeric characters, periods, underscores, hyphens, and parenthesis. It can be up to 90 characters. The name can't end in a period.
New-AzResourceGroup -Name ExampleGroup -Location "Central US"
To deploy an external template, use the -TemplateUri parameter.
New-AzResourceGroupDeployment `
 -Name remoteTemplateDeployment `
 -ResourceGroupName ExampleGroup `
 -TemplateUri https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/quickstarts/microsoft.storage/storage-account-create/azuredeploy.json
The preceding example requires a publicly accessible URI for the template, which works for most scenarios because your template shouldn't include sensitive data. If you need to specify sensitive data (like an admin password), pass that value as a secure parameter. However, if you want to manage access to the template, consider using template specs.
To deploy remote linked templates with relative path that are stored in a storage account, use QueryString to specify the SAS token:
New-AzResourceGroupDeployment `
 -Name linkedTemplateWithRelativePath `
 -ResourceGroupName "myResourceGroup" `
 -TemplateUri "https://stage20210126.blob.core.windows.net/template-staging/mainTemplate.json" `
 -QueryString "$sasToken"
For more information, see Use relative path for linked templates.
Deploy template spec
Instead of deploying a local or remote template, you can create a template spec. The template spec is a resource in your Azure subscription that contains an ARM template. It makes it easy to securely share the template with users in your organization. You use Azure role-based access control (Azure RBAC) to grant access to the template spec. This feature is currently in preview.
The following examples show how to create and deploy a template spec.
First, create the template spec by providing the ARM template.
New-AzTemplateSpec `
 -Name storageSpec `
 -Version 1.0 `
 -ResourceGroupName templateSpecsRg `
 -Location westus2 `
 -TemplateJsonFile ./mainTemplate.json
Then, get the ID for template spec and deploy it.
$id = (Get-AzTemplateSpec -Name storageSpec -ResourceGroupName templateSpecsRg -Version 1.0).Versions.Id

New-AzResourceGroupDeployment `
 -ResourceGroupName demoRG `
 -TemplateSpecId $id
For more information, see Azure Resource Manager template specs.
Preview changes
Before deploying your template, you can preview the changes the template will make to your environment. Use the what-if operation to verify that the template makes the changes that you expect. What-if also validates the template for errors.
Pass parameter values
To pass parameter values, you can use either inline parameters or a parameters file. The parameter file can be either a Bicep parameters file or a JSON parameters file.
Inline parameters
To pass inline parameters, provide the names of the parameter with the New-AzResourceGroupDeployment command. For example, to pass a string and array to a template, use:
$arrayParam = "value1", "value2"
New-AzResourceGroupDeployment -ResourceGroupName testgroup `
 -TemplateFile <path-to-template> `
 -exampleString "inline string" `
 -exampleArray $arrayParam
You can use the TemplateParameterObject parameter to pass through a hashtable that contains the parameters for the template.
$params = @{
 exampleString = "inline string"
 exampleArray = "value1", "value2"
}

New-AzResourceGroupDeployment -ResourceGroupName testgroup `
 -TemplateFile <path-to-bicep> `
 -TemplateParameterObject $params
You can also get the contents of file and provide that content as an inline parameter.
$arrayParam = "value1", "value2"
New-AzResourceGroupDeployment -ResourceGroupName testgroup `
 -TemplateFile <path-to-template> `
 -exampleString $(Get-Content -Path c:\MyTemplates\stringcontent.txt -Raw) `
 -exampleArray $arrayParam
Getting a parameter value from a file is helpful when you need to provide configuration values. For example, you can provide cloud-init values for a Linux virtual machine.
If you need to pass in an array of objects, create hash tables in PowerShell and add them to an array. Pass that array as a parameter during deployment.
$hash1 = @{ Name = "firstSubnet"; AddressPrefix = "10.0.0.0/24"}
$hash2 = @{ Name = "secondSubnet"; AddressPrefix = "10.0.1.0/24"}
$subnetArray = $hash1, $hash2
New-AzResourceGroupDeployment -ResourceGroupName testgroup `
 -TemplateFile <path-to-template> `
 -exampleArray $subnetArray
JSON parameter files
Rather than passing parameters as inline values in your script, you may find it easier to use a JSON file that contains the parameter values. The parameter file can be a local file or an external file with an accessible URI.
For more information about the parameter file, see Create Resource Manager parameter file.
To pass a local parameter file, use the TemplateParameterFile parameter:
New-AzResourceGroupDeployment `
 -Name ExampleDeployment `
 -ResourceGroupName ExampleResourceGroup `
 -TemplateFile <path-to-template> `
 -TemplateParameterFile c:\MyTemplates\storage.parameters.json
To pass an external parameter file, use the TemplateParameterUri parameter:
New-AzResourceGroupDeployment `
 -Name ExampleDeployment `
 -ResourceGroupName ExampleResourceGroup `
 -TemplateUri https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/quickstarts/microsoft.storage/storage-account-create/azuredeploy.json `
 -TemplateParameterUri https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/quickstarts/microsoft.storage/storage-account-create/azuredeploy.parameters.json
For more information about parameters file, see Create Resource Manager parameters file.
Bicep parameter files
With Azure PowerShell version 10.4.0 or later, and Bicep CLI version 0.22.6 or later, you can deploy an ARM template file by utilizing a Bicep parameter file. With the using statement within the Bicep parameters file, there is no need to provide the -TemplateFile switch when specifying a Bicep parameter file for the -TemplateParameterFile switch.
The following example shows a parameters file named storage.bicepparam. The file is in the same directory where the command is run.
New-AzResourceGroupDeployment `
 -Name ExampleDeployment `
 -ResourceGroupName ExampleResourceGroup `
 -TemplateParameterFile storage.bicepparam
For more information about Bicep parameters file, see Bicep parameters file.
Next steps
	•	To roll back to a successful deployment when you get an error, see Rollback on error to successful deployment.
	•	To specify how to handle resources that exist in the resource group but aren't defined in the template, see Azure Resource Manager deployment modes.
	•	To understand how to define parameters in your template, see Understand the structure and syntax of ARM templates.
	•	For information about deploying a template that requires a SAS token, see Deploy private ARM template with SAS token.




Feedback
Was this page helpful?
Yes No
Provide product feedback | Get help at Microsoft Q&A


In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 16>

————————————————————————

<doc 17>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Customize app manifest for Microsoft Visual Studio
	•	2025-05-19
In this article
The app manifest (previously called Teams app manifest) describes how your app integrates into Microsoft Teams and is shared between local and remote environments. The default app manifest file is available at the appPackage/manifest.json file and the environment variables available from the env/.env.{env} file.
The app manifest file contains some environment variables with the ${{XX_XX}} format. You can define your own environment variables and add placeholders in the manifest.json file. The following are the .env and .json file examples:
TEAMS_APP_DESCRIPTION=This is an amazing app
{
  "$schema": "https://developer.microsoft.com/en-us/json-schemas/teams/v1.16/MicrosoftTeams.schema.json",
  "manifestVersion": "1.16",
  "description": {
    "short": "${{TEAMS_APP_DESCRIPTION}}",
    "full": "Full description of tab0418"
  },
}
Preview app manifest file
You can preview the app manifest file either For Local or For Azure. To preview the app manifest file, follow these steps:
	1	Select Project > Microsoft 365 Agents Toolkit.
	2	Select Select Microsoft 365 Account or Provision in the Cloud... to generate environment variables for local or remote Teams app. 
	3	Upload the Zip App Package in the following ways:
	1	Select Project > Microsoft 365 Agents Toolkit > Zip App Package and then select either For Local or For Azure 
	2	From Solution Explorer, right-click on M365Agent (in this scenario the project name is M365Agent). Go to Microsoft 365 Agents Toolkit > Zip App Package and then select either For Local or For Azure. 
	4	Microsoft 365 Agents Toolkit (previously known as Teams Toolkit) generates the zip app package.
	5	Under appPackage folder, right-click on the manifest.json file.
	6	Select Preview Manifest File.
	7	Select either For Local or For Azure. 
You can preview app manifest file under appPackage/build in Visual Studio.
I ran into an issue
Sync local changes to Developer Portal
After you've previewed the app manifest file in Visual Studio, you can sync the local changes to Developer Portal. To sync changes to Developer Portal follow these steps:
	1	Select Project.
	2	Select Microsoft 365 Agents Toolkit.
	3	Select Update Manifest in Developer Portal.

You can also sync the local changes to Developer Portal from Solution Explorer:
	1	Right-click on MyTeamsApp14.
	2	Select Microsoft 365 Agents Toolkit.
	3	Select Update Manifest in Developer Portal

The changes are updated to Developer Portal.
Tip
If you want to make any manual updates that can be overwritten in Developer Portal, from the Warning dialog box select Overwrite and update.

When you create a Teams command bot using Visual Studio, two app IDs are registered in Microsoft Entra ID. You can identify the app IDs in Developer Portal as Application (client) ID under Basic information and existing bot ID under App features.


I ran into an issue
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	App manifest schema
	•	Developer Portal for Teams
	•	Public developer preview for Microsoft Teams
	•	Provision cloud resources using Visual Studio
	•	Deploy Microsoft Teams app to the cloud using Microsoft Visual Studio





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 17>

————————————————————————

<doc 18>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
App manifest
	•	2025-05-29
In this article
The app manifest (previously called Teams app manifest) describes how your app integrates into the Microsoft Teams product. Your app manifest must conform to the schema hosted at https://developer.microsoft.com/json-schemas/teams/v1.22/MicrosoftTeams.schema.json. Previous versions 1.0, 1.1,...,1.21, and the current version is 1.22 are each supported (using "v1.x" in the URL). Version 1.18 is not available. For more information on the changes made in each version, see app manifest change log and for previous versions, see app manifest versions.
The following table lists TeamsJS version and app manifest versions as per different app scenarios:
App type
TeamsJS version
App manifest version
Next steps
Teams apps extended across Outlook and Microsoft 365
TeamsJS v2.19.0 or later
v1.13 or later
Extend a Teams app to run across Microsoft 365 or Create a new Microsoft 365 app
Existing Teams-only apps
Update to TeamsJS v2.19.0 or later*
v1.12 or later**
Understand TeamsJS backwards compatibility and Update to TeamsJS v2.0
New Teams-only apps
TeamsJS v2.19.0 or later
v1.12 or later**
Create a new Teams app using Microsoft 365 Agents Toolkit
*Use the latest TeamsJS to take advantage of the latest improvements and new feature support including Teams-only apps. No new features or improvements will be added to TeamsJS v1.13.0. New app submissions and updates now require TeamsJS v2.19.0 or later. For more information, see TeamsJS library.
**When upgrading your Teams personal tab or message extension app to manifest version 1.13 or later, it becomes available across Microsoft 365 hosts by default. To avoid partial loading in unsupported hosts and ensure a consistent user experience, define runtime requirements in the manifest to control where and how your app appears. For more information, see Specify Microsoft 365 host runtime requirements in app manifest.
Note
If your Teams app is using the app manifest version 1.13 or later, ensure that your app meets the criteria to extend your app to run across Microsoft 365 or Outlook.
The following is the sample app manifest schema:
Sample app manifest
{
  "$schema": "https://developer.microsoft.com/json-schemas/teams/v1.22/MicrosoftTeams.schema.json",
  "manifestVersion": "1.22",
  "version": "1.0.0",
  "id": "%MICROSOFT-APP-ID%",
  "localizationInfo": {
    "defaultLanguageTag": "en",
    "defaultLanguageFile": "en.json",
    "additionalLanguages": [
      {
        "languageTag": "es",
        "file": "es.json"
      }
    ]
  },
  "developer": {
    "name": "Publisher Name",
    "websiteUrl": "https://example.com/",
    "privacyUrl": "https://example.com/privacy",
    "termsOfUseUrl": "https://example.com/app-tos",
    "mpnId": "1234567890"
  },
  "name": {
    "short": "Name of your app (<=30 chars)",
    "full": "Full name of app, if longer than 30 characters (<=100 chars)"
  },
  "description": {
    "short": "Short description of your app (<= 80 chars)",
    "full": "Full description of your app (<= 4000 chars)"
  },
  "icons": {
    "outline": "A relative path to a transparent .png icon — 32px X 32px",
    "color": "A relative path to a full color .png icon — 192px X 192px"
  },
  "accentColor": "A valid HTML color code.",
  "elementRelationshipSet": {
   "oneWayDependencies" : [
    {
     "element" : {
      "name" : "composeExtensions",
      "id" : "composeExtension-id",
      "commandIds": ["exampleCmd1", "exampleCmd2"]
     },
     "dependsOn" : [
       {"name" : "bots", "id" : "bot-id"}
     ]
    }
   ],
   "mutualDependencies" : [
    [
        {"name" : "bots", "id" : "bot-id"}, 
        {"name" : "staticTabs", "id" : "staticTab-id"},
        {"name" : "composeExtensions", "id" : "composeExtension-id"},
        {"name" : "configurableTabs", "id": "configurableTab-id"}
    ]
   ],
  },
  "copilotAgents": {
    "declarativeAgents": [
      {
        "id": "agent1",
        "file": "declarativeAgent1.json"
      }
    ]
  },
  "configurableTabs": [
    {
      "id": "configurableTab-id",
      "configurationUrl": "https://contoso.com/teamstab/configure",
      "scopes": [
        "team",
        "groupChat"
      ],
      "canUpdateConfiguration": true,
      "context": [
        "channelTab",
        "privateChatTab",
        "meetingChatTab",
        "meetingDetailsTab",
        "meetingSidePanel",
        "meetingStage"
      ],
      "sharePointPreviewImage": "Relative path to a tab preview image for use in SharePoint — 1024px X 768",
      "supportedSharePointHosts": [
        "sharePointFullPage",
        "sharePointWebPart"
      ]
    }
  ],
  "staticTabs": [
    {
      "entityId": "idForPage",
      "scopes": [
        "personal"
      ],
      "context": [
        "personalTab",
        "channelTab"
      ],
      "name": "Display name of tab",
      "contentUrl": "https://contoso.com/content (displayed in Teams canvas)",
      "websiteUrl": "https://contoso.com/content (displayed in web browser)",
      "searchUrl": "https://contoso.com/content (displayed in web browser)",
      "requirementSet": {
        "hostMustSupportFunctionalities": [
         {"name": "dialogUrl"},
         {"name": "dialogUrlBot"}
        ]
      }
    }
  ],
  "supportedChannelTypes": [
    "sharedChannels",
    "privateChannels"
  ],
  "bots": [
    {
      "botId": "%MICROSOFT-APP-ID-REGISTERED-WITH-BOT-FRAMEWORK%",
      "scopes": [
        "team",
        "personal",
        "groupChat"
      ],
      "needsChannelSelector": false,
      "isNotificationOnly": false,
      "supportsFiles": true,
      "supportsCalling": false,
      "supportsVideo": true,
      "commandLists": [
        {
          "scopes": [
            "team",
            "groupChat"
          ],
          "commands": [
            {
              "title": "Command 1",
              "description": "Description of Command 1"
            },
            {
              "title": "Command 2",
              "description": "Description of Command 2"
            }
          ]
        },
        {
          "scopes": [
            "personal",
            "groupChat"
          ],
          "commands": [
            {
              "title": "Personal command 1",
              "description": "Description of Personal command 1"
            },
            {
              "title": "Personal command N",
              "description": "Description of Personal command N"
            }
          ]
        }
      ]
    }
  ],
  "connectors": [
    {
      "connectorId": "GUID-FROM-CONNECTOR-DEV-PORTAL%",
      "scopes": [
        "team"
      ],
      "configurationUrl": "https://contoso.com/teamsconnector/configure"
    }
  ],
  "composeExtensions": [
    {
      "id": "composeExtension-id",
      "canUpdateConfiguration": true,
      "botId": "%MICROSOFT-APP-ID-REGISTERED-WITH-BOT-FRAMEWORK%",
      "commands": [
        {
          "id": "exampleCmd1",
          "title": "Example Command",
          "type": "query",
          "context": [
            "compose",
            "commandBox"
          ],
          "description": "Command Description; e.g., Search on the web",
          "initialRun": true,
          "fetchTask": false,
          "parameters": [
            {
              "name": "keyword",
              "title": "Search keywords",
              "inputType": "choiceset",
              "description": "Enter the keywords to search for",
              "value": "Initial value for the parameter",
              "choices": [
                {
                  "title": "Title of the choice",
                  "value": "Value of the choice"
                }
              ]
            }
          ]
        },
        {
          "id": "exampleCmd2",
          "title": "Example Command 2",
          "type": "action",
          "context": [
            "message"
          ],
          "description": "Command Description; e.g., Add a customer",
          "initialRun": true,
          "fetchTask": false ,
          "parameters": [
            {
              "name": "custinfo",
              "title": "Customer name",
              "description": "Enter a customer name",
              "inputType": "text"
            }
          ]
        },
        {
          "id": "exampleCmd3",
          "title": "Example Command 3",
          "type": "action",
          "context": [
            "compose",
            "commandBox",
            "message"
          ],
          "description": "Command Description; e.g., Add a customer",
          "fetchTask": false,
          "taskInfo": {
            "title": "Initial dialog title",
            "width": "Dialog width",
            "height": "Dialog height",
            "url": "Initial webview URL"
          }
        }
      ],
      "messageHandlers": [
        {
          "type": "link",
          "value": {
            "domains": [
              "mysite.someplace.com",
              "othersite.someplace.com"
            ],
            "supportsAnonymizedPayloads": false
          }
        }
      ],
      "requirementSet": {
        "hostMustSupportFunctionalities": [
         {"name": "dialogUrl"},
         {"name": "dialogUrlBot"}
        ]
      }
    }
  ],
  "permissions": [
    "identity",
    "messageTeamMembers"
  ],
  "devicePermissions": [
    "geolocation",
    "media",
    "notifications",
    "midi",
    "openExternal"
  ],
  "validDomains": [
    "contoso.com",
    "mysite.someplace.com",
    "othersite.someplace.com"
  ],
  "webApplicationInfo": {
    "id": "AAD App ID",
    "resource": "Resource URL for acquiring auth token for SSO"
  },
  "authorization": {
    "permissions": {
      "resourceSpecific": [
        {
          "type": "Application",
          "name": "ChannelSettings.Read.Group"
        },
        {
          "type": "Delegated",
          "name": "ChannelMeetingParticipant.Read.Group"
        }
      ]
    }
  },
  "showLoadingIndicator": false,
  "isFullScreen": false,
  "activities": {
    "activityTypes": [
      {
        "type": "taskCreated",
        "description": "Task created activity",
        "templateText": "<team member> created task <taskId> for you"
      },
      {
        "type": "userMention",
        "description": "Personal mention activity",
        "templateText": "<team member> mentioned you"
      }
    ]
  },
  "defaultBlockUntilAdminAction": true,
  "publisherDocsUrl": "https://example.com/app-info",
  "defaultInstallScope": "meetings",
  "defaultGroupCapability": {
    "meetings": "tab",
    "team": "bot",
    "groupchat": "bot"
  },
  "configurableProperties": [
    "name",
    "shortDescription",
    "longDescription",
    "smallImageUrl",
    "largeImageUrl",
    "accentColor",
    "developerUrl",
    "privacyUrl",
    "termsOfUseUrl"
  ],
  "subscriptionOffer": {
    "offerId": "publisherId.offerId"
  },
  "meetingExtensionDefinition": {
    "scenes": [
      {
        "id": "9082c811-7e6a-4174-8173-6ccd57d377e6",
        "name": "Getting started sample",
        "file": "scenes/sceneMetadata.json",
        "preview": "scenes/scenePreview.png",
        "maxAudience": 15,
        "seatsReservedForOrganizersOrPresenters": 0
      },
      {
        "id": "afeaed22-f89b-48e1-98b4-46a514344e4a",
        "name": "Sample-1",
        "file": "scenes/sceneMetadata.json",
        "preview": "scenes/scenePreview.png",
        "maxAudience": 15,
        "seatsReservedForOrganizersOrPresenters": 3
      }
    ]
  }
}
The schema defines the following properties:
$schema
Optional, but recommended – String
The https:// URL referencing the JSON Schema for the app manifest.
manifestVersion
Required – String
The version of the app manifest schema that this manifest is using. Use 1.13 to enable Teams app support in Outlook and Microsoft 365 app; use 1.12 (or earlier) for Teams-only apps.
version
Required – String
The version of a specific app. When you update something in your app manifest, the version must be incremented too. This way, when the new app manifest is installed, it overwrites the existing one and the user receives the new functionality. When this app was submitted to the Microsoft Teams Store, the new app manifest must be resubmitted and revalidated. The app users receive the new updated app manifest automatically within few hours after the app manifest is approved.
If the app requests for permissions change, the users are prompted to upgrade and reconsent to the app.
This version string must follow the semver standard (MAJOR.MINOR.PATCH).
Note
If your app includes an Office Add-in, each segment of the version string is limited to a maximum of five digits. The semver standard's pre-release and metadata version string extensions aren't supported.
ID
Required – Microsoft app ID
The ID is a unique Microsoft-generated identifier for the app. The format of the ID is GUID. You have an ID if your bot is registered through the Microsoft Bot Framework. You have an ID if your tab's web app already signs in with Microsoft. You must enter the ID here. Otherwise, you must generate a new ID at the Microsoft Application Registration Portal. Use the same ID if you add a bot.
The ID stored in Teams admin center is the External App ID and it's visible as ExternalID on the traces.
Note
If you are submitting an update to your existing app in AppSource, the ID in your app manifest must not be modified.
developer
Required – Object
Specifies information about your company. For apps submitted to the Teams Store, these values must match the information in your Teams Store listing. For more information, see the Teams Store publishing guidelines. Developer name helps improve your app discoverability in the Teams Store.
Name
Type
Maximum size
Required
Description
name
String
32 characters
✔️
The display name for the developer.
websiteUrl
String
2048 characters
✔️
The https:// URL to the developer's website. This link must take users to your company or product-specific landing page.
privacyUrl
String
2048 characters
✔️
The https:// URL to the developer's privacy policy.
termsOfUseUrl
String
2048 characters
✔️
The https:// URL to the developer's terms of use.
mpnId
String
10 characters

Optional The Microsoft Cloud Partner Program ID (formerly known as Microsoft Partner Network (MPN) ID) that identifies the partner organization building the app.
name
Required – Object
The name of your app experience, displayed to users in the Teams experience. For apps submitted to AppSource, these values must match the information in your AppSource entry. The values of short and full must be different. App name helps improve your app discoverability in the Teams Store.
Name
Type
Maximum size
Required
Description
short
String
30 characters
✔️
The short display name for the app. Use short property where the space is limited, such as the app header.
full
String
100 characters

The full name of the app, used if the full app name exceeds 30 characters. Use full property where there's more space, such as the app catalog or the app details page.
Note
	•	In the app manifest v1.17 or later the full property is required and for app manifest v1.16 or earlier it isn't required.
	•	The short property is used across all UI surfaces.
description
Required – Object
Describes your app to users. For apps submitted to AppSource, these values must match the information in your AppSource entry. App description helps improve your app discoverability in the Teams Store.
Ensure that your description describes your experience and helps potential customers understand what your experience does. You must note in the full description, if an external account is required for use. The values of short and full must be different. Your short description can't be repeated within the long description and must not include any other app name.
Name
Type
Maximum size
Required
Description
short
String
80 characters
✔️
A short description of your app experience, used when space is limited.
full
String
4000 characters
✔️
The full description of your app.
localizationInfo
Optional – Object
Allows the specification of a default language, and pointers to additional language files. See localization.
Name
Type
Maximum size
Required
Description
defaultLanguageTag
String

✔️
The language tag for the strings in this top-level app manifest file. Default is en-us.
defaultLanguageFile
String
2048 characters

A relative file path to the .json file that contains the strings. If unspecified, strings are taken directly from the app manifest file. A default language file is required for agents that support multiple languages.
localizationInfo.additionalLanguages
An array of objects, each with the following properties to specify additional language translations.
Name
Type
Maximum size
Required
Description
languageTag
String

✔️
The language tag of the strings in the provided file. For example, es
file
String
2048 characters
✔️
A relative file path to the .json file that contains the translated strings.
icons
Required – Object
Icons used within the Teams app. The icon files must be included as part of the upload package. For more information, see Icons.
Name
Type
Maximum size
Required
Description
outline
String
32 x 32 pixels
✔️
A relative file path to a transparent 32x32 PNG outline icon. The border color must be white.
color
String
192 x 192 pixels
✔️
A relative file path to a full color 192x192 PNG icon.
color 32x32
String
32 x 32 pixels

A relative file path to a full color PNG icon with transparent background. Size 32x32.
accentColor
Required – HTML Hex color code
A color to use and as a background for your color icons.
The value must be a valid HTML color code starting with '#', for example #4464ee. For more information, see accentColor.
elementRelationshipSet
Optional – Object
Describes relationships between individual app capabilities, including staticTabs, configurableTabs, composeExtensions, and bots. It's used to specify runtime dependencies to ensure that the app launches only in applicable Microsoft 365 hosts, such as Teams, Outlook, and the Microsoft 365 (Office) app. For more information, see how to specify runtime requirements in your app manifest.
Name
Type
Maximum size
Required
Description
oneWayDependencies
Array
✔️

Defines one or more unidirectional dependency relationships among app components. Each relationship is represented by a oneWayDependency object with a dependent element and a dependsOn element object.
mutualDependencies
Array

✔️
Defines one or more mutual dependency relationships among app capabilities. Each relationship is represented by a mutualDependency array of element objects.
element
Optional – Object
Describes an app capability (element) in an elementRelationshipSet.
Name
Type
Maximum size
Required
Description
name
String enum

✔️
The type of app capability. Supported values: bots, staticTabs, composeExtensions, configurableTabs
id
String

✔️
If there are multiple instances of a bot, tab, or message extension, this property defines a specific instance of the capability. It maps to botId for bots, entityId for static tabs, and id for configurable tabs and message extensions.
commandIds
Array of strings


List of one or more message extension commands that are dependent on the specified dependsOn capability. Use only for message extensions.
elementRelationshipSet.oneWayDependency
Optional – Object
Describes the unidirectional dependency of one app capability (X) to another (Y). If a Microsoft 365 runtime host doesn't support a required capability (Y), the dependent capability (X) won't load or surface to the user.
Name
Type
Maximum size
Required
Description
element
Object

✔️
Represents an individual app capability (represented by element) that has a one-way runtime dependency on another capability being loaded.
dependsOn
Array

✔️
Defines one or more app capabilities (each represented by element) required for the specified element to load.
elementRelationshipSet.mutualDependencies
Optional – Array of arrays (each containing two or more element objects)
Describes a set of mutual dependencies between two or more app capabilities. A Microsoft 365 runtime host must support all required capabilities for any of those capabilities to be available for users in that host.
copilotAgents
Optional – Object
Defines one or more agents to Microsoft 365 Copilot. Declarative agents are customizations of Microsoft 365 Copilot that run on the same orchestrator and foundation models (formerly known as declarativeCopilots). Custom engine agents are conversational Teams bots that use custom AI language models and orchestration, yet are selectable (along with installed declarative agents) as Agents from the Microsoft 365 Copilot side panel.
Name
Type
Maximum size
Required
Description
declarativeAgents
Array of objects
1

Array of objects that each define a declarative agent.
customEngineAgents
Array of objects
1

Array of objects that each define a custom engine agent.
Note
The copilotAgents object must contain either declarativeAgents or customEngineAgents, but not both agents at the same time.
declarativeAgents
Represents a customization of Microsoft 365 Copilot, as defined by its manifest file.
Name
Type
Maximum size
Required
Description
id
String

✔️
Unique identifier for the agent. When using Microsoft Copilot Studio to build agents, this is auto-generated. Otherwise, manually assign the value according to your own conventions or preference.
file
String
2048 characters
✔️
Relative file path within the app package to the declarative agent manifest file.
customEngineAgents
Represents a conversational Teams bot that uses custom AI language models and orchestration, surfaced as an agent in the Microsoft 365 Copilot UI.
Name
Type
Maximum size
Required
Description
id
String

✔️
Unique (bot) identifier for the custom engine agent. Must match the id specified in the bots section of the manifest and be of personal scope.
type
String

✔️
Type of the custom engine agent. Supported value: bot
disclaimer.text
String
500
✔️
The message shown to users before they interact with this application.
configurableTabs
Optional – Array
Used when your app experience has a team channel tab experience that requires extra configuration before it's added. Configurable tabs are supported only in the team and groupChat scopes and you can configure the same tabs multiple times. However, you can define it in the app manifest only once.
Name
Type
Maximum size
Required
Description
id
String
64

Unique identifier for configurable tab. Used when defining one-way and mutual app capability dependencies under elementRelationshipSet.
configurationUrl
String
2048 characters
✔️
The https:// URL to use when configuring the tab.
scopes
Array of enums
2
✔️
The configurable tabs support only the team and groupChat scopes.
canUpdateConfiguration
Boolean


A value indicating whether an instance of the tab's configuration can be updated by the user after creation. 
Default value: true
meetingSurfaces
Array of enums
2

The set of meetingSurfaceItem scopes where a tab is supported. 
Default values: sidePanel, stage
context
Array of enums
7

The set of contextItem scopes where a tab is supported. Accepted value: [personalTab, channelTab, privateChatTab, meetingChatTab, meetingDetailsTab, meetingSidePanel, meetingStage].
sharePointPreviewImage
String
2048 characters

A relative file path to a tab preview image for use in SharePoint. Size 1024x768.
supportedSharePointHosts
Array of enums
2

Defines how your tab is made available in SharePoint. Options are sharePointFullPage and sharePointWebPart.
staticTabs
Optional – Array
Defines a set of tabs that can be pinned by default, without the user adding them manually. Static tabs declared in personal scope are always pinned to the app's personal experience. However, the pinned tabs can be reordered by adding the details of the tab in the same desired order. For more information, see reorder static personal tabs.
This property also enables you to set the default landing capability for an app supporting both tab and bot capabilities in personal scope. For more information, see configure default landing capability.
This item is an array (maximum of 16 elements) with all elements of the type object. This block is required only for solutions that provide a static tab solution.
Name
Type
Maximum size
Required
Description
entityId
String
64 characters
✔️
A unique identifier for the entity that the tab displays.
name
String
128 characters

The display name of the tab.
contentUrl
String
2048 characters

The https:// URL that points to the entity UI to be displayed in the Teams canvas.
contentBotId
String
128 characters

The Microsoft app ID specified for the bot in the Bot Framework portal.
websiteUrl
String
2048 characters

The https:// URL to point to if a user opts to view in a browser.
searchUrl
String
2048 characters

The https:// URL to point to for a user's search queries.
scopes
Array of enums
3
✔️
Specifies whether the tab offers an experience in the context of a channel in a team, or an experience scoped to an individual user or group chat. The static tabs support personal scope only.
context
Array of enums
8

The set of contextItem contexts where a tab is supported. 
Accepted values: personalTab, channelTab, privateChatTab, meetingChatTab, meetingDetailsTab, meetingStage, meetingSidepanel, teamLevelApp. 
Default values: personalTab, channelTab, privateChatTab, meetingChatTab, meetingDetailsTab.
requirementSet
Object


Runtime requirements for the tab to function properly in the Microsoft 365 host application. If one or more of the requirements aren't supported by the runtime host, the host won't load the tab.
Note
	•	The contentBotId property isn't supported in apps that are verified and published on AppSource.
	•	The groupChat and team scopes are supported only in public developer preview.
	•	The teamLevelApp context is dedicated only for Education tenants.
	•	The searchUrl feature is not available for the third-party developers.
	•	If your tabs require context-dependent information to display relevant content or for initiating an authentication flow, For more information, see Get context for your Microsoft Teams tab.
staticTabs.requirementSet
Optional – Object
Name
Type
Maximum size
Required
Description
requirementSet.hostMustSupportFunctionalities
Array of objects

✔️
Specifies one or more runtime capabilities the tab requires to function properly. Supported values: dialogUrl, dialogUrlBot, dialogAdaptiveCard, dialogAdaptiveCardBot. For more information, see how to specify runtime requirements in your app manifest.
bots
Optional – Array
Defines a bot solution, along with optional information such as default command properties.
The item is an array (maximum of only one element— only one bot is allowed per app) with all elements of the type object. This block is required only for solutions that provide a bot experience.
Name
Type
Maximum size
Required
Description
botId
String

✔️
The unique Microsoft app ID for the bot as registered with the Bot Framework. The ID can be the same as the overall app ID.
scopes
Array of enums
3
✔️
Specifies whether the bot offers an experience in the context of a channel in a team, in a group chat (groupChat), or an experience scoped to an individual user alone (personal). These options are non-exclusive.
needsChannelSelector
Boolean


Describes whether or not the bot uses a user hint to add the bot to a specific channel. 
Default value: false
isNotificationOnly
Boolean


Indicates whether a bot is a one-way, notification-only bot, as opposed to a conversational bot. 
Default value: false
supportsFiles
Boolean


Indicates whether the bot supports the ability to upload/download files in personal chat. 
Default value: false
supportsCalling
Boolean


A value indicating where a bot supports audio calling. IMPORTANT: This property is experimental. Experimental properties might be incomplete and might undergo changes before they're fully available. The property is provided for testing and exploration purposes only and must not be used in production applications. 
Default value: false
supportsVideo
Boolean


A value indicating where a bot supports video calling. IMPORTANT: This property is experimental. Experimental properties might be incomplete and might undergo changes before they're fully available. The property is provided for testing and exploration purposes only and must not be used in production applications. 
Default value: false
requirementSet
Object


Runtime requirements for the bot to function properly in the Microsoft 365 host application. If one or more of the requirements aren't supported by the runtime host, the host won't load the bot.
bots.configuration
Optional – Object
Name
Type
Maximum size
Required
Description
team.fetchTask
Boolean

✔️
A boolean value that indicates if it should fetch dialog (referred as task module in TeamsJS v1.x) dynamically. 
Default value: false
team.taskInfo
Object

✔️
The dialog to preload when you use a bot
team.taskInfo.title
String
64 characters
✔️
Initial dialog title.
team.taskInfo.width
String
16 characters

The dialog width is either a number in pixels or default layout such as large, medium, or small.
team.taskInfo.height
String
16 characters

The dialog height is either a number in pixels or default layout such as large, medium, or small.
team.taskInfo.url
String
2048 characters

Initial webview URL.
groupChat.fetchTask
Boolean

✔️
A boolean value that indicates if it should fetch dialog dynamically. 
Default value: false
groupChat.taskInfo
Object


Dialog to be launched when fetch task set to false.
Default value: false
groupChat.taskInfo.title
String
64 characters
✔️
Initial dialog title.
groupChat.taskInfo.width
String
16

The dialog width is either a number in pixels or default layout such as large, medium, or small.
groupChat.taskInfo.height
String
16

The dialog height is either a number in pixels or default layout such as large, medium, or small.
groupChat.taskInfo.url
String
2048 characters

Initial webview URL.
bots.commandLists
Optional – Array
A list of commands that your bot can recommend to users. The object is an array (maximum of three elements) with all elements of type object; you must define a separate command list for each scope that your bot supports. For more information, see Bot menus.
Name
Type
Maximum size
Required
Description
scopes
Array of enums
3
✔️
Specifies the scope for which the command list is valid. Options are team, personal, and groupChat.
commands
Array of objects
10
✔️
An array of commands the bot supports.
Note
Teams mobile client doesn't support the bot app when there is no value in the commandLists property.
bots.commandLists.commands
Required – Array
Name
Type
Maximum size
Required
Description
title
String
128
✔️
The bot command name.
description
String
4000 characters
✔️
A simple text description or an example of the command syntax and its arguments.
bots.requirementSet
Optional – Object
Name
Type
Maximum size
Required
Description
requirementSet.hostMustSupportFunctionalities
Array of objects

✔️
Specifies one or more runtime capabilities the bot requires to function properly. Supported values: dialogUrl, dialogUrlBot, dialogAdaptiveCard, dialogAdaptiveCardBot. For more information, see how to specify runtime requirements in your app manifest.
connectors
Optional – Array
The connectors block defines a connector card for Microsoft 365 Groups for the app.
The object is an array (maximum of one element) with all elements of type object. This block is required only for solutions that provide a Connector.
Name
Type
Maximum size
Required
Description
configurationUrl
String
2048 characters

The https:// URL to use when configuring the connector using the inline configuration experience.
scopes
Array of enums
1
✔️
Specifies whether the Connector offers an experience in the context of a channel in a team, or an experience scoped to an individual user alone (personal). The team scope is only supported.
connectorId
String
64 characters
✔️
A unique identifier for the Connector that matches its ID in the Connectors Developer Dashboard.
composeExtensions
Optional – Array
Defines a message extension for the app.
The item is an array (maximum of one element) with all elements of type object. This block is required only for solutions that provide a message extension.
Name
Type
Maximum Size
Required
Description       
id
String

64
Unique identifier for the message extension. Used when defining one-way and mutual app capability dependencies under elementRelationshipSet.
botId
String


The unique Microsoft app ID for the bot that backs the message extension, as registered with the Bot Framework. The ID can be the same as the overall App ID.
composeExtensionType
String

✔️
Type of the compose extension. Enum values are botBased and apiBased.
authorization
Object


Authorization related information for the API-based message extension.
authorization.authType
String


Enum of possible authorization types. Supported values are none, apiSecretServiceAuth, and microsoftEntra.
authorization.microsoftEntraConfiguration
Object


Object capturing details needed to do microsoftEntra auth flow. Applicable only when auth type is microsoftEntra.
authorization.microsoftEntraConfiguration.supportsSingleSignOn
Boolean


A value indicating whether single sign-on is configured for the app.
authorization.apiSecretServiceAuthConfiguration
Object


Object capturing details needed to do service auth. Applicable only when auth type is apiSecretServiceAuth.
authorization.apiSecretServiceAuthConfiguration.apiSecretRegistrationId
String
128 characters

Registration ID returned when developer submits the API key through Developer Portal.
apiSpecificationFile
String
2048 characters

A relative file path to the API specification file in the manifest package.
canUpdateConfiguration
Boolean


A value indicating whether the configuration of a message extension can be updated by the user. 
Default value: false
commands
Array of objects
10

Array of commands the message extension supports.
messageHandlers
Array of objects
5

A list of handlers that allow apps to be invoked when certain conditions are met.
messageHandlers.type
String


The type of message handler. Must be link.
messageHandlers.value.domains
Array of strings
2048 characters

Array of domains that the link message handler can register for.
messageHandlers.value.supportsAnonymizedPayloads
Boolean


A boolean value that indicates whether the app's link message handler supports anonymous invoke flow. 
Default value: false
requirementSet
Object


Runtime requirements for the message extension to function properly in the Microsoft 365 host application. If one or more of the requirements aren't supported by the runtime host, the host won't load the message extension.
composeExtensions.commands
Your message extension must declare one or more commands with a maximum of 10 commands. Each command appears in Microsoft Teams as a potential interaction from the UI-based entry point.
Each command item is an object with the following structure:
Name
Type
Maximum size
Required
Description
id
String
64 characters
✔️
The ID for the command.
type
String


Type of the command. One of query or action. 
Default value: query
samplePrompts
Array
5

Property used by Microsoft 365 Copilot to display prompts supported by the agent to the user.
samplePrompts.text
String
128 characters
✔️
Content of the sample prompt.
apiResponseRenderingTemplateFile
String
2048 characters

A relative file path for api response rendering template file used to format the JSON response from developer’s API to Adaptive Card response.
context
Array of strings
3

Defines where the message extension can be invoked from. Any combination of compose, commandBox, message. 
Default values: compose, commandBox
title
String
32 characters
✔️
The user-friendly command name.
description
String
128 characters

The description that appears to users to indicate the purpose of this command.
semanticDescription
String
5000 characters

Semantic description of the command for consumption by Microsoft 365 Copilot using Large Language Models (LLMs).
initialRun
Boolean


A Boolean value indicates whether the command runs initially with no parameters. 
Default value: false
fetchTask
Boolean


A Boolean value that indicates if it must fetch the dialog (referred as task module in TeamsJS v1.x) dynamically. 
Default value: false
taskInfo
Object


Specify the dialog to preload when using a message extension command.
taskInfo.title
String
64 characters

Initial dialog title.
taskInfo.width
String
16 characters

Dialog width - either a number in pixels or default layout values such as large, medium, or small.
taskInfo.height
String
16 characters

Dialog height - either a number in pixels or default layout values such as large, medium, or small.
taskInfo.url
String
2048 characters

Initial webview URL.
parameters
Array of objects
5

The list of parameters the command takes.
parameters.name
String
64 characters
✔️
The name of the parameter as it appears in the client. The parameter name is included in the user request.
parameters.title
String
32 characters
✔️
User-friendly title for the parameter.
parameters.description
String
128 characters

User-friendly string that describes this parameter’s purpose.
parameters.semanticDescription
String
2000 characters

Semantic description of the parameter for consumption by Microsoft 365 Copilot using Large Language Models (LLMs).
parameters.value
String
512 characters

Initial value for the parameter. The value isn't supported.
parameters.inputType
String


Defines the type of control displayed on a dialog for fetchTask: false. Input value can only be one of text, textarea, number, date, time, toggle, choiceset. 
Default value: text
parameters.choices
Array of objects
10 items

The choice options for the choiceset. Use only when parameters.inputType is choiceset.
parameters.choices.title
String
128 characters
✔️
Title of the choice.
parameters.choices.value
String
512 characters
✔️
Value of the choice.
composeExtensions.requirementSet
Optional – Object
Name
Type
Maximum size
Required
Description
requirementSet.hostMustSupportFunctionalities
Array of objects

✔️
Specifies one or more runtime capabilities the message extension requires to function properly. Supported values: dialogUrl, dialogUrlBot, dialogAdaptiveCard, dialogAdaptiveCardBot. For more information, see how to specify runtime requirements in your app manifest.
permissions
Optional – Array of strings
An array of string, which specifies which permissions the app requests, which let end users know how the extension does. The following options are non-exclusive:
	•	identity   Requires user identity information.
	•	messageTeamMembers   Requires permission to send direct messages to team members.
Changing these permissions during app update, causes your users to repeat the consent process after they run the updated app. For more information, see Updating your app.
Note
Permissions are deprecated now.
devicePermissions
Optional – Array of strings
Provides the native features on a user's device that your app requests access to. Options are:
	•	geolocation
	•	media
	•	notifications
	•	midi
	•	openExternal
validDomains
Optional (except Required where noted) – Array of strings
A list of valid domains for websites the app expects to load within the Teams client. Domain listings can include wildcards, for example, *.example.com. The valid domain matches exactly one segment of the domain; if you need to match a.b.example.com then use *.*.example.com. If your tab configuration or content UI navigates to any other domain other than tab configuration, that domain must be specified here.
Do not include the domains of identity providers you want to support in your app. For example, to authenticate using a Google ID, it's required to redirect to accounts.google.com, however, you must not include accounts.google.com in validDomains[].
Teams apps that require their own SharePoint URLs to function well, includes "{teamsitedomain}" in their valid domain list.
Important
Don't add domains that are outside your control, either directly or through wildcards (). For example,.yoursite.com is valid, but *.onmicrosoft.com isn't valid as it isn't under your control.
When using wildcards, the following rules apply:
	•	If a subdomain segment includes a wildcard, it must be the only character in the segment.
	•	Any segment preceding a wildcard segment must also be a wildcard segment.
For example, *.*.domain.com is valid, but foo.*.myteam.domain.com is not valid.
The object is an array with all elements of the type string. The maximum item of the object is 16 and maximum length is 2048 characters.
webApplicationInfo
Note
The webApplicationInfo property is related to a single domain and isn't supported for multiple domains. Therefore, if you've two apps hosted on different domains, you need to create separate app manifests for each app.
Optional – Object
Provide your Microsoft Entra App ID and Microsoft Graph information to help users seamlessly sign into your app. If your app is registered in Microsoft Entra ID, you must provide the App ID. Administrators can easily review permissions and grant consent in Teams admin center.
Name
Type
Maximum size
Required
Description
id
String

✔️
Microsoft Entra application ID of the app. This ID must be a GUID.
resource
String
2048 characters

Resource URL of app for acquiring auth token for SSO. 
NOTE: If you aren't using SSO, ensure that you enter a dummy string value in this field to your app manifest, for example, https://example to avoid an error response. The dummy URL string value mustn't contain domains or URLs that aren't in your control, either directly or through wildcards. For example, yourapp.onmicrosoft.com is valid, but *.onmicrosoft.com isn't valid. The top-level domains are prohibited, for example, *.com, *.org.
nestedAppAuthInfo
Array
5

An NAA token based on its contents will be prefetched when the tab is loaded.
nestedAppAuthInfo.redirectUri
String

✔️
Represents the nested app's valid redirect URI (always a base origin).
nestedAppAuthInfo.scopes
Array
20
✔️
Represents the stringified list of scopes the access token requested requires. Order must match that of the proceeding NAA request in the app.
nestedAppAuthInfo.claims
String


An optional JSON formatted object of client capabilities that represents if the resource server is CAE capable. Do not use an empty string for this value. If unsupported, keep the field undefined.
graphConnector
Optional – Object
Specify the app's Graph connector configuration. If this is present, then webApplicationInfo.id must also be specified.
Name
Type
Maximum size
Required
Description
notificationUrl
String
2048 characters
✔️
The url where Graph-connector notifications for the application should be sent.
showLoadingIndicator
Optional – Boolean
Indicates if or not to show the loading indicator when an app or tab is loading. Default is false.
Note
	•	If you select showLoadingIndicator as true in your app manifest, to load the page correctly, modify the content pages of your tabs and dialogs as described in Show a native loading indicator document.
	•	If you don't modify the content pages of your tab, the tab app doesn't load and shows the error There was a problem reaching this app.
isFullScreen
Optional – Boolean
Indicates if a personal app is rendered without a tab header bar (signifying full screen mode). Default value: false
Note
	•	isFullScreen only works for apps published to your organization. Uploaded and published third-party apps can't use this property (it's ignored).
	•	The isFullScreen=true parameter eliminates the header bar and title provided by Teams from personal apps and dialogs. However, it's recommended not to use the isFullScreen=true parameter with chat bot apps.
activities
Optional – Object
Define the properties your app uses to post a user activity feed.
Name
Type
Maximum size
Required
Description
activityTypes
Array of objects
128 items

Provide the types of activities that your app can post to a users activity feed.
activities.activityTypes
Name
Type
Maximum size
Required
Description
type
String
64 characters
✔️
The notification type.
description
String
128 characters
✔️
A brief description of the notification.
templateText
String
128 characters
✔️
Ex: "{actor} created task {taskId} for you"
allowedIconIds
Array
50 characters

An array containing valid icon IDs per activity type.
activities.activityIcons
Name
Type
Maximum size
Required
Description
id
String
64 characters
✔️
Represents the unique icon ID.
iconFile
String
128 characters
✔️
Represents the relative path to the icon image. Image should be size 32x32.
{
  "activities":{
   "activityTypes":[
     {
      "type":"taskCreated",
      "description":"Task Created Activity",
      "templateText":"{actor} created task {taskId} for you"
     },
     {
      "type":"teamMention",
      "description":"Team Mention Activity",
      "templateText":"{actor} mentioned team"
     },
     {
      "type":"channelMention",
      "description":"Channel Mention Activity",
      "templateText":"{actor} mentioned channel"
     },
     {
      "type":"userMention",
      "description":"Personal Mention Activity",
      "templateText":"{actor} mentioned user"
     },
     {
      "type":"calendarForward",
      "description":"Forwarding a Calendar Event",
      "templateText":"{actor} sent user an invite on behalf of {eventOwner}"
     },
     {
      "type":"calendarForward",
      "description":"Forwarding a Calendar Event",
      "templateText":"{actor} sent user an invite on behalf of {eventOwner}"
     },
     {
      "type":"creatorTaskCreated",
      "description":"Created Task Created",
      "templateText":"The Creator created task {taskId} for you"
     }
   ]
  }
}

defaultInstallScope
Optional – String
Specifies the install scope defined for this app by default. The default install scope is denoted with a Recommended option adjacent to the corresponding scope in the scope selection dialog, after the user adds the app. The options are:
	•	personal
	•	team
	•	groupChat
	•	meetings
	•	copilot
defaultGroupCapability
Optional – Object
When a group install scope is selected, it defines the default capability when the user installs the app.
Name
Type
Maximum size
Required
Description
team
String


When the install scope selected is team, this field specifies the default capability available. Options: tab, bot, or connector.
groupchat
String


When the install scope selected is groupChat, this field specifies the default capability available. Options: tab, bot, or connector.
meetings
String


When the install scope selected is meetings, this field specifies the default capability available. Options: tab, bot, or connector.
configurableProperties
Optional – Array
The configurableProperties block defines the app properties that Teams Administrators can customize. For more information, see enable app customization. The app customization feature isn't supported in custom apps or custom apps built for your org (LOB apps).
Note
A minimum of one property must be defined. You can define a maximum of nine properties in this block.
You can define any of the following properties:
	•	name: The app's display name.
	•	shortDescription: The app's short description.
	•	longDescription: The app's long description.
	•	smallImageUrl: The app's outline icon.
	•	largeImageUrl: The app's color icon.
	•	accentColor: The color to use and a background for your outline icons.
	•	developerUrl: The HTTPS URL of the developer's website.
	•	privacyUrl: The HTTPS URL of the developer's privacy policy.
	•	termsOfUseUrl: The HTTPS URL of the developer's terms of use.
supportedChannelTypes
Optional – Array
Enables your app in non-standard channels. If your app supports a team scope and this property is defined, Teams enables your app in each channel type accordingly. The supportedChannelTypes property only supports sharedChannels and privateChannels.
Note
	•	If your app supports a team scope, it functions in the standard channels regardless of the values that are defined in this property.
	•	Your app can account for the unique properties of each of the channel types to function properly. To enable your tab for private and shared channels, see retrieve context in private channels and get context in shared channels
defaultBlockUntilAdminAction
Optional – Boolean
When defaultBlockUntilAdminAction property is set to true, the app is hidden from users by default until admin allows it. If set to true, the app is hidden for all tenants and end users. The Teams Administrators can see the app in the Teams admin center and take action to allow or block the app. The default value is false. For more information on default app block, see Block apps by default for users until an admin approves.
publisherDocsUrl
Optional – String
Maximum size - 2048 characters
The value of the publisherDocsUrl parameter is a secure HTTPS URL to the app documentation and information page that app developers choose to provide. Teams Administrators get documentation about the app at this URL. Teams admin center displays the URL in the app details page. The documentation may include the instructions for admins to facilitate app adoption and app rollout. In the app documentation, you can also include instructions or information about the app that is useful for the Teams Administrator, users, and other business stakeholders.
subscriptionOffer
Optional – Object
Specifies the SaaS offer associated with your app.
Name
Type
Maximum size
Required
Description
offerId
String
2048 characters
✔️
A unique identifier that includes your Publisher ID and Offer ID, which you can find in Partner Center. You must format the string as publisherId.offerId.
meetingExtensionDefinition
Optional – Object
Specify meeting extension definition. For more information, see custom Together Mode scenes in Teams.
Name
Type
Maximum size
Required
Description
scenes
Array of objects
5 items

Meeting supported scenes.
supportsCustomShareToStage
Boolean


Represents if the app has added support for sharing to stage.
supportsStreaming
Boolean


A value that indicates whether an app can stream the meeting's audio and video content to a real-time meeting protocol (RTMP) endpoint. 
Default value: false
supportsAnonymousGuestUsers
Boolean


A value that indicates whether an app supports access for anonymous users. 
Default value: false
Note
The supportsAnonymousGuestUsers property in the app manifest schema v1.16 is supported only in new Teams client.
meetingExtensionDefinition.scenes
Name
Type
Maximum size
Required
Description
id
String

✔️
The unique identifier for the scene. This id must be a GUID.
name
String
128 characters
✔️
The name of the scene.
file
String
2048 characters
✔️
The relative file path to the scenes' metadata json file.
preview
String
2048 characters
✔️
The relative file path to the scenes' PNG preview icon.
maxAudience
Integer
50
✔️
The maximum number of audiences supported in the scene.
seatsReservedForOrganizersOrPresenters
Integer
50
✔️
The number of seats reserved for organizers or presenters.
authorization
Optional – Object
Note
authorization is only supported for the app manifest version 1.12 or later.
Specify and consolidate authorization related information for the app.
Name
Type
Maximum size
Required
Description
permissions
Object


List of permissions that the app needs to function.
authorization.permissions
Name
Type
Maximum size
Required
Description
resourceSpecific
Array of objects
16 items

Permissions that guard data access on resource instance level.
authorization.permissions.resourceSpecific
Name
Type
Maximum size
Required
Description
type
String

✔️
The type of the resource-specific consent (RSC) permission. Options: Application and Delegated.
name
String
128 characters
✔️
The name of the RSC permission. For more information, see RSC application permissions and RSC delegated permissions
RSC application permissions
Application permissions allow the app to access data without a signed-in user. For information on application permissions, see RSC permissions for Microsoft Graph and Microsoft BotSDK.
RSC delegated permissions
Delegated permissions allow the app to access data on behalf of the signed-in user.
	•	RSC delegated permissions for a team
	•	Name
	•	Description
	•	ChannelMeetingParticipant.Read.Group
	•	Allows the app to read participant information, including name, role, id, joined, and left times, of channel meetings associated with this team, on behalf of the signed-in user.
	•	ChannelMeetingIncomingAudio.Detect.Group
	•	Allows the app to detect incoming audio in channel meetings associated with the team.
	•	ChannelMeetingActiveSpeaker.Read.Group
	•	Allows the app to read the participants who are sending audio into the channel meetings associated with the team.
	•	ChannelMeetingAudioVideo.Stream.Group
	•	Allows the app to stream audio-video content from channel meetings associated with the team.
	•	InAppPurchase.Allow.Group
	•	Allows the app to show marketplace offers to users in the team and complete their purchases within the app, on behalf of the signed-in user.
	•	ChannelMeetingStage.Write.Group
	•	Allows the app to show content on the meeting stage in channel meetings associated with the team, on behalf of the signed-in user.
	•	LiveShareSession.ReadWrite.Group
	•	Allows the app to create and synchronize Live Share sessions for the team and get access related information, such as name and role, about the team's roster and any associated meetings, on behalf of the signed-in user.
	•	MeetingParticipantReaction.Read.Group
	•	Allows the app to read reactions of participants in channel meetings associated with the team.
	•	RSC delegated permissions for chats or meetings
	•	Name
	•	Description
	•	InAppPurchase.Allow.Chat
	•	Allows the app to show marketplace offers to the users in the chat, and any associated meeting, and complete their purchases within the app, on behalf of the signed-in user.
	•	MeetingStage.Write.Chat
	•	Allows the app to show content on the meeting stage in meetings associated with the chat, on behalf of the signed-in user.
	•	OnlineMeetingParticipant.Read.Chat
	•	Allows the app to read participant information, including name, role, id, joined, and left times, of meeting associated with the chat, on behalf of the signed-in user.
	•	OnlineMeetingParticipant.ToggleIncomingAudio.Chat
	•	Allows the app to toggle incoming audio for participants in meetings associated with the chat, on behalf of the signed-in user.
	•	LiveShareSession.ReadWrite.Chat
	•	Allows the app to create and synchronize Live Share sessions for the chat and get access related information, such as name and role, about the chat's roster and any associated meetings, on behalf of the signed-in user.
	•	MeetingParticipantReaction.Read.Chat
	•	Allows the app to read reactions of participants in meetings associated with the chat.
	•	OnlineMeetingIncomingAudio.Detect.Chat
	•	Allows the app to detect changes in the status of incoming audio in meetings associated with the chat, on behalf of the signed-in user.
	•	OnlineMeetingActiveSpeaker.Read.Chat
	•	Allows the app to read participants who are sending audio into the meetings associated with the chat.
	•	OnlineMeetingAudioVideo.Stream.Chat
	•	Allows the app to stream audio-video content of meetings associated with the chat.
	•	RSC delegated permissions for users
	•	Name
	•	Description
	•	CameraStream.Read.User
	•	Allows the app to read user's camera stream.
	•	InAppPurchase.Allow.User
	•	Allows the app to show the user marketplace offers and complete the user's purchases within the app, on behalf of the signed-in user.
	•	OutgoingVideoStream.Write.User
	•	Allows the app to modify the user's outgoing video.
	•	MicrophoneStream.Read.User
	•	Allows the app to read user's microphone stream.
	•	MeetingParticipantReaction.Read.User
	•	Allows the app to read user's reactions while participating in a meeting.
extensions
Optional – Object
The extensions property specifies Outlook Add-ins within an app manifest and simplifies the distribution and acquisition across the Microsoft 365 ecosystem. Each app supports only one extension.
Name
Type
Maximum size
Required
Description
requirements
Object


Specifies the set of client or host requirements for the extension.
runtimes
Array
20

Configures the set of runtimes and actions that can be used by each extension point. For more information, see runtimes in Office Add-ins.
ribbons
Array
20

Defines the ribbons extension point.
autoRunEvents
Array
10

Defines the event-based activation extension point.
alternates
Array

10
Specifies the relationship to alternate existing Microsoft 365 solutions. It's used to hide or prioritize add-ins from the same publisher with overlapping functionality.
audienceClaimUrl
String
2048 characters

Specifies the URL for your extension and is used to validate Exchange user identity tokens. For more information, see inside the Exchange identity token
For more information, see Office Add-ins manifest for Microsoft 365.
extensions.requirements
The extensions.requirements object specifies the scopes, form factors, and Office JavaScript library requirement sets that must be supported on the Office client in order for the add-in to be installed. Requirements are also supported on the ribbon, runtime, alternates, and autoRunEvents child properties to selectively filter out some features of the add-in. For more information, see Specify Office Add-in requirements in the unified manifest for Microsoft 365.
Name
Type
Maximum size
Required
Description
capabilities
Array
100

Identifies the requirement sets.
capabilities.name
String
128
✔️
Identifies the name of the requirement set.
capabilities.minVersion
String


Identifies the minimum version for the requirement set.
capabilities.maxVersion
String


Identifies the maximum version for the requirement set.
scopes
Array of enums
4

Identifies the scopes in which the add-in can run and defines the Microsoft 365 applications in which the extension can run. For example, mail (Outlook). 
Supported value: mail
formFactors
Array of enums
2

Identifies the form factors that support the add-in. 
Supported values: mobile, desktop
extensions.runtimes
Optional – Array
The extensions.runtimes array configures the sets of runtimes and actions that each extension point can use.
Name
Type
Maximum size
Required
Description
id
String
64 characters
✔️
Specifies the ID for runtime.
type
String enum

✔️
Specifies the type of runtime. The supported enum value for browser-based runtime is general.
code
Object

✔️
Specifies the location of code for the runtime. Based on runtime.type, add-ins can use either a JavaScript file or an HTML page with an embedded script tag that specifies the URL of a JavaScript file. Both URLs are necessary in situations where the runtime.type is uncertain.
code.page
String
2048 characters
✔️
Specifies the URL of the web page that contains an embedded script tag, which specifies the URL of a JavaScript file (to be loaded in a browser-based runtime).
code.script
String
2048 characters

Specifies the URL of the JavaScript file to be loaded in JavaScript-only runtime.
lifetime
String enum


Specifies the lifetime of the runtime. Runtimes with a short lifetime don’t preserve state across executions while runtimes with a long lifetime do. For more information, see Runtimes in Office Add-ins. 
Default value: short
actions
Array
20

Specifies the set of actions supported by the runtime. An action is either running a JavaScript function or opening a view such as a task pane.
actions.id
String
64 characters
✔️
Specifies the ID for the action, which is passed to the code file.
actions.type
String

✔️
Specifies the type of action. The executeFunction type runs a JavaScript function without waiting for it to finish and the openPage type opens a page in a given view.
actions.displayName
String
64 characters

Specifies the display name of the action and it isn't the label of a button or a menu item that invokes the action (which is configured with tabs.groups.controls.label).
actions.pinnable
Boolean


Specifies that a task pane supports pinning, which keeps the task pane open when the user changes the selection. 
Default value: false
actions.view
String
64 characters

Specifies the view where the page must be opened. It's used only when actions.type is openPage.
actions.multiselect
Boolean


Specifies whether the end user can select multiple items, such as multiple email messages, and apply the action to all of them. 
Default value: false
actions.supportsNoItemContext
Boolean


Allows task pane add-ins to activate without the reading pane enabled or a message selected. 
Default value: false
requirements
Object


Specifies the scopes, formFactors, and Office JavaScript library requirement sets that must be supported on the Office client in order for the runtime to be included in the add-in. For more information, see Specify Office Add-in requirements in the unified manifest for Microsoft 365.
requirements.capabilities
Array
100

Identifies the requirement sets. 
Options: name (required), minVersion, maxVersion
requirements.capabilities.name
String
128
✔️
Identifies the name of the requirement set.
requirements.capabilities.minVersion
String


Identifies the minimum version for the requirement set.
requirements.capabilities.maxVersion
String


Identifies the maximum version for the requirement set.
requirements.scopes
Array of enums
4

Identifies the scopes in which the add-in can run and defines the Microsoft 365 applications in which the extension can run. For example, mail (Outlook). 
Supported value: mail
requirements.formFactors
Array of enums
2

Identifies the form factors that support the add-in. 
Supported values: mobile, desktop
To use extensions.runtimes, see create add-in commands, configure the runtime for a task pane, and configure the runtime for the function command.
extensions.ribbons
Optional – Array
The extensions.ribbons property provides the ability to add add-in commands (buttons and menu items) to the Microsoft 365 application's ribbon. The ribbon definition is selected from the array based on the requirements and first-of order.
Name
Type
Maximum size
Required
Description
contexts
Array
8

Specifies the Microsoft 365 application window in which the ribbon customization is available to the user. Each item in the array is a member of a string array. 
Supported values: mailRead, mailCompose, meetingDetailsOrganizer, meetingDetailsAttendee, onlineMeetingDetailsOrganizer, logEventMeetingDetailsAttendee, spamReportingOverride, default
requirements
Object


Specifies the scopes, formFactors, and Office JavaScript library requirement sets that must be supported on the Office client in order for the ribbon customization to appear. For more information, see Specify Office Add-in requirements in the unified manifest for Microsoft 365.
requirements.capabilities
Array
100

Identifies the requirement sets. 
Options: name (required), minVersion, maxVersion
requirements.capabilities.name
String
128
✔️
Identifies the name of the requirement set.
requirements.capabilities.minVersion
String


Identifies the minimum version for the requirement set.
requirements.capabilities.maxVersion
String


Identifies the maximum version for the requirement set.
requirements.scopes
Array of enums
4

Identifies the scopes in which the add-in can run and defines the Microsoft 365 applications in which the extension can run. For example, mail (Outlook). 
Supported value: mail
requirements.formFactors
Array of enums
2

Identifies the form factors that support the add-in. 
Supported values: mobile, desktop
tabs
Array
20
✔️
Configures the custom tabs on the Microsoft 365 application ribbon.
tabs.id
String
64 characters

Specifies the ID for the tab within the app.
tabs.builtInTabId
String
64 characters

Specifies the ID of a built-in Office ribbon tab. For more information on possible values, see find the IDs of built-in Office ribbon tabs. The only other child properties of the tab object that can be combined with this one are groups and customMobileRibbonGroups.
tabs.label
String
64 characters

Specifies the text displayed for the tab. Despite the maximum length of 64 characters, to correctly align the tab in the ribbon, we recommend you limit the label to 16 characters.
tabs.position
Object
64 characters

Configures the position of the custom tab relative to other tabs on the ribbon.
tabs.position.builtInTabId
String
64 characters
✔️
Specifies the ID of the built-in tab that the custom tab should be positioned next to. For more information, see find the IDs of controls and control groups.
tabs.position.align
String enum

✔️
Defines the alignment of custom tab relative to the specified built-in tab. 
Supported values: after, before
tabs.groups
Array
10

Defines groups of controls on a ribbon tab on a non-mobile device. For mobile devices, see tabs.customMobileRibbonGroups.
tabs.groups.id
String
64 characters

Specifies the ID for the tab group within the app. It must be different from any built-in group ID in the Microsoft 365 application and any other custom group.
tabs.groups.label
String
64 characters

Specifies the text displayed for the group. Despite the maximum length of 64 characters, to correctly align the tab in the ribbon, we recommend you limit the label to 16 characters.
tabs.groups.icons
Array
3

Specifies the icons displayed for the group.
tabs.groups.icons.size
Number

✔️
Specifies the size of the icon in pixels, enumerated as 16,20,24,32,40,48,64,80. 
Required image sizes: 16, 32, 80.
tabs.groups.icons.url
String
2048 characters
✔️
Specifies the absolute URL of the icon. 
Default value: The string must start with https://
tabs.groups.controls
Array


Configures the buttons and menus in the group.
tabs.groups.controls.id
String
64 characters
✔️
Specifies the ID for the control within the app. It must be different from any built-in control ID in the Microsoft 365 application and any other custom control.
tabs.groups.controls.items
Array


Configures the items for a menu control.
tabs.groups.controls.items.id
String
64 characters
✔️
Specifies the ID for a menu item.
tabs.groups.controls.items.type
String enum

✔️
Defines the menu item's control type. 
Supported values: button
tabs.groups.controls.items.label
String
64 characters
✔️
Specifies the text displayed for the menu item.
tabs.groups.controls.items.icons
Array
3 characters

Configures the icons for the menu item.
tabs.groups.controls.items.icons.size
Number

✔️
Specifies the size of the icon in pixels, enumerated as 16,20,24,32,40,48,64,80. 
Required image sizes: 16, 32, 80.
tabs.groups.controls.items.icons.url
URL
2048 characters
✔️
Specifies the absolute URL of the icon. 
Default value: The string must start with https://
tabs.groups.controls.items.supertip
Object

✔️
Configures a supertip for the menu item. A supertip is a UI feature that displays a brief box of help information about a control when the cursor hovers over it. The box may contain multiple lines of text.
tabs.groups.controls.items.supertip.title
String
64 characters
✔️
Specifies the title text of the supertip.
tabs.groups.controls.items.supertip.description
String
250 characters
✔️
Specifies the description of the supertip.
tabs.groups.controls.items.actionId
String
64 characters
✔️
Specifies the ID of the action that is taken when a user selects the control or menu item. The actionId must match with some runtimes.actions.id property value.
tabs.groups.controls.items.enabled
Boolean


Indicates whether the menu item is initially enabled. 
Default value: true
tabs.groups.controls.items.overriddenByRibbonApi
Boolean


Specifies whether the menu item is hidden on application and platform combinations which support the API (Office.ribbon.requestCreateControls). This API installs custom contextual tabs on the ribbon. 
Default value: false
tabs.groups.controls.type
String

✔️
Defines the control type. 
Supported values: button, menu
tabs.groups.controls.builtInControlId
String
64 characters
✔️
Specifies the ID of an existing Microsoft 365 control. For more information, see find the IDs of controls and control groups. This property can't be combined with any other child properties of the control object because built-in controls are not customizable by an add-in.
tabs.groups.controls.label
String
64 characters
✔️
Specifies the text displayed for the control. Despite the maximum length of 64 characters, to correctly align the tab in the ribbon, we recommend you limit the label to 16 characters.
tabs.groups.controls.icons
Array
3 characters
✔️
Defines the icons for the control. There must be at least three child objects; one each with size properties of 16, 32, and 80 pixels.
tabs.groups.controls.icons.size
Number

✔️
Specifies the size of the icon in pixels, enumerated as 16,20,24,32,40,48,64,80. 
Required image sizes: 16, 32, 80
tabs.groups.controls.icons.url
URL
2048 characters

Specifies the absolute URL to the icon file. 
Default value: The string must start with https://
tabs.groups.controls.supertip
Object

✔️
Configures a supertip for the control. A supertip is a UI feature that displays a brief box of help information about a control when the cursor hovers over it. The box may contain multiple lines of text.
tabs.groups.controls.supertip.title
String
64 characters
✔️
Specifies the title text of the supertip.
tabs.groups.controls.supertip.description
String
250 characters
✔️
Specifies the description of the supertip.
tabs.groups.controls.actionId
String
64 characters

Required if the control type is button. Don't use if the control type is menu. Specifies the ID of the action that is taken when a user selects the control. The actionId must match the runtime.actions.id property of an action in the runtimes object.
tabs.groups.controls.enabled
Boolean


Indicates whether the control is initially enabled. 
Default value: true
tabs.groups.controls.overriddenByRibbonApi
Boolean


Specifies whether the control is hidden on application and platform combinations which support the API (Office.ribbon.requestCreateControls). This API installs custom contextual tabs on the ribbon. 
Default value: false
tabs.groups.builtInGroupId
String
64 characters

Specifies the ID of a built-in group. For more information, see find the IDs of controls and control groups. This property can't be combined with any other child properties of the group object because built-in groups are not customizable by an add-in.
tabs.customMobileRibbonGroups
Array
10

Defines groups of controls on the default tab of the ribbon on a mobile device. This array property can only be present on tab objects that have a tabs.builtInTabId property that is set to DefaultTab. For non-mobile devices, see tabs.groups above.
tabs.customMobileRibbonGroups.id
String
250 characters
✔️
Specifies the ID of the group. It must be different from any built-in group ID in the Microsoft 365 application and any other custom group.
tabs.customMobileRibbonGroups.label
String
32 characters
✔️
Specifies the label on the group.
tabs.customMobileRibbonGroups.controls
Array
20
✔️
Defines the controls in the group. Only mobile buttons are supported.
tabs.customMobileRibbonGroups.controls.id
String
250 characters
✔️
Specifies the ID of the control such as msgReadFunctionButton.
tabs.customMobileRibbonGroups.controls.type
String enum

✔️
Specifies the type of control. 
Supported value: MobileButton
tabs.customMobileRibbonGroups.controls.label
String
32 characters
✔️
Specifies the label on the control.
tabs.customMobileRibbonGroups.controls.actionId
String
64 characters
✔️
Specifies the ID of the action that is taken when a user selects the control. The actionId must match the runtime.actions.id property of an action in the runtimes object.
tabs.customMobileRibbonGroups.controls.icons
Array
9
✔️
Specifies the icons that appear on the control depending on the dimensions and DPI of the mobile device screen. There must be exactly 9 icons.
tabs.customMobileRibbonGroups.controls.icons.size
Number enum

✔️
Size in pixels of the icon. The required sizes are 25, 32, and 48. There must be exactly one of each size for each possible value of the icons' scale property.
tabs.customMobileRibbonGroups.controls.icons.url
String
2048 characters
✔️
The full, absolute URL of the icon's image file. 
Default value: The string must start with https://
tabs.customMobileRibbonGroups.controls.icons.scale
Number enum

✔️
Specifies the UIScreen.scale property for iOS devices. The possible values are 1, 2, and 3. There must be exactly one of each value for each possible value of the icons's size property.
fixedControls
Array
1

Configures the button of an integrated spam-reporting add-in in Outlook. Must configure if spamReportingOverride is specified in the extensions.ribbons.contexts array.
fixedControls.id
String
64 characters
✔️
Specifies the unique ID of the button of a spam-reporting add-in.
fixedControls.type
String

✔️
Defines the control type of a spam-reporting add-in. 
Supported value: button
fixedControls.label
String
64 characters
✔️
Specifies the text that appears on button of a spam-reporting add-in.
fixedControls.enabled
Boolean

✔️
This property must be specified in the fixedControls object, but it doesn't affect the functionality of the spam-reporting add-in. 
Default value: True
fixedControls.icons
Array
3
✔️
Defines the icons for the button of a spam-reporting add-in. There must be at least three child objects, each with icon sizes of 16, 32, and 80 pixels respectively.
fixedControls.icons.size
Number

✔️
Specifies the size of the icon in pixels, enumerated as 16, 20, 24, 32, 40, 48, 64, and 80.
Required image sizes: 16, 32, 80
fixedControls.icons.url
String
2048 characters
✔️
Specifies the absolute URL to the icon. 
Default value: The string must start with https://
fixedControls.supertip
Object

✔️
Configures a supertip for the button of a spam-reporting add-in.
fixedControls.supertip.title
String
64 characters
✔️
Specifies the title text of the supertip.
fixedControls.supertip.description
String
250 characters
✔️
Specifies the description of the supertip.
fixedControls.actionId
String
64 characters
✔️
Specifies the ID of the action taken when a user selects the button of a spam-reporting add-in. The actionId must match the runtime.actions.id property of an action in the runtimes object.
fixedControls.enabled
Boolean

✔️
This property must be specified in the fixedControls object. However, it doesn't affect the functionality of a spam-reporting add-in. 
Supported value: True
spamPreProcessingDialog
Object


Configures the preprocessing dialog of an integrated spam-reporting add-in in Outlook.
spamPreProcessingDialog.title
String
128 characters
✔️
Specifies the custom title of the preprocessing dialog of a spam-reporting add-in.
spamPreProcessingDialog.description
String
250 characters
✔️
Specifies the custom text that appears in the preprocessing dialog of a spam-reporting add-in.
spamPreProcessingDialog.spamNeverShowAgainOption
Boolean


Indicating if the developer will allow the user to permanently bypass the PreProcessing Dialog for this add-in. "false" is the default value if not specified.
spamPreProcessingDialog.spamReportingOptions
Object


Specifies up to five options that a user can select from the preprocessing dialog to provide a reason for reporting a message.
spamPreProcessingDialog.spamReportingOptions.title
String
128 characters
✔️
Specifies the custom text or title to describe the reporting options provided in the preprocessing dialog.
spamPreProcessingDialog.spamReportingOptions.options
Array of strings
5 options

128 characters per option
✔️
Specifies a custom option with a checkbox that a user can select from the preprocessing dialog to provide a reason for reporting a message. At least one option must be specified. A maximum of five options can be included.
spamPreProcessingDialog.spamFreeTextSectionTitle
String
128 characters

Adds a text box to the preprocessing dialog for users to provide additional information on the message they're reporting. The string provided in this property appears above the text box.
spamPreProcessingDialog.spamMoreInfo
Object


Configures a link to provide informational resources to a user. In the preprocessing dialog, the link appears below the text provided in spamPreProcessingDialog.description.
spamPreProcessingDialog.spamMoreInfo.text
String
128 characters
✔️
Specifies the link text for a URL that directs users to informational resources from the preprocessing dialog.
spamPreProcessingDialog.spamMoreInfo.url
String
2048 characters
✔️
Specifies the HTTPS URL of a site that contains informational resources.
To use extensions.ribbons, see create add-in commands, configure the UI for the task pane command, and configure the UI for the function command.
extensions.autoRunEvents
Optional – Array
The extensions.autoRunEvents property defines event-based activation extension points.
Name
Type
Maximum size
Required
Description
events
Array
20
✔️
Configures the event that cause actions in an Outlook Add-in to run automatically. For example, see use smart alerts and the OnMessageSend and OnAppointmentSend events in your Outlook Add-ins.
events.type
String
64 characters
✔️
Specifies the type of event. For supported types, see supported events.
events.actionId
String
64 characters
✔️
Identifies the action that is taken when the event fires. The actionId must match with runtime.actions.id.
events.options
Object


Configures how Outlook responds to the event.
events.options.sendMode
String

✔️
Specifies the actions to take during a mail send action. 
Supported values: promptUser, softBlock, block. For more information, see available send mode options.
requirements
Object


Specifies the scopes, formFactors, and Office JavaScript library requirement sets that must be supported on the Office client in order for the event handling code to run. For more information, see Specify Office Add-in requirements in the unified manifest for Microsoft 365.
requirements.capabilities
Array
100

Identifies the requirement sets. 
Options: name (required), minVersion, maxVersion
requirements.capabilities.name
String
128 characters
✔️
Identifies the name of the requirement set.
requirements.capabilities.minVersion
String


Identifies the minimum version for the requirement set.
requirements.capabilities.maxVersion
String


Identifies the maximum version for the requirement set.
requirements.scopes
Array of enums
4

Identifies the scopes in which the add-in can run and defines the Microsoft 365 applications in which the extension can run. For example, mail (Outlook). 
Supported value: mail
requirements.formFactors
Array of enums
2

Identifies the form factors that support the add-in. 
Supported values: mobile, desktop
extensions.alternates
Optional – Array
The extensions.alternates property is used to hide or prioritize specific in-market add-ins when you've published multiple add-ins with overlapping functionality.
Name
Type
Maximum size
Required
Description
prefer
Object


Specifies the backward compatibility with an equivalent COM add-in, XLL add-in, or both.
prefer.comAddin
Object


Specifies a COM add-in that must be used in place of the Microsoft 365 Web Add-in for Windows.
prefer.comAddin.progId
String
64 characters
✔️
Identifies the application type in which the extension can run.
hide
Object


Configures how to hide another add-in that you've published whenever the add-in is installed, so users don't see both in the Microsoft 365 UI. For example, use this property when you've previously published an add-in that uses the old XML app manifest and you're replacing it with a version that uses the new JSON app manifest.
hide.storeOfficeAddin
Object


Specifies a Microsoft 365 Add-in available in Microsoft AppSource.
hide.storeOfficeAddin.officeAddinId
String
64 characters
✔️
Specifies the ID of the in-market add-in to hide. The GUID is taken from the app manifest id property if the in-market add-in uses the JSON app manifest. The GUID is taken from the <Id> element if the in-market add-in uses the XML app manifest.
hide.storeOfficeAddin.assetId
String
64 characters
✔️
Specifies the AppSource asset ID of the in-market add-in to hide.
hide.customOfficeAddin
Object


Configures how to hide an in-market add-in that isn't distributed through AppSource.
hide.customOfficeAddin.officeAddinId
String
64 characters
✔️
Specifies the ID of the in-market add-in to hide. The GUID is taken from the app manifest id property if the in-market add-in uses the JSON app manifest. The GUID is taken from the <Id> element if the in-market add-in uses the XML app manifest.
requirements
Object


Specifies the scopes, formFactors, and Office JavaScript library requirement sets that must be supported on the Office client in order for the hide, prefer, or alternateIcons properties to take effect. For more information, see Specify Office Add-in requirements in the unified manifest for Microsoft 365.
requirements.capabilities
Array
100

Identifies the requirement sets. 
Options: name (required), minVersion, maxVersion
requirements.capabilities.name
String

✔️
Identifies the name of the requirement set.
requirements.capabilities.minVersion
String


Identifies the minimum version for the requirement set.
requirements.capabilities.maxVersion
String


Identifies the maximum version for the requirement set.
requirements.scopes
Array of enums
1

Identifies the scopes in which the add-in can run and defines the Microsoft 365 applications in which the extension can run. For example, mail (Outlook). 
Supported value: mail
requirements.formFactors
Array of enums


Identifies the form factors that support the add-in. 
Supported values: mobile, desktop
alternateIcons
Object


Specifies the main icons that are used to represent the add-in on older versions of Office. This property is required if the Office add-in is to be installable in Office on Mac, perpetual Office licenses, and Microsoft 365 subscription versions of Office on Windows earlier than 2304 (Build 16320.00000).
alternateIcons.icon
Object

✔️
Specifies properties of the image file used to represent the add-in.
alternateIcons.icon.size
Number enum

✔️
Specifies the size of the icon in pixels, enumerated as 16,20,24,32,40,48,64,80. 
Required image sizes: 16, 32, 80.
alternateIcons.icon.url
String
2048 characters
✔️
Specifies the full, absolute URL of the image file that is used to represent the add-in. Icon image must be 64 x 64 pixels and use one of the following file formats: GIF, JPG, PNG, EXIF, BMP, TIFF.
alternateIcons.highResolutionIcon
Object

✔️
Specifies properties of the image file used to represent the add-in on high DPI screens.
alternateIcons.highResolutionIcon.size
Number enum

✔️
Specifies the size of the icon in pixels, enumerated as 16,20,24,32,40,48,64,80. 
Required image sizes: 16, 32, 80.
alternateIcons.highResolutionIcon.url
String
2048 characters
✔️
Specifies the full, absolute URL of the image file that is used to represent the add-in on high DPI screens. Icon image must be 128 x 128 pixels and use one of the following file formats: GIF, JPG, PNG, EXIF, BMP, TIFF.
dashboardCards
Optional – Array
Defines a list of cards that can be pinned to a dashboard, such as Microsoft Viva Connections, to provide a summarized view of app information. To learn more about creating cards for Viva Connections Dashboard, see Overview of Bot Powered Adaptive Card Extensions.
This item is an array of dashboardCard elements of type object.
dashboardCards.dashboardCard
Defines a single dashboard card and its properties.
Name
Type
Maximum size
Required
Description
id
String

✔️
A unique identifier for this dashboard card. ID must be a GUID.
displayName
String
255 characters
✔️
Display name of the card.
description
String
255 characters
✔️
Description of the card.
pickerGroupId
String

✔️
ID of the group in the card picker. ID must be a GUID.
icon
Object


Specifies icon for the card.
contentSource
Object

✔️
Specifies the source of the card's content
defaultSize
String

✔️
Rendering size for the dashboard card. Options: medium or large.
dashboardCards.dashboardCard.icon
Defines the icon properties of a given dashboard card.
Name
Type
Maximum size
Required
Description
iconUrl
String
2048 characters

Location of the icon for the card, to be displayed in the toolbox and card bar.
officeUIFabricIconName
String
255 characters

Office UI Fabric or Fluent UI icon's friendly name for the card. This value is used if iconUrl is not specified.
dashboardCards.dashboardCard.contentSource
Defines the content source of a given dashboard card.
Name
Type
Maximum size
Required
Description
sourceType
String


Represents the source of a card's content. Option: bot.
botConfiguration
Object


The configuration for the bot source. Required if the sourceType is set to bot.
dashboardCards.dashboardCard.contentSource.botConfiguration
Name
Type
Maximum size
Required
Description
botId
String


The unique Microsoft app ID for the bot as registered with the Bot Framework. ID must be a GUID.
intuneInfo
Optional – Object
Properties related to app support for Microsoft Intune.
Name
Type
Maximum size
Required
Description
supportedMobileAppManagementVersion
String
64 characters

Supported Microsoft Intune Mobile App Management (MAM) version. The value is a single version number in the format integer.integer, such as 1.2, indicating the highest level of support the app confirms. If no value is provided, the app doesn't attest to being Intune MAM compliant.
Create an app manifest file
If your app doesn't have an app manifest file, you need to create it.
To create an app manifest file:
	1	Use the sample app manifest schema to create a .json file.
	2	Save it in the root of your project folder as manifest.json.

Here's an example of the app manifest schema for a tab app with SSO enabled:

Note
The app manifest example content shown here is only for a tab app. It uses example values for subdomain URI. For more information, see sample app manifest schema.
{ 
"$schema": "https://developer.microsoft.com/json-schemas/teams/v1.11/MicrosoftTeams.schema.json", 
"manifestVersion": "1.12", 
"version": "1.0.0", 
"id": "{new GUID for this Teams app - not the Microsoft Entra App ID}", 
"developer": { 
"name": "Microsoft", 
"websiteUrl": "https://www.microsoft.com", 
"privacyUrl": "https://www.microsoft.com/privacy", 
"termsOfUseUrl": "https://www.microsoft.com/termsofuse" 
}, 

"name": { 
 "short": "Teams Auth SSO", 
 "full": "Teams Auth SSO" 
}, 


"description": { 
 "short": "Teams Auth SSO app", 
 "full": "The Teams Auth SSO app" 
}, 

"icons": { 
 "outline": "outline.png", 
 "color": "color.png" 
}, 

"accentColor": "#60A18E", 
"staticTabs": [ 
 { 
  "entityId": "auth", 
  "name": "Auth", 
  "contentUrl": "https://subdomain.example.com/Home/Index", 
  "scopes": [ "personal" ] 
 } 
], 

"configurableTabs": [ 
 { 
  "configurationUrl": "https://subdomain.example.com/Home/Configure", 
  "canUpdateConfiguration": true, 
  "scopes": [ 
  "team" 
  ] 
 } 
], 
"permissions": [ "identity", "messageTeamMembers" ], 
"validDomains": [ 
 "{subdomain or ngrok url}" 
], 
"webApplicationInfo": { 
 "id": "{Microsoft Entra AppId}", 
 "resource": "api://subdomain.example.com/{Microsoft Entra AppId}" 
}
} 
See also
	•	Understand the Microsoft Teams app structure
	•	Enable app customization
	•	Localize your app
	•	Integrate media capabilities
	•	Public developer preview app manifest schema





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 18>

————————————————————————

<doc 19>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Deploy Microsoft Teams app to the cloud using Microsoft Visual Studio
	•	2024-03-13
In this article
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit) helps to deploy or upload the front-end and back-end code in your app to your provisioned cloud resources in Azure.
You can deploy your Teams app to the following cloud resources:
	•	Azure App Services
	•	Azure Functions
	•	Azure Storage (as static website)
	•	SharePoint
Note
Before you deploy your app code to Azure cloud, you need to complete the provisioning of cloud resources.
To deploy Teams app using Agents Toolkit, follow these steps:
	1	Open Visual Studio.
	2	Select Create a new project or open an existing project from the list.
	3	Select Project > Microsoft 365 Agents Toolkit > Deploy to the Cloud. 
	4	In the pop-up window that appears, select Deploy.  The app is deployed to Azure cloud.
Customize deploy lifecycle in Teams using Visual Studio
To customize the deployment process, you can edit the following deploy sections in the m365agents.yml file:
	•	cli/runNpmCommand
	•	cli/runDotnetCommand
	•	cli/runNpxCommand
	•	azureAppService/zipDeploy
	•	azureFunctions/zipDeploy
	•	azureStorage/deploy
cli/runNpmCommand
This action executes npm commands under specified directory with parameters.
Sample
 - uses: cli/runNpmCommand
  with:
   workingDirectory: ./src
   args: install
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to run the command. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
args
command arguments
Yes
NA
cli/runDotnetCommand
This action executes dotnet commands under specified directory with parameters.
Sample
 - uses: cli/runDotnetCommand
  with:
   workingDirectory: ./src
   execPath: /YOU_DOTNET_INSTALL_PATH
   args: publish --configuration Release --runtime win-x86 --self-contained
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to run the command. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
args
npm command arguments
Yes
NA
execPath
executor path
No
System PATH
cli/runNpxCommand
This action executes npx commands under specified directory with parameters. You can use it to run gulp commands for bundling and packaging sppkg.
Sample
 - uses: cli/runNpxCommand
  with:
   workingDirectory: ./src
   args: gulp package-solution --ship --no-color
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to run the command. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
args
command arguments
Yes
NA
azureAppService/zipDeploy
This action uploads and deploys the project to Azure App Service using the zip deploy feature.
Sample
 - uses: azureAppService/zipDeploy
  with:
   workingDirectory: ./src
   artifactFolder: .
   ignoreFile: ./.webappignore
   resourceId: ${{BOT_AZURE_APP_SERVICE_RESOURCE_ID}}
   dryRun: false
   outputZipFile: ./.deployment/deployment.zip
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
artifactFolder
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
Yes
NA
ignoreFile
Specifies the file path of the ignored file used during upload. You can utilize this file to exclude certain files or folders from the artifactFolder. Its syntax is similar to the Git's ignore.
No
null
resourceId
Indicates the resource ID of an Azure App Service. It's generated automatically after running the provision command. If you already have an Azure App Service, you can find its resource ID in the Azure portal. For more information, see how to find resource ID.
Yes
NA
dryRun
You can set the dryRun parameter to true if you only want to test the preparation of the upload and don't intend to deploy it. This helps you verify that the packaging zip file is correct.
No
false
outputZipFile
Indicates the path of the zip file for the packaged artifact folder. It's relative to the workingDirectory. During deployment, it reconstructs this file reflects all folders and files in your artifactFolder, and removes any non-existent files or folder.
No
./.deployment/deployment.zip
azureFunctions/zipDeploy
This action uploads and deploys the project to Azure Functions using. For more information, see the zip deploy feature.
Sample
 - uses: azureFunctions/zipDeploy
  with:
   workingDirectory: ./src
   artifactFolder: .
   ignoreFile: ./.webappignore
   resourceId: ${{BOT_AZURE_APP_SERVICE_RESOURCE_ID}}
   dryRun: false
   outputZipFile: ./.deployment/deployment.zip
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
artifactFolder
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
Yes
NA
ignoreFile
Specifies the file path of the ignored file used during upload. You can utilize this file to exclude certain files or folders from the artifactFolder. Its syntax is similar to the Git's ignore.
No
null
resourceId
Indicates the resource ID of an Azure Functions. It's generated automatically after running the provision command. If you already have an Azure Functions, you can find its resource ID in the Azure portal. For more information, see how to find resource ID.
Yes
NA
dryRun
You can set the dryRun parameter to true if you only want to test the preparation of the upload and don't intend to deploy it. This helps you verify that the packaging zip file is correct.
No
false
outputZipFile
Indicates the path of the zip file for the packaged artifact folder. It's relative to the workingDirectory. During deployment, it reconstructs this file, reflecting all folders and files in your artifactFolder, and removes any non-existent files or folder.
No
./.deployment/deployment.zip
azureStorage/deploy
This action uploads and deploys the project to Azure Storage.
Sample
 - uses: azureStorage/deploy
  with:
   workingDirectory: ./src
   artifactFolder: .
   ignoreFile: ./.webappignore
   resourceId: ${{BOT_AZURE_APP_SERVICE_RESOURCE_ID}} 
Parameters
Parameter
Description
Required
Default value
workingDirectory
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
No
Project root
artifactFolder
Represents the folder where you want to upload the artifact. If your input value is a relative path, it's relative to the workingDirectory.
Yes
NA
ignoreFile
Specifies the file path of the ignored file used during upload. You can utilize this file to exclude certain files or folders from the artifactFolder. Its syntax is similar to the Git's ignore.
No
null
resourceId
Indicates the resource ID of an Azure Storage. It's generated automatically after running the provision command. If you already have an Azure Storage, you can find its resource ID in the Azure portal (see this link for more information).
Yes
NA
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Create and deploy an Azure cloud service
	•	Create new Teams app in Visual Studio
	•	Provision cloud resources using Visual Studio
	•	Edit Teams app manifest using Visual Studio
	•	[Debug your Teams app locally using Visual Studio]Deploy Microsoft Teams app to the cloud using Microsoft Visual Studio





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 19>

————————————————————————

<doc 20>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Agents Toolkit Visual Studio Overview
	•	2025-05-19
In this article
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit) makes it simple to get started with app development for Microsoft Teams using Microsoft Visual Studio.
	•	Start with a project template for common custom app built for your org (LOB app) scenarios or from a sample.
	•	Save setup time with automated app registration and configuration.
	•	Run and debug to Teams directly from familiar tools.
	•	Smart defaults for hosting in Microsoft Azure using infrastructure-as-code and Bicep.
	•	Bring your app to your organization or the Microsoft Teams Store using built-in publishing tools.

Available for Visual Studio
Agents Toolkit is available for free for Visual Studio 2022 Community, Professional, and Enterprise. For more information about installation and setup, see how to install Microsoft 365 Agents Toolkit.
Agents Toolkit
Visual Studio
Installation
Available in the Visual Studio Installer
Build with
C#, .NET, ASP.NET, and Blazor
Features
The following are the key features of Agents Toolkit:
	•	Project templates
	•	Automatic registration and configuration
	•	CodeLens to trigger Agents Toolkit lifecycle
	•	Agents Toolkit documentation
	•	Agent for Microsoft 365 Copilot
Note
CodeLens to trigger Agents Toolkit lifecycle, Agents Toolkit documentation, and agent for Microsoft 365 Copilot is available in public developer preview.
Project templates
You can start with the capability-focused templates such as tabs, bots, and message extensions or by following the existing samples if you're already familiar with Teams app development. Agents Toolkit reduces the complexity of getting started with the help of templates for custom app built for org scenarios and smart defaults to accelerate your time to production.
Perform the following the steps to select templates and app capability:
	1	Select File > New > Project.
	2	Enter Teams in the search box and from search results, select Microsoft Teams App template.
	3	Select Next. 
Automatic registration and configuration
You can save time and let the toolkit automatically register the app in Teams Developer Portal. When you first run or debug the app, Agents Toolkit automatically registers the Teams app to your Microsoft 365 tenant and configures settings such as Microsoft Entra ID for your Teams app. Sign in with your Microsoft 365 account to control where the app is configured and customize the Microsoft Entra manifest.
CodeLens to trigger Agents Toolkit lifecycle
Agents Toolkit provides developers with lifecycle actions and grants access to configuration definitions within the m365agents.yml file. You can now preview and trigger these predefined lifecycle actions using the CodeLens feature directly within the teamsapp.yml file. This streamlined process enhances the development workflow.

Agents Toolkit documentation
To view the Agents Toolkit documentation, follow these steps from Agents Toolkit:
	1	Select Project > Microsoft 365 Agents Toolkit.
	2	Select Microsoft 365 Agents Toolkit Documentation. 
A browser window opens to view the documentation.
Agent for Microsoft 365 Copilot
The latest version of Agents Toolkit incorporates numerous preview features designed to support agent for Microsoft 365 Copilot development. To enable and activate the preview feature, follow these steps:
	1	Select Tools > Options....  A pop-up window appears.
	2	Enter Copilot, select Preview Features.
	3	Select the Microsoft 365 Agents Toolkit: Develop Copilot Plugin (requires restart) checkbox.
	4	Select OK. 
Enhance the capabilities of Microsoft 365 Copilot by converting your app into an agent that helps user productivity in daily tasks and workflows. Activate these agents for Microsoft 365 Copilot using Agents Toolkit. Agents Toolkit agent supports specific capabilities, such as Custom Search Results and AI Assistant Bot [Preview].
TeamsFx .NET SDK reference
	•	Microsoft.Extensions.DependencyInjection Namespace
	•	Microsoft.TeamsFx Namespace
	•	Microsoft.TeamsFx.Configuration Namespace
	•	Microsoft.TeamsFx.Conversation Namespace
	•	Microsoft.TeamsFx.Helper Namespace
See also
Install Microsoft 365 Agents Toolkit





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 20>

————————————————————————

<doc 21>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Microsoft 365 Agents Toolkit Overview
	•	2025-05-19
In this article
Agents Toolkit (previously known as Teams Toolkit) makes it simple to get started with app development for Microsoft Teams, Outlook, and Microsoft 365 Copilot using Visual Studio Code.
	•	Create new apps from project templates for common app scenarios.
	•	Save setup time with automated app registration and configuration.
	•	Run and debug to Teams, Outlook, and Copilot directly from Visual Studio Code.
	•	Smart defaults for hosting in Azure using infrastructure-as-code and Bicep.
	•	Test with different configurations such as dev, test, and prod using the environment features.

Available for Visual Studio Code
Agents Toolkit is available as a free extension for Visual Studio Code. To get started, see install Agents Toolkit.
Agents Toolkit
Visual Studio Code
Installation
Available in the Visual Studio Code Marketplace
Build with
JavaScript, TypeScript, React, SPFx
Important
Agents Toolkit doesn't support building apps for Government Community Cloud (GCC), GCC High, Department of Defense (DoD), and Teams operated by 21Vianet environments.
Features
The following list provides the key features of Agents Toolkit:
Project templates
Save time getting started with new Teams apps using the capability-focused templates for tabs, bots, message extensions, and common app scenarios.

Composable automation tasks
Automate repetitive or tedious configuration using a composable task framework that creates app IDs, bot registrations, Microsoft Entra apps, and so on.
Multiple environments
Test your app with different groupings of hosted resources by creating unique configurations such as dev, test, and prod using the Environments features.
Quick access to Teams Developer Portal
You can access Teams Developer Portal where you can configure, publish, and manage your app. For more information, see manage your Teams apps using Developer Portal.

Debug tunneling for bots
Run and debug your bot projects using Visual Studio Code and the included Dev Tunnels features.
Microsoft 365 Agents Playground
Microsoft 365 Agents Playground (previously known as Teams App Test Tool) makes debugging bot-based apps effortless. You can chat with your bot and see its messages and Adaptive Cards as they appear in Teams. You don’t need a Microsoft 365 developer account, tunneling, or Teams app and bot registration to use Agents Playground. For more information, see Agents Playground.
See also
Install Microsoft 365 Agents Toolkit





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 21>

————————————————————————

<doc 22>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Create a new Teams app
	•	2025-05-19
In this article
In this section, you can learn how to create a new Microsoft Teams project using Microsoft Visual Studio Code.
Create a new Teams project using Visual Studio Code
You can build a new Teams project by selecting Create a New Agent/App in Microsoft 365 Agents Toolkit (previously known as Teams Toolkit). You can start from built-in Teams app templates or start from official Teams app samples in Agents Toolkit. What's more, Agents Toolkit supports to start with Outlook Add-in templates to build your own Outlook Add-ins.

To start with Teams capabilities, you can create the following types of Teams app:
App Types
Definition
Scenario-based Teams apps
This group of templates are designed for particular abstracted business scenarios that your teams app can serve for. For example notification bot, command bot, SSO-enabled tab, or Dashboard tab app.
Basic Teams apps
Basic Teams apps are just hello world Teams tab, bot, or message extension that you can create and customize based on your requirement.
Extend Teams App across Microsoft 365
This group of Teams app can be installed and run on Outlook and Office.com.
Create a new Teams app
The process to create a new Teams app is similar for all types of apps.
To create a basic Teams app:
	1	Open Visual Studio Code.
	2	Select the Microsoft 365 Agents Toolkit > Create a New Agent/App > select Teams App. 
	3	In this example, select Tab as app capability. 
	4	Select Basic Tab as app capability. 
	5	Select JavaScript as the programming language. 
	6	Select Default folder to store your project root folder in the default location. 
	7	Learn to change the default folder:
	1	Select Browse. 
	2	Select the location for project workspace. 
	8	The folder you select is the location for your project workspace. 
	1	Enter a suitable name for your app, such as helloworld, as the application name. Ensure that you use only alphanumeric characters. Press Enter.
	9	 The Teams tab app is created in a few seconds. 
I ran into an issue
Directory structure for different app types
Agents Toolkit provides all components for building an app. After creating the project, you can view the project folders and files under EXPLORER section.

Directory structure for basic Teams app
The following example shows a basic Teams tab app directory structure:
Folder name
Contents
.vscode
Settings for VS Code to build and debug your Teams app.
appPackage
App manifest (previously called Teams app manifest) file and icon files that Teams used to recognize your Teams app.
env
Stores different environment parameters.
infra
Azure bicep template files. Used for deploy your Teams app to Azure.
src
Source code for the Tab capability, including your front-end app, UI components and the privacy notice, terms of use,
src/app.js
Application entry point and express handlers for website.
src/views/hello.html
An HTML template that is bind to the tab endpoint.
src/static
The web server can serve static assets such as CSS and JavaScript files.
m365agents.yml
This configuration file defines the Agents Toolkit behavior for provision, deploy, and publish lifecycle. You can customize this file to change the behavior of Agents Toolkit in each lifecycle.
m365agents.local.yml
This overrides m365agents.yml with actions that enable local execution and debugging.
Note
If you have a bot or message extension app, relevant folders are added to the directory structure.
To learn more about the directory structure of different types of basic Teams apps, see the following table:
App Type
Links
For tab app
Build your first tab app using JavaScript
For bot app
Build your first bot app using JavaScript
For message extension app
Build your first message extension app using JavaScript

Directory structure for scenario-based Teams app
The following example shows a scenario-based notification bot Teams app directory structure:
The new project folder contains the following content:
Folder name
Contents
.vscode
Settings for VS Code to build and debug your Teams app.
appPackage
The app manifest file and icon files that Teams used to recognize your Teams app.
env
Stores different environment parameters.
infra
Azure bicep template files. Used for deploy your Teams app to Azure.
m365agents.yml
This configuration file defines the Agents Toolkit behavior for provision, deploy, and publish lifecycle. You can customize this file to change the behavior of Agents Toolkit in each lifecycle.
m365agents.local.yml
This overrides m365agents.yml with actions that enable local execution and debugging.
The core notification implementation is stored in the src folder and it contains:
File name
Contents
src\adaptiveCards\
Templates for Adaptive Card.
src\internal\
Generated initialize code for notification functionality.
src\index.ts
The entry point to handle bot messages and send notifications.
.gitignore
File to exclude local files from the bot project.
package.json
The npm package file for the bot project.
Note
If you have a command bot, workflow bot, SSO-enabled tab, or SPFx tab app, relevant folders are added to the directory structure.
To learn more about the directory structure of different types of scenario-based Teams apps, see the following table:
App Type
Links
For notification bot app
Send notification to Teams
For command bot app
Build command bot
For workflow bot app
Create Teams workflow bot
For SPFx tab app
Build a Teams app with SPFx

See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Build a Teams app with Blazor
	•	Build a Teams app with C# or .NET
	•	Prerequisites for all types of environment and create your Teams app
	•	Prepare to build apps using Agents Toolkit





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 22>

————————————————————————

<doc 23>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Prerequisites for creating your Teams app
	•	2025-05-19
In this article
Before you create your Microsoft Teams app project, ensure that the prerequisites are in place. You must:
	•	Install required tools to build your Teams app
	•	Prepare Accounts to build your Teams app
	•	Verify custom app upload permission
Install required tools to build your Teams app
Ensure the following requirements are met before you start building your Teams app:
 
Tools
Purpose
For environment type
Required
 
 
 
 
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit)
A Microsoft Visual Studio Code extension that creates a project scaffolding for your app. Use the latest version.
JavaScript and SPFx
 
Microsoft Teams
Collaborate with everyone you work with through apps for chat, meetings, and call - all in one place.
JavaScript and SPFx
 
Node.js
Back-end JavaScript runtime environment. For more information, see Node.js version compatibility table for project type.
JavaScript and SPFx
 
Node Package Manager (NPM)
Install and manage packages for use in both Node.js and ASP.NET Core applications.
JavaScript and SPFx
 
Microsoft Edge (recommended) or Google Chrome
A browser with developer tools.
JavaScript and SPFx
 
Microsoft Visual Studio Code
JavaScript, TypeScript, or SPFx build environments. Use the latest version.
JavaScript and SPFx
Optional
 
 
 
 
Azure Tools for Visual Studio Code and Azure CLI
Access stored data or deploy a cloud-based back end for your Teams app in Azure.
JavaScript
 
React Developer Tools for Chrome or React Developer Tools for Microsoft Edge
A browser DevTools extension for the open-source React JavaScript library.
JavaScript
 
Microsoft Graph Explorer
A browser-based tool that lets you run a query from Microsoft Graph data.
JavaScript and SPFx
 
Developer Portal for Teams
A web-based portal to configure, manage, and publish your Teams app to your organization or the Teams Store.
JavaScript and SPFx
Accounts to build your Teams app
Ensure that you have the following accounts before you start building your Teams app:
Accounts
Purpose
For environment type
Microsoft 365 work or school account
Teams developer account while developing an app.
JavaScript, TypeScript, SPFx, and C# or Blazor.
Azure account
Back-end resources on Azure.
JavaScript, TypeScript, SPFx, and C# or Blazor.
SharePoint collection site administrator account
Deployment for hosting.
SPFx.
Microsoft 365 developer program
Note
To build Teams apps, you must have a work or school Microsoft 365 account. Microsoft 365 personal account can't be used.
If you have a Visual Studio Enterprise or Professional subscription, both programs include a free Microsoft 365 developer subscription. It's active as long as your Visual Studio subscription is active. For more information, see Microsoft 365 developer subscription.
If you don't have any Microsoft 365 tenant, you might qualify for a Microsoft 365 E5 developer subscription through the Microsoft 365 Developer Program; for details, see the FAQ. Alternatively, you can sign up for a 1-month free trial or purchase a Microsoft 365 plan.
You can sign up for the developer program using one of the following account types:
	•	Microsoft account for personal use The Microsoft account provides access to the Microsoft products and cloud services, such as Outlook, Messenger, OneDrive, MSN, Xbox Live, or Microsoft 365. Sign up for an Outlook.com mailbox to create a Microsoft 365 account. Use it to access consumer-related Microsoft cloud services or Azure.    
	•	Microsoft work account for business This account provides access to all small, medium, and enterprise business-level Microsoft cloud services. The services include Azure, Microsoft Intune, and Microsoft 365. When you sign up to one of these services as an organization, a cloud-based directory is automatically provisioned in Microsoft Entra ID to represent your organization.    
Create a free Microsoft 365 developer account
To create a free Microsoft 365 developer account:
	1	Go to the Microsoft 365 developer program.
	2	Select Join Now.
	3	Set up your administrator account subscription. After the completion of the subscription, the following information appears: 
Azure account
An Azure account allows you to host a Teams app or the back-end resources for your Teams app to Azure. You can do this using Agents Toolkit in Visual Studio Code. You must have an Azure subscription in the following scenarios:
	•	If you already have an existing app on a different cloud provider other than Azure, and you want to integrate the app on Teams platform.
	•	If you want to host the back-end resources for your app using another cloud provider, or on your own servers if they're available in the public domain.
Note
You can use Azure account to provision Azure resource to host your Teams app. You can create a free account in case you don't have any. If you don't use Agents Toolkit to provision and deploy, Azure account isn't required.
SharePoint collection site administrator account
While creating Teams app using SPFx environment, you must have a SharePoint collection site administrator account. It’s required for deploying and hosting your app on SharePoint site. If you're using a Microsoft 365 developer program tenant, you can use the administrator account you created at the time.
Verify custom app upload permission
After creating the app, you must load your app in Teams without distributing it. This process is known as custom app upload. Sign in to your Microsoft 365 account to view this option.
You can verify if the app upload permission is enabled using either Visual Studio Code or Teams client.

Verify custom app upload permission using Visual Studio Code
You can use this method to verify custom app upload permission only after you have created an app project using Agents Toolkit. If you haven't created an app project, you can verify custom app upload permission using Teams client.
	1	Open Visual Studio Code.
	2	Select Microsoft 365 Agents Toolkit from the Visual Studio Code activity bar. Note If you're unable to see the option, see install Agents Toolkit to install Agents Toolkit extension in Visual Studio Code. 
	3	Create a new Agents Toolkit app project or open an existing app project.
	4	Select Sign in to Microsoft 365 under ACCOUNTS. 
	5	Verify if you can see the option Custom App Upload Enabled as shown in the following image: 

Verify custom app upload permission using Teams client
	1	In the Teams client, select Apps > Manage your apps > Upload an app. 
	2	Check if you can see the option Upload a custom app. 
Enable custom app upload using admin center
If the custom app upload option isn’t visible in Agents Toolkit extension in Visual Studio Code or if the option to upload a custom app isn’t available in Teams, it indicates that you don't have the required permission for custom app upload.
You must enable custom app upload in Teams:
	•	If you're a Teams Administrator, enable the custom app upload setting for your tenant or organization in the Teams admin center.
	•	If you aren't a Teams Administrator, contact your admin to enable custom app upload.
If you have admin rights, you can enable custom app upload:
	1	Sign in to Microsoft 365 admin center with your admin credentials.
	2	Select the icon > Teams.  Note It can take up to 24 hours for the Teams option to appear. You can upload your custom app to a Teams environment for testing and validation. 
	3	Sign in to Microsoft Teams admin center with your admin credentials.
	4	Select the icon > Teams apps > Setup policies. 
	5	Select Global (Org-wide default). 
	6	Set Upload custom apps toggle to On. 
	7	Select Save. Note It can take up to 24 hours for custom app upload to become active. In the meantime, you can use upload for your tenant to test your app. To upload the .zip package file of the app, see upload custom apps.  Ensure that you have the app upload permission using the steps mentioned in verify custom app upload permission using Visual Studio Code or Teams client.
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Manage custom app policies and settings in Teams
	•	Manage app setup policies in Teams





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 23>

————————————————————————

<doc 24>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Publish Teams apps using Microsoft 365 Agents Toolkit
	•	2025-05-19
In this article
After creating the app, you can publish your app to different scopes, such as an individual, a team, or an organization. The distribution depends on multiple factors such as needs, business and technical requirements, and your goal for the app. Distribution to different scope may need different review process. In general, the bigger the scope, the more review the app needs to go through for security and compliance concerns.

Here's what you'll learn in this section:
	•	Publish to individual scope or custom app upload permission
	•	Publish to your organization
	•	Publish to Microsoft Teams Store
Prerequisites
	•	Ensure to create your app package and validate it for errors.
	•	Enable custom app uploading in Teams.
	•	Ensure that your app is running and accessible using HTTPs.
	•	Ensure you have followed set of guidelines in the publish your app to the Teams Store to publish your app.
Publish to individual scope or custom app upload permission
You can add a custom app to Microsoft Teams by uploading an app package in .zip file directly to a team or in personal context. Adding a custom app by uploading an app package is known as custom app upload. It allows you to test app while being uploaded in Teams. You can build and test app in the following scenarios:
	•	Test and debug an app locally.
	•	Build an app for yourself, such as to automate a workflow.
	•	Build an app for small set of users, such as, your work group.
You can build an app for internal use and share it with your team without submitting it to the Microsoft Teams app catalog in the Teams Store . For more information, see how to upload your app in Teams.
Build app package
You need to run Provision in the cloud before you build the app package. The following step helps you to build the app package:
Select Zip Teams App Package > UTILITY. The generated app package is located in {your project folder}\appPackage\build\appPackage.{env}.zip.
Upload app package
Perform the following steps to upload app package:
	1	In the Teams client, select Apps > Manage your apps > Upload an app.  The Upload an app window appears.
	2	Select Upload a custom app.  Now, the custom app is uploaded into the Teams client and you can add and view it.
Publish to your organization
When the app is ready for use in production, you can submit the app using the Teams app submission API, called from Microsoft Graph API. Teams app submission API is an integrated development environment (IDE) such as Microsoft Visual Studio Code installed with Agents Toolkit (previously known as Teams Toolkit). The following steps help you to publish the app to your organization:
	•	Publish from Agents Toolkit
	•	Approve on admin center
Publish from Agents Toolkit
Note
You can use CICD pipelines to publish your Teams app. For more information, see set up CI/CD pipelines.
The following steps help you to publish the app from Agents Toolkit:
	1	You can publish your Teams app in one of the following ways:
	◦	Select Publish under LIFECYCLE.
	◦	Select View > Command Palette... > Teams: Publish to Organization. 
	2	Select your environment, Agents Toolkit runs the publish lifecycle defined in m365agents.yml. 
Now the app is available on the Manage apps of Microsoft Teams admin center, where you and the admin can review and approve it.
Note
The app doesn't publish to your organization's app store yet. The step submits the app to the Teams admin center where you can approve it for publishing to your organization's app store.
Approve on admin center
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit) for Visual Studio Code built on top of the Teams App Submission API and it allows you to automate the submission-to-approval process for custom apps on Teams.
Note
Ensure that you have Teams app project in Visual Studio code. As an admin, Manage apps in the Microsoft Teams admin center is where you can view and manage all Teams apps for your organization. You can do the following activities in the admin center:
	•	See the org level status and properties of apps.
	•	Approve or upload new custom apps to your organization's app store.
	•	Block or allow apps at the org level.
	•	Add apps to Teams.
	•	Purchase services for third-party apps.
	•	View permissions requested by apps.
	•	Grant admin consent to apps in manage org wide app settings..
The following steps help you to approve from admin center:
	1	Select Go to admin portal.
	2	Select the icon > Teams apps > Manage apps.  You can view all Teams app for your organization. In the Pending approval widget at the top of the page, lets you know when a custom app is submitted for approval. In the table, a newly submitted app automatically publishes the status of submitted and blocked apps. You can sort the publishing status column in descending order to find the app. 
	3	Select the app name to go to the app details page. On the About tab, you can view details about the app, including description, status, and app ID. 
	4	Select the status dropdown and change from Submitted to Publish. After you publish the app, the publishing status changes to Published and the status automatically changes to Allowed. For more information, see Publish to your org
Publish to Teams Store
You can publish your app directly to the Teams Store inside Microsoft Teams and reach millions of users around the world. If your app is also featured in the Teams Store, you can instantly reach potential customers. The apps published to the Teams Store also automatically list on Microsoft AppSource, which is the official marketplace for Microsoft 365 apps and solutions.
For more information, see how to publish to the Teams Store.
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Distribute your Microsoft Teams app
	•	Create Teams app package
	•	Prepare your Microsoft 365 tenant
	•	Manage Teams app in the Microsoft Teams admin center





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 24>

————————————————————————

<doc 25>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Publish Teams apps using Microsoft 365 Agents Toolkit
	•	2025-05-19
In this article
After creating the app, you can publish your app to different scopes, such as an individual, a team, or an organization. The distribution depends on multiple factors such as needs, business and technical requirements, and your goal for the app. Distribution to different scope may need different review process. In general, the bigger the scope, the more review the app needs to go through for security and compliance concerns.

Here's what you'll learn in this section:
	•	Publish to individual scope or custom app upload permission
	•	Publish to your organization
	•	Publish to Microsoft Teams Store
Prerequisites
	•	Ensure to create your app package and validate it for errors.
	•	Enable custom app uploading in Teams.
	•	Ensure that your app is running and accessible using HTTPs.
	•	Ensure you have followed set of guidelines in the publish your app to the Teams Store to publish your app.
Publish to individual scope or custom app upload permission
You can add a custom app to Microsoft Teams by uploading an app package in .zip file directly to a team or in personal context. Adding a custom app by uploading an app package is known as custom app upload. It allows you to test app while being uploaded in Teams. You can build and test app in the following scenarios:
	•	Test and debug an app locally.
	•	Build an app for yourself, such as to automate a workflow.
	•	Build an app for small set of users, such as, your work group.
You can build an app for internal use and share it with your team without submitting it to the Microsoft Teams app catalog in the Teams Store . For more information, see how to upload your app in Teams.
Build app package
You need to run Provision in the cloud before you build the app package. The following step helps you to build the app package:
Select Zip Teams App Package > UTILITY. The generated app package is located in {your project folder}\appPackage\build\appPackage.{env}.zip.
Upload app package
Perform the following steps to upload app package:
	1	In the Teams client, select Apps > Manage your apps > Upload an app.  The Upload an app window appears.
	2	Select Upload a custom app.  Now, the custom app is uploaded into the Teams client and you can add and view it.
Publish to your organization
When the app is ready for use in production, you can submit the app using the Teams app submission API, called from Microsoft Graph API. Teams app submission API is an integrated development environment (IDE) such as Microsoft Visual Studio Code installed with Agents Toolkit (previously known as Teams Toolkit). The following steps help you to publish the app to your organization:
	•	Publish from Agents Toolkit
	•	Approve on admin center
Publish from Agents Toolkit
Note
You can use CICD pipelines to publish your Teams app. For more information, see set up CI/CD pipelines.
The following steps help you to publish the app from Agents Toolkit:
	1	You can publish your Teams app in one of the following ways:
	◦	Select Publish under LIFECYCLE.
	◦	Select View > Command Palette... > Teams: Publish to Organization. 
	2	Select your environment, Agents Toolkit runs the publish lifecycle defined in m365agents.yml. 
Now the app is available on the Manage apps of Microsoft Teams admin center, where you and the admin can review and approve it.
Note
The app doesn't publish to your organization's app store yet. The step submits the app to the Teams admin center where you can approve it for publishing to your organization's app store.
Approve on admin center
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit) for Visual Studio Code built on top of the Teams App Submission API and it allows you to automate the submission-to-approval process for custom apps on Teams.
Note
Ensure that you have Teams app project in Visual Studio code. As an admin, Manage apps in the Microsoft Teams admin center is where you can view and manage all Teams apps for your organization. You can do the following activities in the admin center:
	•	See the org level status and properties of apps.
	•	Approve or upload new custom apps to your organization's app store.
	•	Block or allow apps at the org level.
	•	Add apps to Teams.
	•	Purchase services for third-party apps.
	•	View permissions requested by apps.
	•	Grant admin consent to apps in manage org wide app settings..
The following steps help you to approve from admin center:
	1	Select Go to admin portal.
	2	Select the icon > Teams apps > Manage apps.  You can view all Teams app for your organization. In the Pending approval widget at the top of the page, lets you know when a custom app is submitted for approval. In the table, a newly submitted app automatically publishes the status of submitted and blocked apps. You can sort the publishing status column in descending order to find the app. 
	3	Select the app name to go to the app details page. On the About tab, you can view details about the app, including description, status, and app ID. 
	4	Select the status dropdown and change from Submitted to Publish. After you publish the app, the publishing status changes to Published and the status automatically changes to Allowed. For more information, see Publish to your org
Publish to Teams Store
You can publish your app directly to the Teams Store inside Microsoft Teams and reach millions of users around the world. If your app is also featured in the Teams Store, you can instantly reach potential customers. The apps published to the Teams Store also automatically list on Microsoft AppSource, which is the official marketplace for Microsoft 365 apps and solutions.
For more information, see how to publish to the Teams Store.
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Distribute your Microsoft Teams app
	•	Create Teams app package
	•	Prepare your Microsoft 365 tenant
	•	Manage Teams app in the Microsoft Teams admin center





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 25>

————————————————————————

<doc 26>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Provision cloud resources
	•	2024-03-13
In this article
TeamsFx integrates with Azure and the Microsoft 365 cloud, which allows to place your app in Azure with a single command. TeamsFx integrates with Azure Resource Manager (ARM), which enables to provision Azure resources that your application needs for code approach.
Provision using Microsoft 365 Agents Toolkit in Visual Studio Code
You can trigger the provision command in Agents Toolkit (previously known as Teams Toolkit) or Microsoft 365 Agents Toolkit CLI (previously known as TeamsFx CLI) to create or update resources for your application. The steps of the provision command are defined in the m365agents.yml file, under provision property. You can view the file to understand what resources are created.
Note
Azure services incur costs in your subscription. For more information on cost estimation, see pricing calculator.
Provision actions
The following list shows the actions designed for provision.
teamsApp/create
What it is
If the environment variable that stores Teams app ID is empty or the app ID isn't found from Teams Developer Portal, then this action creates a new Teams app.
What resource it operates
Teams app in Teams Developer Portal.
How to use it
 - uses: teamsApp/create
  with:
   # #required. Name of Teams app
   name: <your-preferred-app-name>
  # Write the information of created resources into environment file for the specified environment variable(s).
  writeToEnvironmentFile:
   # The id for Teams app
   teamsAppId: <your-preferred-env-var-name>
teamsApp/update
What it is
Apply the app manifest (previously called Teams app manifest) to an existing Teams app in Teams Developer Portal. It uses the app ID in the manifest.json file to determine which Teams app to update.
What resource it operates
Teams app in Teams Developer Portal.
How to use it
- uses: teamsApp/update
  with:
   # Required. Relative path to the yaml file. This is the path for built zip file.
   appPackagePath: <path-to-teams-app-package-file>
teamsApp/validateManifest
What it is
This action renders the app manifest template with environment variables and validates the app manifest file using its schema.
What resource it operates
N/A
How to use it
 - uses: teamsApp/validate
  with:
   # Required. Relative path to the yaml file. Path to app manifest file
   manifestPath: <path-to-manifest-file>
teamsApp/validateAppPackage
What it is
This action validates Teams app package using validation rules.
What resource it operates
N/A
How to use it
 - uses: teamsApp/validateAppPackage
  with:
   # Required. Relative path to the yaml file. This is the path for built zip file.
   appPackagePath: <path-to-teams-app-package-file>
teamsApp/zipAppPackage
What it is
This action renders the app manifest template with environment variables and compresses the app manifest file with two icons into a zip file.
What resource it operates
N/A
How to use it
- uses: teamsApp/zipAppPackage
  with:
   # Required. Relative path to the yaml file. This is the path for app manifest file. Environment variables in manifest will be replaced before apply to Microsoft Entra app.
   manifestPath: <path-to-manifest-file>
   # Required. Relative path to the yaml file. This is the path for built zip file.
   outputZipPath: <path-to-generated-zip-file>
   # Required. Relative path to the yaml file. This is the path for built manifest json file.
   outputJsonPath: <path-to-generated-json-file>
teamsApp/publishAppPackage
What it is
This action publishes built Teams app zip file to tenant app catalog.
What resource it operates
Teams app in Microsoft 365 tenant app catalog.
How to use it
- uses: teamsApp/publishAppPackage
  with:
   # Required. Relative path to this file. This is the path for built zip file.
   appPackagePath: <path-to-teams-app-package>
  # Write the information of created resources into environment file for the specified environment variable(s).
  writeToEnvironmentFile:
   # The Teams app id in tenant app catalog.
   publishedAppId: <your-preferred-env-var-name>
aadApp/create
What it is
This action creates a new Microsoft Entra application to authenticate users if the environment variable that stores clientId is empty.
What resource it operates
Microsoft Entra ID in your Microsoft 365 tenant.
How to use it
- uses: aadApp/create
  with:
   # Required. The Microsoft Entra app's display name. When you run aadApp/update, the Microsoft Entra app name will be updated based on the definition in manifest. If you don't want to change the name, make sure the name in Microsoft Entra app manifest is the same with the name defined here.
   name: <your-application-name>
   # Required. If the value is false, the action will not generate client secret for you
   generateClientSecret: true
   # Required. Specifies what Microsoft accounts are supported for the current application. Supported values are: `AzureADMyOrg`, `AzureADMultipleOrgs`, `AzureADandPersonalMicrosoftAccount`, `PersonalMicrosoftAccount`.
   signInAudience: "AzureADMyOrg"
  # Write the information of created resources into environment file for the specified environment variable(s).
  writeToEnvironmentFile:
   # Required. The client (application) ID of Microsoft Entra application. The action will refer the environment variable defined here to determine whether to create a new Microsoft Entra app.
   clientId: <your-preferred-env-var-name>
   # Required when `generateClientSecret` is `true`. The action will refer the environment variable defined here to determine whether to create a new client secret. It's recommended to add `SECRET_` prefix to the environment variable name so it will be stored to the .env.{envName}.user environment file.
   clientSecret: <your-preferred-env-var-name>
   # Required. The object ID of Microsoft Entra application
   objectId: <your-preferred-env-var-name>
   # Optional. The tenant ID of Microsoft Entra tenant
   tenantId: <your-preferred-env-var-name>
   # Optional. The Microsoft Entra authority
   authority: <your-preferred-env-var-name>
   # Optional. The host name of Microsoft Entra authority
   authorityHost: <your-preferred-env-var-name>
aadApp/update
What it is
This action updates your Microsoft Entra application based on give Microsoft Entra app manifest. It refers to the ID property in Microsoft Entra app manifest to determine which Microsoft Entra app to update.
What resource it operates
Microsoft Entra ID in your Microsoft 365 tenant.
How to use it
- uses: aadApp/update
  with:
   # Required. Relative path to the yaml file. Path to the Microsoft Entra app manifest. Environment variables in manifest will be replaced before apply to Microsoft Entra app.
   manifestPath: <path-to-manifest-file>
   # Required. Relative path to the yaml folder. This action will output the final Microsoft Entra app manifest used to update Microsoft Entra app to this path.
   outputFilePath : <path-to-output-file>
botAadApp/create
What it is
This action creates a new or reuses an existing Microsoft Entra application for bot.
What resource it operates
Microsoft Entra ID in your Microsoft 365 tenant.
How to use it
- uses: botAadApp/create
  with:
   # Required. The Microsoft Entra app's display name
   name: <your-app-name>
  writeToEnvironmentFile:
   # The Microsoft Entra app's client id created for bot.
   botId: <your-preferred-env-var-name>
   # The Microsoft Entra app's client secret created for bot. 
   botPassword: <your-preferred-env-var-name>
arm/deploy
What it is
This action deploys given ARM templates in parallel.
What resource it operates
Azure subscription.
How to use it
- uses: arm/deploy
  with:
   # Required. You can use built-in environment variable `AZURE_SUBSCRIPTION_ID` here. TeamsFx will ask you select one subscription if its value is empty. You're free to reference other environment variable here, but TeamsFx will not ask you to select subscription if it's empty in this case.
   subscriptionId: ${{AZURE_SUBSCRIPTION_ID}}
   # Required. You can use built-in environment variable `AZURE_RESOURCE_GROUP_NAME` here. TeamsFx will ask you to select or create one resource group if its value is empty. You're free to reference other environment variable here, but TeamsFx will not ask you to select or create resource group if it's empty in this case.
   resourceGroupName: ${{AZURE_RESOURCE_GROUP_NAME}}
   # Required. The ARM templates to be deployed.
   templates:
    # Required. Relative path to the yaml file.
   - path: <path-to-arm-template>
    # Optional. Relative path to the yaml file. TeamsFx will replace the environment variable reference with real value before deploy ARM template.
    parameters: <path-to-arm-template-parameter>
    # Required. Name of the ARM template deployment.
    deploymentName: <arm-deployment-name>
   # Optional. Agents Toolkit will download this bicep CLI version from github for you, will use bicep CLI in PATH if you remove this config.
   bicepCliVersion: v0.9.1
azureStorage/enableStaticWebsite
What it is
This action enables static website setting in Azure Storage.
What resource it operates
Azure Storage.
How to use it
- uses: azureStorage/enableStaticWebsite
  with:
   # Required. The resource id of Azure Storage
   storageResourceId: ${{<env-name-of-azure-storage-resource-id>}}
   # Required. The path to index page.
   indexPage: <path-to-index-page>
   # Required. The path to error page.
   errorPage: <path-to-error-page>
azureStaticWebApps/getDeploymentToken
What it is
This action retrieves the deployment token from Azure Static Web Apps.
Version Info
v1.4
What resource it operates
Azure Static Web Apps.
How to use it
- uses: azureStaticWebApps/getDeploymentToken
  with:
   resourceId: ${{AZURE_STATIC_WEB_APPS_RESOURCE_ID}}
  writeToEnvironmentFile:
   deploymentToken: SECRET_TAB_SWA_DEPLOYMENT_TOKEN
script
What it is
This action executes a user-defined script.
What resource it operates
N/A
How to use it
- uses: script
  with:
   # Required. Command to run or path to the script. Succeeds if exit code is 0. '::set-teamsfx-env key=value' is a special command to generate output variables into .env file, in this case, "mykey=abc" will be added the output in the corresponding .env file.
   run: $my_key="abc"; echo "::set-teamsfx-env mykey=${my_key}"
   # Optional. Available values are: bash, sh, powershell(Powershell Desktop), pwsh(powershell core), cmd. If omitted, it defaults to bash on Linux/MacOS, defaults to pwsh on windows.
   shell: <shell-name>
   # Optional. Current working directory. Defaults to the directory of this file.
   workingDirectory: <working-directory>
   # Optional. Timeout in ms.
   timeout: <timeout-in-ms>
   # Optional. Redirect stdout and stderr to a file.
   redirectTo: <path-to-output-file>
Customize resource provision
The provision steps are defined in m365agents.yml file, under provision property. You can add, remove, or update actions to the provision property to define the expected actions you want to do during provision.
Reference environment variables in parameter files
Agents Toolkit supports referencing the values from environment variables in m365agents.yml, app manifest, Microsoft Entra app manifest, and Azure parameter files. You can use syntax ${{ENV_VARIABLE_NAME}} to reference environment variables.
The following example sets the value of environment variable MY_AZURE_SUBSCRIPTION_ID to subscriptionId:
subscriptionId: ${{MY_AZURE_SUBSCRIPTION_ID}}
Customize ARM template files
If the predefined templates don't meet your app requirements, you can create your own ARM template or update existing ARM template and provide the path to arm/deploy action as in the following template:
- uses: arm/deploy
  with:
   subscriptionId: ${{AZURE_SUBSCRIPTION_ID}}
   resourceGroupName: ${{AZURE_RESOURCE_GROUP_NAME}}
   templates:
   - path: <path-to-your-arm-template>
    parameters: <path-to-your-parameter-file>
    deploymentName: <arm-deployment-name>
   bicepCliVersion: <bicep-cli-version>
The arm/deploy action support ARM templates written in bicep and json format. If you use json format, you can omit the bicepCliVersion parameter. You need to have basic knowledge of Azure Resource Manager. You can get started with Azure Resource Manager at Azure Resource Manager documentation.
Customize Teams apps
You can customize your bot or the Teams app by adding environment variables to use a Microsoft Entra app created by you. Ways to customize the Teams app are:
	•	Use an existing Microsoft Entra app for your Teams app
	•	Use an existing Microsoft Entra app for your bot

Use an existing Microsoft Entra app for your Teams app
You can follow the steps to add environment variables to the .env files to use a Microsoft Entra app created for your Teams app. If you don't have a Microsoft Entra app yet or you already have one but don't know where to find the correct value, see how to use existing Microsoft Entra app in TeamsFx project.
	1	Open m365agents.yml and find the aadApp/create action.
	2	Find the environment variable names that store information for Microsoft Entra app in the writeToEnvironmentFile property. The default writeToenvironmentFile definition if you create projects using Agents Toolkit is as follows:  writeToEnvironmentFile:
	3	 clientId: AAD_APP_CLIENT_ID
	4	 clientSecret: SECRET_AAD_APP_CLIENT_SECRET
	5	 objectId: AAD_APP_OBJECT_ID
	6	 tenantId: AAD_APP_TENANT_ID
	7	 authority: AAD_APP_OAUTH_AUTHORITY
	8	 authorityHost: AAD_APP_OAUTH_AUTHORITY_HOST
	9	
	10	Add values for each environment variable from step 2.
	1	Add the following environment variables and their values to env\.env.{env} file.  AAD_APP_CLIENT_ID=<value of Microsoft Entra application's client id (application id)> # example: 00000000-0000-0000-0000-000000000000
	2	 AAD_APP_OBJECT_ID=<value of Microsoft Entra application's object id> # example: 00000000-0000-0000-0000-000000000000
	3	 AAD_APP_TENANT_ID=<value of Microsoft Entra's tenant id>> # example: 00000000-0000-0000-0000-000000000000
	4	 AAD_APP_OAUTH_AUTHORITY=<value of Microsoft Entra's authority> # example: https://login.microsoftonline.com/<Directory (tenant) ID>
	5	 AAD_APP_OAUTH_AUTHORITY_HOST=<host of Microsoft Entra's authority> # example: https://login.microsoftonline.com
	6	 AAD_APP_ACCESS_AS_USER_PERMISSION_ID=<id of access_as_user permission> # example: 00000000-0000-0000-0000-000000000000
	7	
	8	If your application requires a Microsoft Entra app client secret, add the following environment variable and its value to env\.env.{env}.user file. SECRET_AAD_APP_CLIENT_SECRET=<value of Microsoft Entra application's client secret>
	9	
Note
	•	Remember to update the environment variable names in the examples if you use different names in writeToEnvironmentFile.
	•	If you don't use aadApp/create action to create Microsoft Entra application, you can add necessary environment variables with your preferred name without following above steps.
	•	Ensure not to share the same Microsoft Entra app in multiple environments.

Use an existing Microsoft Entra app for your bot
You can follow the steps to add environment variables to the .env files to use a Microsoft Entra app created for your Teams app. If you don't have a Microsoft Entra app for your bot yet or you already have one but don't know where to find the correct values, see Use existing Microsoft Entra app in TeamsFx project.
	1	Open m365agents.yml and find the botAadApp/create action.
	2	Find the environment variable names that store information for Microsoft Entra app in the writeToEnvironmentFile property. The default writeToEnvironmentFile definition if you create projects using Agents Toolkit is as follows:  writeToEnvironmentFile:
	3	  botId: BOT_ID
	4	  botPassword: SECRET_BOT_PASSWORD
	5	
	6	Add values for each environment variable from step 2.
	1	Add the following environment variable and its value to env\.env.{env} file. BOT_ID=<value of Microsoft Entra application's client id (application id)> # example: 00000000-0000-0000-0000-000000000000  
	2	
	3	Add the following environment variable and its value to env\.env.{env}.user file. SECRET_BOT_PASSWORD=<value of Microsoft Entra application's client secret>
	4	
Note
	•	Remember to update the environment variable names in the examples if you use different names in writeToEnvironmentFile.
	•	If you don't use botAadApp/create action to create Microsoft Entra application, you can add necessary environment variables with your preferred name without following above steps.
	•	Ensure not to share the same Microsoft Entra app in multiple environments.
See also
Deploy Teams app to the cloud





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 26>

————————————————————————

<doc 27>

Skip to main content





Table of contents Exit focus mode



Table of contents Add Edit

Share via
Facebook x.com LinkedIn Email

Print
Prerequisites for creating your Teams app
	•	2025-05-19
In this article
Before you create your Microsoft Teams app project, ensure that the prerequisites are in place. You must:
	•	Install required tools to build your Teams app
	•	Prepare Accounts to build your Teams app
	•	Verify custom app upload permission
Install required tools to build your Teams app
Ensure the following requirements are met before you start building your Teams app:
 
Tools
Purpose
For environment type
Required
 
 
 
 
Microsoft 365 Agents Toolkit (previously known as Teams Toolkit)
A Microsoft Visual Studio Code extension that creates a project scaffolding for your app. Use the latest version.
JavaScript and SPFx
 
Microsoft Teams
Collaborate with everyone you work with through apps for chat, meetings, and call - all in one place.
JavaScript and SPFx
 
Node.js
Back-end JavaScript runtime environment. For more information, see Node.js version compatibility table for project type.
JavaScript and SPFx
 
Node Package Manager (NPM)
Install and manage packages for use in both Node.js and ASP.NET Core applications.
JavaScript and SPFx
 
Microsoft Edge (recommended) or Google Chrome
A browser with developer tools.
JavaScript and SPFx
 
Microsoft Visual Studio Code
JavaScript, TypeScript, or SPFx build environments. Use the latest version.
JavaScript and SPFx
Optional
 
 
 
 
Azure Tools for Visual Studio Code and Azure CLI
Access stored data or deploy a cloud-based back end for your Teams app in Azure.
JavaScript
 
React Developer Tools for Chrome or React Developer Tools for Microsoft Edge
A browser DevTools extension for the open-source React JavaScript library.
JavaScript
 
Microsoft Graph Explorer
A browser-based tool that lets you run a query from Microsoft Graph data.
JavaScript and SPFx
 
Developer Portal for Teams
A web-based portal to configure, manage, and publish your Teams app to your organization or the Teams Store.
JavaScript and SPFx
Accounts to build your Teams app
Ensure that you have the following accounts before you start building your Teams app:
Accounts
Purpose
For environment type
Microsoft 365 work or school account
Teams developer account while developing an app.
JavaScript, TypeScript, SPFx, and C# or Blazor.
Azure account
Back-end resources on Azure.
JavaScript, TypeScript, SPFx, and C# or Blazor.
SharePoint collection site administrator account
Deployment for hosting.
SPFx.
Microsoft 365 developer program
Note
To build Teams apps, you must have a work or school Microsoft 365 account. Microsoft 365 personal account can't be used.
If you have a Visual Studio Enterprise or Professional subscription, both programs include a free Microsoft 365 developer subscription. It's active as long as your Visual Studio subscription is active. For more information, see Microsoft 365 developer subscription.
If you don't have any Microsoft 365 tenant, you might qualify for a Microsoft 365 E5 developer subscription through the Microsoft 365 Developer Program; for details, see the FAQ. Alternatively, you can sign up for a 1-month free trial or purchase a Microsoft 365 plan.
You can sign up for the developer program using one of the following account types:
	•	Microsoft account for personal use The Microsoft account provides access to the Microsoft products and cloud services, such as Outlook, Messenger, OneDrive, MSN, Xbox Live, or Microsoft 365. Sign up for an Outlook.com mailbox to create a Microsoft 365 account. Use it to access consumer-related Microsoft cloud services or Azure.    
	•	Microsoft work account for business This account provides access to all small, medium, and enterprise business-level Microsoft cloud services. The services include Azure, Microsoft Intune, and Microsoft 365. When you sign up to one of these services as an organization, a cloud-based directory is automatically provisioned in Microsoft Entra ID to represent your organization.    
Create a free Microsoft 365 developer account
To create a free Microsoft 365 developer account:
	1	Go to the Microsoft 365 developer program.
	2	Select Join Now.
	3	Set up your administrator account subscription. After the completion of the subscription, the following information appears: 
Azure account
An Azure account allows you to host a Teams app or the back-end resources for your Teams app to Azure. You can do this using Agents Toolkit in Visual Studio Code. You must have an Azure subscription in the following scenarios:
	•	If you already have an existing app on a different cloud provider other than Azure, and you want to integrate the app on Teams platform.
	•	If you want to host the back-end resources for your app using another cloud provider, or on your own servers if they're available in the public domain.
Note
You can use Azure account to provision Azure resource to host your Teams app. You can create a free account in case you don't have any. If you don't use Agents Toolkit to provision and deploy, Azure account isn't required.
SharePoint collection site administrator account
While creating Teams app using SPFx environment, you must have a SharePoint collection site administrator account. It’s required for deploying and hosting your app on SharePoint site. If you're using a Microsoft 365 developer program tenant, you can use the administrator account you created at the time.
Verify custom app upload permission
After creating the app, you must load your app in Teams without distributing it. This process is known as custom app upload. Sign in to your Microsoft 365 account to view this option.
You can verify if the app upload permission is enabled using either Visual Studio Code or Teams client.

Verify custom app upload permission using Visual Studio Code
You can use this method to verify custom app upload permission only after you have created an app project using Agents Toolkit. If you haven't created an app project, you can verify custom app upload permission using Teams client.
	1	Open Visual Studio Code.
	2	Select Microsoft 365 Agents Toolkit from the Visual Studio Code activity bar. Note If you're unable to see the option, see install Agents Toolkit to install Agents Toolkit extension in Visual Studio Code. 
	3	Create a new Agents Toolkit app project or open an existing app project.
	4	Select Sign in to Microsoft 365 under ACCOUNTS. 
	5	Verify if you can see the option Custom App Upload Enabled as shown in the following image: 

Verify custom app upload permission using Teams client
	1	In the Teams client, select Apps > Manage your apps > Upload an app. 
	2	Check if you can see the option Upload a custom app. 
Enable custom app upload using admin center
If the custom app upload option isn’t visible in Agents Toolkit extension in Visual Studio Code or if the option to upload a custom app isn’t available in Teams, it indicates that you don't have the required permission for custom app upload.
You must enable custom app upload in Teams:
	•	If you're a Teams Administrator, enable the custom app upload setting for your tenant or organization in the Teams admin center.
	•	If you aren't a Teams Administrator, contact your admin to enable custom app upload.
If you have admin rights, you can enable custom app upload:
	1	Sign in to Microsoft 365 admin center with your admin credentials.
	2	Select the icon > Teams.  Note It can take up to 24 hours for the Teams option to appear. You can upload your custom app to a Teams environment for testing and validation. 
	3	Sign in to Microsoft Teams admin center with your admin credentials.
	4	Select the icon > Teams apps > Setup policies. 
	5	Select Global (Org-wide default). 
	6	Set Upload custom apps toggle to On. 
	7	Select Save. Note It can take up to 24 hours for custom app upload to become active. In the meantime, you can use upload for your tenant to test your app. To upload the .zip package file of the app, see upload custom apps.  Ensure that you have the app upload permission using the steps mentioned in verify custom app upload permission using Visual Studio Code or Teams client.
See also
	•	Microsoft 365 Agents Toolkit Overview
	•	Manage custom app policies and settings in Teams
	•	Manage app setup policies in Teams





In this article


en-us
Theme
	•	Light
	•	Dark
	•	High contrast
	•	AI Disclaimer
	•	Previous Versions
	•	Blog
	•	Contribute
	•	Privacy
	•	Terms of Use
	•	Trademarks
	•	© Microsoft 2025


</doc 27>